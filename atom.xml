<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>拾忆鱼&#39;s Blog</title>
  
  <subtitle>愿为江水 与君重逢</subtitle>
  <link href="https://www.haipeng-lin.cn/atom.xml" rel="self"/>
  
  <link href="https://www.haipeng-lin.cn/"/>
  <updated>2024-10-28T13:10:41.621Z</updated>
  <id>https://www.haipeng-lin.cn/</id>
  
  <author>
    <name>拾忆鱼</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于微信公众号+验证码实现微信登录</title>
    <link href="https://www.haipeng-lin.cn/posts/8239deef.html"/>
    <id>https://www.haipeng-lin.cn/posts/8239deef.html</id>
    <published>2024-10-28T13:05:25.000Z</published>
    <updated>2024-10-28T13:10:41.621Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1实现方案选择"><a class="markdownIt-Anchor" href="#1实现方案选择"></a> 1.实现方案选择</h2><p>​我们在生活中，随处可见基于微信扫码登录的场景，例如一些招聘网站、牛客网、力扣等等。但是这种微信扫码登录方式，需要微信公众号是微信认证的，个人公众号没有这个权限。我们便采用了另一种方式：基于微信公众号+验证码登录</p><h2 id="2必备知识"><a class="markdownIt-Anchor" href="#2必备知识"></a> 2.必备知识</h2><h3 id="21何为半长连接"><a class="markdownIt-Anchor" href="#21何为半长连接"></a> 2.1何为半长连接</h3><p>​半长连接，可以分成两个部分理解，一个是半连接，一个是长连接。</p><p>​其中长连接，我们使用了SSE协议，服务端发送事件，单双工通信，即服务端可以主动向客户端推送信息，但是客户端不可以主动推送信息</p><p>​其中半连接，类似于<strong>TCP半连接</strong>，TCP半连接是指在TCP三次握手过程中，服务端开启第二次握手时候的状态，半连接状态。此时，服务器已接收到客户端的连接请求，并发送了确认，但<strong>不可以确认服务端发送的消息是否能到达客户端</strong>，需要等待客户端发回确认包，才可以建立可靠的连接，所以此时称为半连接状态。</p><p>  而与这个行为类似的，在用户点击登录按钮后，视为发出登录请求，视作第一次握手，此时<strong>服务端根据设备id提供验证码，视作第二次握手</strong>，而将验证码和SSE协议共同维护在cache中，等同<strong>将socket维护在半连接队列中</strong>，最后用户在微信端输入验证码，则是第三次握手了，主要是 应用层连接这个概念和传输层连接概念的相似性</p><h3 id="22登录流程"><a class="markdownIt-Anchor" href="#22登录流程"></a> 2.2登录流程</h3><p>​如图，为知识流平台的基于微信公众号+验证码的微信登录流程</p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/知识流——基于微信公众号+验证码实现登录.drawio.png" alt="知识流——基于微信公众号+验证码实现登录.drawio" style="zoom: 30%;" /><h2 id="3项目实战"><a class="markdownIt-Anchor" href="#3项目实战"></a> 3.项目实战</h2><h3 id="31微信公众号设置"><a class="markdownIt-Anchor" href="#31微信公众号设置"></a> 3.1微信公众号设置</h3><p>​要配置的内容主要有三项：服务器地址、令牌、消息加解密密钥，服务器地址填服务端绑定公众号的回调接口，令牌用于认证请求是否合法（可随便配置，看服务端是否有要求）</p><p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410282110525.png" alt="image-20241028192947512" /></p><h3 id="32服务端配置"><a class="markdownIt-Anchor" href="#32服务端配置"></a> 3.2服务端配置</h3><h4 id="321服务端token验证-消息回调"><a class="markdownIt-Anchor" href="#321服务端token验证-消息回调"></a> 3.2.1服务端token验证、消息回调</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;wx&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WxCallbackRestController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 微信的公众号接入 token 验证，即返回echostr的参数值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@GetMapping(path = &quot;callback&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">check</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">echoStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;echostr&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNoneEmpty(echoStr)) &#123;</span><br><span class="line">            <span class="keyword">return</span> echoStr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * fixme: 需要做防刷校验</span></span><br><span class="line"><span class="comment">     * 微信的响应返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(path = &quot;callback&quot;,</span></span><br><span class="line"><span class="meta">            consumes = &#123;&quot;application/xml&quot;, &quot;text/xml&quot;&#125;,</span></span><br><span class="line"><span class="meta">            produces = &quot;application/xml;charset=utf-8&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> BaseWxMsgResVo <span class="title function_">callBack</span><span class="params">(<span class="meta">@RequestBody</span> WxTxtMsgReqVo msg)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> msg.getContent();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;subscribe&quot;</span>.equals(msg.getEvent()) || <span class="string">&quot;scan&quot;</span>.equalsIgnoreCase(msg.getEvent())) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> msg.getEventKey();</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(key) || key.startsWith(<span class="string">&quot;qrscene_&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 带参数的二维码，扫描、关注事件拿到之后，直接登录，省却输入验证码这一步</span></span><br><span class="line">                <span class="comment">// fixme 带参数二维码需要 微信认证，个人公众号无权限</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> key.substring(<span class="string">&quot;qrscene_&quot;</span>.length());</span><br><span class="line">                sessionService.autoRegisterWxUserInfo(msg.getFromUserName());</span><br><span class="line">                qrLoginHelper.login(code);</span><br><span class="line">                <span class="type">WxTxtMsgResVo</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WxTxtMsgResVo</span>();</span><br><span class="line">                res.setContent(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">                fillResVo(res, msg);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">BaseWxMsgResVo</span> <span class="variable">res</span> <span class="operator">=</span> wxHelper.buildResponseBody(msg.getEvent(), content, msg.getFromUserName());</span><br><span class="line">        fillResVo(res, msg);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="322建立半长连接"><a class="markdownIt-Anchor" href="#322建立半长连接"></a> 3.2.2建立半长连接</h4><p>​当用户点击登录，前台会展示一个公众号二维码图片和验证码，此时服务端已经建立了该验证码和半长连接之间的映射，这时服务端会等待用户到公众号平台发送验证码</p><ul><li>后端设计：<ul><li>verifyCodeCache：缓存 <strong>验证码</strong> 和 <strong>半长连接</strong> 的映射</li><li>deviceCodeCache：缓存 <strong>设备ID</strong> 和 <strong>验证码</strong> 的映射，确保同一台设备多次访问前台登录页面，展示的验证码只有一个，用户刷新验证码动作除外</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* key = 验证码, value = 半长连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> LoadingCache&lt;String, SseEmitter&gt; verifyCodeCache;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* key = 设备ID value = 验证码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> LoadingCache&lt;String, String&gt; deviceCodeCache;</span><br></pre></td></tr></table></figure><ul><li>用户每次访问前台展示验证码页面，都会<strong>重新生成验证码和半长连接的映射</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 建立验证码与半长连接的映射，基于设备ID和验证码的映射获取验证码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> SseEmitter <span class="title function_">subscribe</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">deviceId</span> <span class="operator">=</span> ReqInfoContext.getReqInfo().getDeviceId();</span><br><span class="line">    <span class="comment">// 基于设备获取验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">realCode</span> <span class="operator">=</span> deviceCodeCache.getUnchecked(deviceId) ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme 设置15min的超时时间, 超时时间一旦设置不能修改；因此导致刷新验证码并不会增加连接的有效期</span></span><br><span class="line">    <span class="type">SseEmitter</span> <span class="variable">sseEmitter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SseEmitter</span>(SSE_EXPIRE_TIME);</span><br><span class="line">    <span class="type">SseEmitter</span> <span class="variable">oldSse</span> <span class="operator">=</span> verifyCodeCache.getIfPresent(realCode);</span><br><span class="line">    <span class="keyword">if</span> (oldSse != <span class="literal">null</span>) &#123;</span><br><span class="line">        oldSse.complete();</span><br><span class="line">    &#125;</span><br><span class="line">    verifyCodeCache.put(realCode, sseEmitter);</span><br><span class="line">    sseEmitter.onTimeout(() -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">&quot;sse 超时中断 --&gt; &#123;&#125;&quot;</span>, realCode);</span><br><span class="line">        verifyCodeCache.invalidate(realCode);</span><br><span class="line">        sseEmitter.complete();</span><br><span class="line">    &#125;);</span><br><span class="line">    sseEmitter.onError((e) -&gt; &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;sse error! --&gt; &#123;&#125;&quot;</span>, realCode, e);</span><br><span class="line">        verifyCodeCache.invalidate(realCode);</span><br><span class="line">        sseEmitter.complete();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 若实际的验证码与前端显示的不同，则通知前端更新</span></span><br><span class="line">    sseEmitter.send(<span class="string">&quot;initCode!&quot;</span>);</span><br><span class="line">    sseEmitter.send(<span class="string">&quot;init#&quot;</span> + realCode);</span><br><span class="line">    <span class="keyword">return</span> sseEmitter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="323公众号消息回调"><a class="markdownIt-Anchor" href="#323公众号消息回调"></a> 3.2.3公众号消息回调</h4><p>​当用户扫码关注公众号并输入验证码后，公众号会发起回调，系统根据验证码找到该半长连接，找到该设备，并识别微信号找到用户，这时服务端向客户端推送登录成功消息，实现登录</p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410282002366.png" alt="image-20241028195945260" style="zoom:67%;" /><ul><li>输入的内容为验证码</li></ul><p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410282004493.png" alt="image-20241028200245042" /></p><ul><li>微信公众号登录</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 微信公众号登录</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> verifyCode 用户输入的登录验证码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String verifyCode)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过验证码找到对应的长连接</span></span><br><span class="line">    <span class="type">SseEmitter</span> <span class="variable">sseEmitter</span> <span class="operator">=</span> verifyCodeCache.getIfPresent(verifyCode);</span><br><span class="line">    <span class="keyword">if</span> (sseEmitter == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">session</span> <span class="operator">=</span> sessionService.loginByWx(ReqInfoContext.getReqInfo().getUserId());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 登录成功，写入session</span></span><br><span class="line">        sseEmitter.send(session);</span><br><span class="line">        <span class="comment">// 设置cookie的路径</span></span><br><span class="line">        sseEmitter.send(<span class="string">&quot;login#&quot;</span> + LoginService.SESSION_KEY + <span class="string">&quot;=&quot;</span> + session + <span class="string">&quot;;path=/;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;登录异常: &#123;&#125;&quot;</span>, verifyCode, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sseEmitter.complete();</span><br><span class="line">        verifyCodeCache.invalidate(verifyCode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="33测试"><a class="markdownIt-Anchor" href="#33测试"></a> 3.3测试</h3><ul><li>前台页面</li></ul><p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410282037716.png" alt="image-20241028203719799" /></p><ul><li>公众号平台</li></ul><p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410282039965.png" alt="image-20241028203947882" /></p><h2 id="4总结"><a class="markdownIt-Anchor" href="#4总结"></a> 4.总结</h2><p>​我们在本篇中，实现了基于微信公众号和验证码的登录方式，使用了SSE作为验证码和前端保持连接的方式，同时学习了半连接、长连接、半长连接的定义、区别、以及联系</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="【知识流】" scheme="https://www.haipeng-lin.cn/categories/%E3%80%90%E7%9F%A5%E8%AF%86%E6%B5%81%E3%80%91/"/>
    
    
  </entry>
  
  <entry>
    <title>ElasticSearch学习笔记</title>
    <link href="https://www.haipeng-lin.cn/posts/172c1a2d.html"/>
    <id>https://www.haipeng-lin.cn/posts/172c1a2d.html</id>
    <published>2024-10-16T03:36:17.000Z</published>
    <updated>2024-10-16T03:39:14.951Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1elasticsearch是什么"><a class="markdownIt-Anchor" href="#1elasticsearch是什么"></a> 1.ElasticSearch是什么</h1><h2 id="11elasticsearch简介"><a class="markdownIt-Anchor" href="#11elasticsearch简介"></a> 1.1ElasticSearch简介</h2><p>  Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎</p><ol><li><p><strong>ElasticSearch特点：</strong></p><ol><li>分布式的文件存储，<strong>每个字段都被索引</strong>且可用于搜索。</li><li><strong>分布式</strong>的实时分析搜索引擎，<strong>海量数据</strong>下近实时秒级响应。</li><li>简单的<strong>restful api</strong>，天生的兼容多语言开发。</li><li><strong>易扩展</strong>，处理PB级结构化或非结构化数据</li></ol></li><li><p><strong>ElasticSearch缺点：</strong></p><ol><li>由于 Elasticsearch 需要处理大量的数据，因此需要<strong>较高的硬件性能</strong>和存储空间。</li><li>由于 Elasticsearch 是一个分布式系统，可能存在<strong>数据一致性</strong>问题</li></ol></li><li><p><strong>适用场景：</strong></p><ol><li>日志分析：Elasticsearch 可以快速地搜索和分析大量的日志数据。</li><li>搜索引擎：Elasticsearch 可以作为搜索引擎用于搜索和排序数据。</li><li>数据分析：Elasticsearch 可以用于数据分析，支持聚合和分析数据。</li><li>地理位置搜索：Elasticsearch 支持地理位置搜索，可以用于地图应用等。</li></ol></li></ol><h2 id="12es与solr对比"><a class="markdownIt-Anchor" href="#12es与solr对比"></a> 1.2ES与Solr对比</h2><ol><li>Solr是Apache Lucene项目的开源<strong>企业搜索平台</strong>。其主要功能包括<strong>全文检索</strong>、命中标示、分面搜索、动态聚类、数据库集成，以及富文本（如Word、PDF）的处理；Solr是高度可扩展的，并提供了分布式搜索和索引复制功能</li><li>当单纯的对<strong>已有数据</strong>进行搜索时，Solr更快；当实时建立索引时，Solr会产生io阻塞，查询性能较差</li><li>随着<strong>数据量的增加</strong>，Solr的搜索效率会变得更<strong>低</strong>，而Elasticsearch却没有明显的变化。</li></ol><h2 id="13es与mysql对比"><a class="markdownIt-Anchor" href="#13es与mysql对比"></a> 1.3ES与MySQL对比</h2><ol><li>结论：ElasticSearch比MySQL查询快，原因如下：</li><li><strong>基于分词后的全文检索：</strong><ol><li>例如select * from test where name like ‘%张三%’，对于mysql来说，因为索引失效，会进行全表检索；</li><li>对es而言分词后，每个字都可以利用FST高速找到倒排索引的位置，并迅速获取文档id列表，大大的提升了性能，减少了磁盘IO</li></ol></li><li><strong>精确检索：</strong><ol><li>进行精确检索，有些时候可能mysql要快一些，当mysql的非聚合索引引用上了聚合索引，无需回表，则速度上可能更快；</li><li>es还是通过FST找到倒排索引的位置比获取文档id列表，再根据文档id获取文档并根据相关度进行排序</li><li>但是es还有个优势，就是es即天然的分布式能够在大量数据搜索时可以通过分片降低检索规模，并且可以通过并行检索提升效率，用filter时，更是可以直接跳过检索直接走缓存</li></ol></li></ol><h2 id="14es基本概念"><a class="markdownIt-Anchor" href="#14es基本概念"></a> 1.4ES基本概念</h2><p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410161110837.jpeg" alt="img" /></p><h3 id="141index-索引"><a class="markdownIt-Anchor" href="#141index-索引"></a> 1.4.1Index-索引</h3><p>Index，即索引，关键词有两种用法，可用作动词、或者名词</p><ol><li>动词,相当于MySQL中的insert、插入</li><li>名词,相当于MySQL中的Database、数据库</li></ol><h3 id="142type-类型"><a class="markdownIt-Anchor" href="#142type-类型"></a> 1.4.2Type-类型</h3><ol><li>在Index（索引）中,可以定义一个或多个类型,每种类型的数据放一起；类似于MySQL中数据库中可以定义一个或多个表（Table）;</li><li>ES7、8版本差异：<ol><li>Elasticsearch 7. X URL中<strong>的type参数为可选</strong>。比如，索引一个文档不再要求提供文档类型。</li><li>Elasticsearch 8.X 不再支持URL中的type参数。ElasticSearch8开始，将索引从多类型迁移到单类型，每种类型文档一个独立索引</li><li><strong>原因：<strong>Elasticsearch是基于Lucene开发的搜索引擎，而</strong><mark>ES中不同type下名称相同的filed最终在Lucene中的处理方式是一样的</mark></strong>。不同type中的相同字段名称就会在处理中出现冲突的情况，<strong>导致Lucene处理效率下降</strong>，去掉type就是为了提高ES处理数据的效率。</li></ol></li></ol><h3 id="143document-文档"><a class="markdownIt-Anchor" href="#143document-文档"></a> 1.4.3Document-文档</h3><ol><li>保存到某个索引(Index)下,某种类型(Type)的一个数据(Document)，文档是JSON格式的</li><li>一个Document就像是MySQL中某个表的一条记录.</li></ol><h3 id="144倒排索引"><a class="markdownIt-Anchor" href="#144倒排索引"></a> 1.4.4倒排索引</h3><p>由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引(inverted index)</p><ul><li>索引存储示例</li></ul><p>将整句拆分为单词,将单词的值与索引存储起来,就可以根据单词查询索引位置,然后根据检索条件的相关性得分进行排序</p><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231125161941142.png" alt="image-20231125161941142" /></p><h1 id="2安装elasticsearch"><a class="markdownIt-Anchor" href="#2安装elasticsearch"></a> 2.安装ElasticSearch</h1><h2 id="21基于docker安装es与kibana"><a class="markdownIt-Anchor" href="#21基于docker安装es与kibana"></a> 2.1基于Docker安装ES与Kibana</h2><h3 id="211下载镜像文件"><a class="markdownIt-Anchor" href="#211下载镜像文件"></a> 2.1.1下载镜像文件</h3><p>elasticsearch与kibana版本是同步的</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">pull</span> <span class="string">elasticsearch:7.4.2</span> <span class="comment">#存储和检索数据</span></span><br><span class="line"><span class="string">docker</span> <span class="string">pull</span> <span class="string">kibana:7.4.2</span> <span class="comment">#可视化检索数据</span></span><br></pre></td></tr></table></figure><h3 id="212创建实例"><a class="markdownIt-Anchor" href="#212创建实例"></a> 2.1.2创建实例</h3><h4 id="1创建elasticsearch实例"><a class="markdownIt-Anchor" href="#1创建elasticsearch实例"></a> （1）创建ElasticSearch实例</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先将es的数据与配置与需要映射的文件夹创建好</span></span><br><span class="line"><span class="string">mkdir</span> <span class="string">-p</span> <span class="string">/mydata/elasticsearch/config</span></span><br><span class="line"><span class="string">mkdir</span> <span class="string">-p</span> <span class="string">/mydata/elasticsearch/data</span></span><br><span class="line"><span class="comment">#配置es地址</span></span><br><span class="line"><span class="string">echo</span> <span class="string">&quot;http.host: 0.0.0.0&quot;</span> <span class="string">&gt;&gt;</span> <span class="string">/mydata/elasticsearch/config/elasticsearch.yml</span></span><br><span class="line"><span class="comment">#保证权限</span></span><br><span class="line"><span class="string">chmod</span> <span class="string">-R</span> <span class="number">777</span> <span class="string">/mydata/elasticsearch/</span> </span><br><span class="line"><span class="comment">#创建并启动实例</span></span><br><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">--name</span> <span class="string">elasticsearch</span> <span class="string">-p</span> <span class="number">9200</span><span class="string">:9200</span> <span class="string">-p</span> <span class="number">9300</span><span class="string">:9300</span> <span class="string">\</span></span><br><span class="line"><span class="string">-e</span> <span class="string">&quot;discovery.type=single-node&quot;</span> <span class="string">\-e</span> <span class="string">ES_JAVA_OPTS=&quot;-Xms64m</span> <span class="string">-Xmx512m&quot;</span> <span class="string">\</span></span><br><span class="line"><span class="string">-v</span> <span class="string">/mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml</span> <span class="string">\</span></span><br><span class="line"><span class="string">-v</span> <span class="string">/mydata/elasticsearch/data:/usr/share/elasticsearch/data</span> <span class="string">\</span></span><br><span class="line"><span class="string">-v</span> <span class="string">/mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins</span> <span class="string">\</span></span><br><span class="line"><span class="string">-d</span> <span class="string">elasticsearch:7.4.2</span></span><br></pre></td></tr></table></figure><ul><li><p>注意：-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx256m&quot; \ 测试环境下， 设置 ES 的初始内存和最大内存， 否则会导致占用内存过多</p></li><li><p>效果：</p></li></ul><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231125163451134.png" alt="image-20231125163451134" /></p><ul><li><p>ES的9200和9300端口区别</p><ul><li><p>9200作为Http协议，主要用于外部通讯</p></li><li><p>9300作为Tcp协议，jar之间就是通过tcp协议通讯 .ES集群之间是通过9300进行通讯</p></li></ul></li></ul><blockquote><p>测试是否创建成功</p><p>192.168.234.128:9200 虚拟机地址+9200</p><p>记得防火墙开放9200端口</p></blockquote><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231125163328991.png" alt="image-20231125163328991" /></p><h4 id="2创建kibana实例"><a class="markdownIt-Anchor" href="#2创建kibana实例"></a> （2）创建Kibana实例</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">--name</span> <span class="string">kibana</span> <span class="string">-e</span> <span class="string">ELASTICSEARCH_HOSTS=http://192.168.234.128:9200</span> <span class="string">-p</span> <span class="number">5601</span><span class="string">:5601</span> <span class="string">\</span></span><br><span class="line"><span class="string">-d</span> <span class="string">kibana:7.4.2</span></span><br></pre></td></tr></table></figure><blockquote><p>测试是否创建成功</p><p>192.168.234.128:5601</p></blockquote><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231125164601714.png" alt="image-20231125164601714" style="zoom: 33%;" /><h3 id="213设置es和kibana自启动"><a class="markdownIt-Anchor" href="#213设置es和kibana自启动"></a> 2.1.3设置es和kibana自启动</h3><blockquote><p>先不设置，担心内存不够</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置es在docker开启的时候启动</span></span><br><span class="line"><span class="string">docker</span> <span class="string">update</span> <span class="string">elasticsearch</span> <span class="string">--restart=always</span></span><br><span class="line"><span class="comment"># 设置Kibana在docker开启的时候启动</span></span><br><span class="line"><span class="string">docker</span> <span class="string">update</span> <span class="string">kibana</span> <span class="string">--restart=always</span></span><br></pre></td></tr></table></figure><h2 id="22基于windows安装es与kibana"><a class="markdownIt-Anchor" href="#22基于windows安装es与kibana"></a> 2.2基于Windows安装ES与Kibana</h2><blockquote><p>待写</p></blockquote><h1 id="3初级检索"><a class="markdownIt-Anchor" href="#3初级检索"></a> 3.初级检索</h1><h2 id="31查看节点索引"><a class="markdownIt-Anchor" href="#31查看节点索引"></a> 3.1查看节点/索引</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看所有节点</span></span><br><span class="line"><span class="string">GET</span> <span class="string">/_cat/nodes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看所有节点</span></span><br><span class="line"><span class="string">GET</span> <span class="string">/_cat/health</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看主节点</span></span><br><span class="line"><span class="string">GET</span> <span class="string">/_cat/master</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看所有索引——show databases;</span></span><br><span class="line"><span class="string">GET</span> <span class="string">/_cat/indices</span></span><br></pre></td></tr></table></figure><h2 id="32索引保存文档"><a class="markdownIt-Anchor" href="#32索引保存文档"></a> 3.2索引（保存）文档</h2><h3 id="321put方法"><a class="markdownIt-Anchor" href="#321put方法"></a> 3.2.1PUT方法</h3><p><strong>保存一个数据， 保存在哪个索引的哪个类型下， 指定用哪个唯一标识</strong></p><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231125170734843.png" alt="image-20231125170734843" /></p><h3 id="322post方法"><a class="markdownIt-Anchor" href="#322post方法"></a> 3.2.2POST方法</h3><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231125171504137.png" alt="image-20231125171504137" /></p><h3 id="323put和post的区别"><a class="markdownIt-Anchor" href="#323put和post的区别"></a> 3.2.3PUT和POST的区别</h3><ul><li><p>相同</p><ul><li><p>PUT与POST都可以新增与修改文档</p></li><li><p>PUT与POST修改文档都是指定id再索引一次</p></li></ul></li><li><p>不同—<strong>新增上</strong></p><ul><li><strong>PUT新增只能自定义id</strong>，不能自动生成（PUT本就是设定用来修改的）</li><li><strong>POST新增可以不带id（自动生成），也可以自定义id</strong></li></ul></li><li><p>补充</p><ul><li>PUT修改必须指定文档id、否则报错</li><li>POST修改若指定存在的文档id，则为修改；若指定不存在或者没有接上文档id，则为新增</li></ul></li></ul><h2 id="33查询指定id文档"><a class="markdownIt-Anchor" href="#33查询指定id文档"></a> 3.3查询指定id文档</h2><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231125172846736.png" alt="image-20231125172846736" /></p><h2 id="34更新文档"><a class="markdownIt-Anchor" href="#34更新文档"></a> 3.4更新文档</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 之前就是这种写法：版本直接加</span></span><br><span class="line"><span class="string">POST</span> <span class="string">customer/external/1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;:</span> <span class="string">&quot;John Doe2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会对比之前的内容，相同则版本不变</span></span><br><span class="line"><span class="string">POST</span> <span class="string">customer/external/1/_update</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;doc&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;:</span> <span class="string">&quot;John Doe2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新同时增加属性</span></span><br><span class="line"><span class="string">PUT</span> <span class="string">customer/external/1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;:</span> <span class="string">&quot;John Doe3&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新同时增加属性</span></span><br><span class="line"><span class="string">POST</span> <span class="string">customer/external/1/_update</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;doc&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;:</span> <span class="string">&quot;Jane Doe&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;age&quot;:</span> <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>POST方式一与方式二的区别是否带update</p><ul><li><p><strong>带_update的POST更新：会对比源文档数据</strong>， 如果相同不会有什么操作， 文档 version 不增加</p></li><li><p>不带_update的POST：总会将数据重新保存并增加 version 版本</p></li><li><p>PUT 操作总会将数据重新保存并增加 version 版本；</p></li></ul><h2 id="35删除索引"><a class="markdownIt-Anchor" href="#35删除索引"></a> 3.5删除索引</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除文档</span></span><br><span class="line"><span class="string">DELETE</span> <span class="string">customer/external/1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除索引</span></span><br><span class="line"><span class="string">DELETE</span> <span class="string">customer</span></span><br></pre></td></tr></table></figure><h2 id="36bulk批量api"><a class="markdownIt-Anchor" href="#36bulk批量api"></a> 3.6bulk批量API</h2><p>在单个 API 调用中执行<mark>多个索引或删除操作</mark>。这减少了开销并且可以大大提高索引速度。</p><h3 id="361语法格式"><a class="markdownIt-Anchor" href="#361语法格式"></a> 3.6.1语法格式</h3><blockquote><p>{ action: { metadata }} //action: 操作; metadata:对哪一个数据进行操作</p><p>{ request body } //操作的内容</p><p>{ action: { metadata }}</p><p>{ request body }</p><p>两个一组</p></blockquote><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231125223007146.png" alt="image-20231125223007146" /></p><h3 id="362复杂bulk"><a class="markdownIt-Anchor" href="#362复杂bulk"></a> 3.6.2复杂bulk</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /_bulk</span><br><span class="line">&#123; <span class="string">&quot;delete&quot;</span>: &#123; <span class="string">&quot;_index&quot;</span>: <span class="string">&quot;website&quot;</span>, <span class="string">&quot;_type&quot;</span>: <span class="string">&quot;blog&quot;</span>, <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;123&quot;</span> &#125;&#125;</span><br><span class="line">&#123; <span class="string">&quot;create&quot;</span>: &#123; <span class="string">&quot;_index&quot;</span>: <span class="string">&quot;website&quot;</span>, <span class="string">&quot;_type&quot;</span>: <span class="string">&quot;blog&quot;</span>, <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;123&quot;</span> &#125;&#125;</span><br><span class="line">&#123; <span class="string">&quot;title&quot;</span>: <span class="string">&quot;My first blog post&quot;</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;index&quot;</span>: &#123; <span class="string">&quot;_index&quot;</span>: <span class="string">&quot;website&quot;</span>, <span class="string">&quot;_type&quot;</span>: <span class="string">&quot;blog&quot;</span> &#125;&#125;  </span><br><span class="line">&#123; <span class="string">&quot;title&quot;</span>: <span class="string">&quot;My second blog post&quot;</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;update&quot;</span>: &#123; <span class="string">&quot;_index&quot;</span>: <span class="string">&quot;website&quot;</span>, <span class="string">&quot;_type&quot;</span>: <span class="string">&quot;blog&quot;</span>, <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;123&quot;</span>&#125;&#125;</span><br><span class="line">&#123; <span class="string">&quot;doc&quot;</span> : &#123;<span class="string">&quot;title&quot;</span> : <span class="string">&quot;My updated blog post&quot;</span>&#125; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>bulk API 以此按顺序执行所有的 action（动作） 。 如果一个单个的动作因任何原因而失败，它将继续处理它后面剩余的动作。 当 bulk API 返回时， 它将提供每个动作的状态（与发送的顺序相同） ， 所以您可以检查是否一个指定的动作是不是失败了。</p></blockquote><h1 id="4进阶检索"><a class="markdownIt-Anchor" href="#4进阶检索"></a> 4.进阶检索</h1><h2 id="41导入数据"><a class="markdownIt-Anchor" href="#41导入数据"></a> 4.1导入数据</h2><p>数据链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://gitee.com/zhourui815/gulimall/blob/master/doc/es%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE.json#</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST bank/account/_bulk</span><br><span class="line">测试数据</span><br></pre></td></tr></table></figure><h2 id="42searchapi"><a class="markdownIt-Anchor" href="#42searchapi"></a> 4.2SearchAPI</h2><p>ES 支持两种基本方式检索 :</p><ul><li>一个是通过使用 REST request URI 发送搜索参数（uri+检索参数）</li><li>另一个是通过使用 REST request body 来发送它们（uri+请求体</li></ul><h3 id="421检索信息"><a class="markdownIt-Anchor" href="#421检索信息"></a> 4.2.1检索信息</h3><p>**一切检索从_search 开始 **</p><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231125224553112.png" alt="image-20231125224553112" /></p><h3 id="422请求参数方式检索"><a class="markdownIt-Anchor" href="#422请求参数方式检索"></a> 4.2.2请求参数方式检索</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#请求参数方式检索</span></span><br><span class="line"><span class="string">q=*</span>  <span class="string">代表要查询的字段类似于select</span> <span class="string">*</span></span><br><span class="line"><span class="string">sort=account_number:asc</span>  <span class="string">代表按照account_number字段排序,升序</span></span><br><span class="line"><span class="string">GET</span> <span class="string">bank/_search?q=*&amp;sort=account_number:asc</span></span><br></pre></td></tr></table></figure><h3 id="423uri请求体进行检索"><a class="markdownIt-Anchor" href="#423uri请求体进行检索"></a> 4.2.3uri+请求体进行检索</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#uri+请求体进行检索  </span></span><br><span class="line"><span class="string">GET</span> <span class="string">bank/_search</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;:</span> &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;:</span> [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;account_number&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;order&quot;:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="43query-dsl"><a class="markdownIt-Anchor" href="#43query-dsl"></a> 4.3Query DSL</h2><p>url+请求体</p><p>Elasticsearch 提供了一个可以执行查询的 Json 风格的 DSL（ domain-specific language 领域特定语言） 。 这个被称为 Query DSL。 该查询语言非常全面， 并且刚开始的时候感觉有点复杂，真正学好它的方法是从一些基础的示例开始的。</p><h3 id="431语法格式"><a class="markdownIt-Anchor" href="#431语法格式"></a> 4.3.1语法格式</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个查询语句 的典型结构</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">QUERY_NAME:</span> &#123;</span><br><span class="line"><span class="attr">ARGUMENT:</span> <span class="string">VALUE</span>,</span><br><span class="line"><span class="attr">ARGUMENT:</span> <span class="string">VALUE</span>,<span class="string">...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 如果是针对某个字段， 那么它的结构如下：</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">QUERY_NAME:</span> &#123;</span><br><span class="line"><span class="attr">FIELD_NAME:</span> &#123;</span><br><span class="line"><span class="attr">ARGUMENT:</span> <span class="string">VALUE</span>,</span><br><span class="line"><span class="attr">ARGUMENT:</span> <span class="string">VALUE</span>,<span class="string">...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="432查询示例"><a class="markdownIt-Anchor" href="#432查询示例"></a> 4.3.2查询示例</h3><blockquote><p>查询bank索引并按照account_number字段降序排序,分页大小为5</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基本查询示例</span></span><br><span class="line"><span class="string">GET</span> <span class="string">bank/_search</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;:</span> &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;from&quot;:</span> <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;size&quot;:</span> <span class="number">5</span>,</span><br><span class="line">  <span class="attr">&quot;sort&quot;:</span> [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;account_number&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;order&quot;:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>query 定义如何查询，</li><li>match_all 查询类型【代表查询所有的所有】 ，</li><li>es 中可以在 query 中组合非常多的查 询类型完成复杂查询</li><li>除了 query 参数之外， 我们也可以传递其它的参数以改变查询结果。 如 sort， size</li><li>from+size 限定， 完成分页功能</li><li>sort 排序， 多字段排序， 会在前序字段相等时后续字段内部排序， 否则以前序为准</li></ul></blockquote><h3 id="433match匹配"><a class="markdownIt-Anchor" href="#433match匹配"></a> 4.3.3match匹配</h3><blockquote><p>match 返回 account_number=20 的</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#match 基本类型(非字符串类型),精确匹配  </span></span><br><span class="line"><span class="string">GET</span> <span class="string">bank/_search</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;account_number&quot;:</span> <span class="string">&quot;20&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最终查询出 address 中包含 mill 单词的所有记录 match 当搜索字符串类型的时候， 会进行全文检索， 并且每条记录有相关性得分。</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#match 字符串类型,全文检索，模糊匹配</span></span><br><span class="line"><span class="string">GET</span> <span class="string">bank/_search</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;address&quot;:</span> <span class="string">&quot;mill&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最终查询出 address 中包含 mill 或者 road 或者 mill road 的所有记录， 并给出相关性得分</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#match 字符串， 多个单词（ 分词+全文检索）</span></span><br><span class="line"><span class="string">GET</span> <span class="string">bank/_search</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;address&quot;:</span> <span class="string">&quot;mill road&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="434match_phrase短语匹配"><a class="markdownIt-Anchor" href="#434match_phrase短语匹配"></a> 4.3.4match_phrase短语匹配</h3><blockquote><p>短语匹配：将需要匹配的值当成一个整体单词（ 不分词） 进行检索</p><p>查出 address 中包含 mill road 的所有记录， 并给出相关性得分</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#match_phrase 短语匹配</span></span><br><span class="line"><span class="string">GET</span> <span class="string">bank/_search</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;match_phrase&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;address&quot;:</span> <span class="string">&quot;mill road&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="435multi_match-多字段匹配"><a class="markdownIt-Anchor" href="#435multi_match-多字段匹配"></a> 4.3.5multi_match 多字段匹配</h3><blockquote><p>查询 state 或者 address字段 包含 mill</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#multi_match 多字段匹配</span></span><br><span class="line"><span class="string">GET</span> <span class="string">bank/_search</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;multi_match&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;query&quot;:</span> <span class="string">&quot;mill&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;fields&quot;:</span> [<span class="string">&quot;address&quot;</span>,<span class="string">&quot;state&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="436bool复合查询"><a class="markdownIt-Anchor" href="#436bool复合查询"></a> 4.3.6bool复合查询</h3><blockquote><p>bool 用来做复合查询：<br />复合语句可以合并 任何 其它查询语句， 包括复合语句，  复合语句之间可以互相嵌套， 可以表达非常复杂的逻辑。</p></blockquote><h4 id="1must"><a class="markdownIt-Anchor" href="#1must"></a> （1）must</h4><blockquote><p>必须达到 must 列举的所有条件</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># must 必须达到 must 列举的所有条件</span></span><br><span class="line"><span class="string">GET</span> <span class="string">bank/_search</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;:</span> [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;address&quot;:</span> <span class="string">&quot;Mill&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;gender&quot;:</span> <span class="string">&quot;M&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2should"><a class="markdownIt-Anchor" href="#2should"></a> （2）should</h4><blockquote><p>应该达到 should 列举的条件， 如果达到会增加相关文档的评分， 并不会改变查询的结果。</p><p>如果 query 中只有 should 且只有一种匹配规则， 那么 should 的条件就会被作为默认匹配条件而去改变查询结果</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应该达到 should列举的条件，如果达到会增加相关文档的评分，并不会改变查询的结果。</span></span><br><span class="line"><span class="string">GET</span> <span class="string">bank/_search</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;:</span> [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;address&quot;:</span> <span class="string">&quot;mill&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;gender&quot;:</span> <span class="string">&quot;M&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;should&quot;:</span> [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;address&quot;:</span> <span class="string">&quot;lane&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3must_not"><a class="markdownIt-Anchor" href="#3must_not"></a> （3）must_not</h4><blockquote><p>必须不是指定的情况</p><p>address 包含 mill， 并且 gender 是 M， 如果 address 里面有 lane 最好不过， 但是匹配的字段必须不是文本类型</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#must_not 必须不是指定的情况  </span></span><br><span class="line"><span class="string">GET</span> <span class="string">bank/_search</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;:</span> [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;address&quot;:</span> <span class="string">&quot;mill&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;gender&quot;:</span> <span class="string">&quot;M&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;should&quot;:</span> [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;address&quot;:</span> <span class="string">&quot;lane&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;must_not&quot;:</span> [</span><br><span class="line">        &#123;<span class="attr">&quot;match&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;FIELD&quot;:</span> <span class="string">&quot;TEXT&quot;</span></span><br><span class="line">        &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4filter结果过滤"><a class="markdownIt-Anchor" href="#4filter结果过滤"></a> （4）filter结果过滤</h4><blockquote><p>并不是所有的查询都需要产生分数， 特别是那些仅用于 “filtering”（过滤） 的文档。 **为了不计算分数 **Elasticsearch 会自动检查场景并且优化查询的执行。</p></blockquote><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231125233601072.png" alt="image-20231125233601072" /></p><h4 id="5小结"><a class="markdownIt-Anchor" href="#5小结"></a> （5）小结</h4><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231125233651828.png" alt="image-20231125233651828" /></p><h3 id="437term非text字段检索"><a class="markdownIt-Anchor" href="#437term非text字段检索"></a> 4.3.7term—非text字段检索</h3><blockquote><p>和 match 一样。 匹配某个属性的值。 全文检索字段用 match， 其他<strong>非 text 字段</strong>匹配用 term。</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#term 其他非 text 字段检索</span></span><br><span class="line"><span class="string">GET</span> <span class="string">bank/_search</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;:</span> [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;term&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;account_number&quot;:</span> &#123;</span><br><span class="line">              <span class="attr">&quot;value&quot;:</span> <span class="string">&quot;970&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;address&quot;:</span> <span class="string">&quot;Mill&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="438aggregations聚合检索"><a class="markdownIt-Anchor" href="#438aggregations聚合检索"></a> 4.3.8aggregations聚合检索</h3><ol><li>最简单的聚合方法大致等于 SQL GROUP BY 和 SQL 聚合函数。</li><li>在 Elasticsearch 中， 您有执行搜索返回 hits（ 命中结果），并且同时返回聚合结果， 把一个响应中的所有 hits（ 命中结果） 分隔开的能力。</li><li>可以执行查询和多个聚合， 并且在一次使用中得到各自的（ 任何一个的） 返回结果， 使用一次简洁和简化的 API 来避免网络往返。</li></ol><blockquote><p>写在前面：有很多种聚合方式：terms、avgs聚合</p></blockquote><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126091812312.png" alt="image-20231126091812312" style="zoom:50%;" /><h4 id="1年龄分布-并求出年龄的平均值"><a class="markdownIt-Anchor" href="#1年龄分布-并求出年龄的平均值"></a> （1）年龄分布、并求出年龄的平均值</h4><blockquote><p>搜索 address 中包含 mill 的所有人的年龄分布以及平均年龄， 但不显示这些人的详情（size=0）</p></blockquote><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126092304394.png" alt="image-20231126092304394" style="zoom: 50%;" /><h4 id="2求出年龄分布并在每个年龄求平均薪资"><a class="markdownIt-Anchor" href="#2求出年龄分布并在每个年龄求平均薪资"></a> （2）求出年龄分布,并在每个年龄求平均薪资</h4><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126092648463.png" alt="image-20231126092648463" /></p><h2 id="44mapping"><a class="markdownIt-Anchor" href="#44mapping"></a> 4.4Mapping</h2><h3 id="441字段类型"><a class="markdownIt-Anchor" href="#441字段类型"></a> 4.4.1字段类型</h3><ol><li>字段类型有核心类型、复合类型、地理类型、特定类型以及多字段类型共5种</li><li><strong>核心类型：</strong><ol><li>字符串：string、text、keyword</li><li>数字类型：long、integer、short、byte、double、float</li><li>日期类型：date</li><li>布尔类型：boolean</li><li>二进制类型：binary</li></ol></li><li>**复合类型：**数组类型（Array）、对象类型（Object）、嵌套类型（Nested）</li><li>**地理类型：**地理坐标（Geo-points）、地理图形（Geo-Shape）</li><li>**特定类型：**IP类型（ip）、补全类型（Completion）、令牌计数类型（Token count）、附件类型（attachment）</li><li>**多字段类型：**通常用于为不同目的用不同的方法索I同一个字段。例如，<strong>string字段</strong>可以映射为一个text字段用于全文检索，同样可以映射为一个keyword字段用于排序和聚合</li></ol><h3 id="442映射简介"><a class="markdownIt-Anchor" href="#442映射简介"></a> 4.4.2映射简介</h3><ol><li>定义：Mapping 是用来定义一个文档（ document） ， 以及它所包含的属性（ field） 是如何存储和索引的。 比如， 使用 mapping 来定义：<ol><li>哪些字符串属性应该被看做全文本属性（full text fields）</li><li>哪些属性包含数字， 日期或者地理位置。</li><li>文档中的所有属性是否都能被索引</li></ol></li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看mapping信息</span></span><br><span class="line"><span class="string">GET</span> <span class="string">bank/_mapping</span></span><br></pre></td></tr></table></figure><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126093413138.png" alt="image-20231126093413138" style="zoom:50%;" /><ul><li>问题：我们在创建索引是没有指定类型，为什么会查询出来呢?</li><li>答案：es会根据数据自动猜测的映射类型，自动猜测的映射类型有：<ul><li>布尔型：true或者false，猜测的映射类型为boolean</li><li>整数：123，猜测的映射类型为long</li><li>浮点数：123.45，猜测的映射类型为double</li><li>字符串，有效日期：2024-10-10，猜测的映射类型为date</li><li>字符串：foo bar，猜测的映射类型为string</li></ul></li></ul><h3 id="443创建映射"><a class="markdownIt-Anchor" href="#443创建映射"></a> 4.4.3创建映射</h3><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126094141793.png" alt="image-20231126094141793" /></p><h3 id="444更新映射"><a class="markdownIt-Anchor" href="#444更新映射"></a> 4.4.4更新映射</h3><p>对于已经存在的映射字段， 我们不能更新。 更新必须创建新的索引进行数据迁移</p><h3 id="445数据迁移"><a class="markdownIt-Anchor" href="#445数据迁移"></a> 4.4.5数据迁移</h3><h4 id="1查询之前的映射"><a class="markdownIt-Anchor" href="#1查询之前的映射"></a> （1）查询之前的映射</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">GET</span> <span class="string">bank/_mapping</span></span><br></pre></td></tr></table></figure><ul><li>将查询的字段映射复制出来</li><li>假设age字段类型为long，想换成integer类型</li></ul><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126100102484.png" alt="image-20231126100102484" /></p><h4 id="2新增一个新索引"><a class="markdownIt-Anchor" href="#2新增一个新索引"></a> （2）新增一个新索引</h4><p>将复制的属性粘贴到属性中，先不执行</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;account_number&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;long&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;address&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;keyword&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignore_above&quot;</span> <span class="punctuation">:</span> <span class="number">256</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;long&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;balance&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;long&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;city&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;keyword&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignore_above&quot;</span> <span class="punctuation">:</span> <span class="number">256</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;email&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;keyword&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignore_above&quot;</span> <span class="punctuation">:</span> <span class="number">256</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;employer&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;keyword&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignore_above&quot;</span> <span class="punctuation">:</span> <span class="number">256</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;firstname&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;keyword&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignore_above&quot;</span> <span class="punctuation">:</span> <span class="number">256</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;gender&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;keyword&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignore_above&quot;</span> <span class="punctuation">:</span> <span class="number">256</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;lastname&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;keyword&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignore_above&quot;</span> <span class="punctuation">:</span> <span class="number">256</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;state&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;keyword&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignore_above&quot;</span> <span class="punctuation">:</span> <span class="number">256</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3修改映射"><a class="markdownIt-Anchor" href="#3修改映射"></a> （3）修改映射</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个新索引</span></span><br><span class="line"><span class="string">PUT</span> <span class="string">newbank2</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span><span class="string">:</span>&#123;</span><br><span class="line">    <span class="attr">&quot;properties&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;account_number&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;long&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;address&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;text&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;age&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;balance&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;long&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;city&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;text&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;fields&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;keyword&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;ignore_above&quot;:</span> <span class="number">256</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;email&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;text&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;fields&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;keyword&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;ignore_above&quot;:</span> <span class="number">256</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;employer&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;text&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;fields&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;keyword&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;ignore_above&quot;:</span> <span class="number">256</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;firstname&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;text&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;fields&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;keyword&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;ignore_above&quot;:</span> <span class="number">256</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;gender&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;text&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;fields&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;keyword&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;ignore_above&quot;:</span> <span class="number">256</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;lastname&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;text&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;fields&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;keyword&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;ignore_above&quot;:</span> <span class="number">256</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;state&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;text&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;fields&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;keyword&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;ignore_above&quot;:</span> <span class="number">256</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4数据迁移"><a class="markdownIt-Anchor" href="#4数据迁移"></a> （4）数据迁移</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数据迁移</span></span><br><span class="line"><span class="string">POST</span> <span class="string">_reindex</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;:</span> <span class="string">&quot;bank&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;:</span> <span class="string">&quot;newbank2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>迁移成功</p></blockquote><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126101222331.png" alt="image-20231126101222331" /></p><h2 id="45分词待重写"><a class="markdownIt-Anchor" href="#45分词待重写"></a> <mark>4.5分词（待重写）</mark></h2><ol><li><p>在ES中，一个 tokenizer（ 分词器） 接收一个字符流， 将之分割为独立的 tokens（ 词元， 通常是独立的单词） ， 然后输出 tokens 流。</p><ol><li>例如， whitespace tokenizer 遇到空白字符时分割文本。 它会将文本 “Quick brown fox!” 分割为 [Quick, brown, fox!]。</li><li>该 tokenizer（分词器） 还负责记录各个 term（词条） 的顺序或 position 位置（用于 phrase 短语和 word proximity 词近邻查询） ， 以及 term（词条） 所代表的原始 word（单词） 的 start（起始） 和 end（结束） 的 character offsets（字符偏移量） （用于高亮显示搜索的内容） 。</li></ol></li><li><p>Elasticsearch 提供了很多内置的分词器， 可以用来构建 custom analyzers（自定义分词器） 。</p></li></ol><h3 id="451安装ik分词器"><a class="markdownIt-Anchor" href="#451安装ik分词器"></a> 4.5.1安装ik分词器</h3><p>没有安装分词器之前的效果</p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126102404692.png" alt="image-20231126102404692" style="zoom:50%;" /><p>**注意： 不能用默认 elasticsearch-plugin install xxx.zip 进行自动安装 **</p><blockquote><p>由于之前映射了plugins目录,所以在/mydata/elasticsearch/plugins/下载elasticsearch-analysis-ik-7.4.2.zip</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.4.2/elasticsearch-analysis-ik-7.4.2.zip</span><br></pre></td></tr></table></figure><blockquote><p>解压</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip elasticsearch-analysis-ik-7.4.2.zip</span><br></pre></td></tr></table></figure><blockquote><p>删除zip文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm –rf *.zip</span><br></pre></td></tr></table></figure><blockquote><p>将elasticsearch文件夹下的所有文件 移动至ik目录下(自建目录)</p></blockquote><p><mark><strong>使用xftp进行移动</strong></mark></p><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126110523062.png" alt="image-20231126110523062" /></p><blockquote><p>修改ik文件夹权限</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">chmod</span> <span class="string">-R</span> <span class="number">777</span> <span class="string">ik</span></span><br></pre></td></tr></table></figure><blockquote><p>确认是否安装好了分词器</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入容器内部</span></span><br><span class="line"><span class="string">docker</span> <span class="string">exec</span> <span class="string">-it</span> <span class="string">容器</span> <span class="string">id</span> <span class="string">/bin/bash</span></span><br><span class="line"><span class="comment">#切换目录</span></span><br><span class="line"><span class="string">cd</span> <span class="string">bin</span></span><br><span class="line"><span class="comment">#列出安装的plugin</span></span><br><span class="line"><span class="string">elasticsearch</span> <span class="string">plugin</span> <span class="string">list</span></span><br></pre></td></tr></table></figure><blockquote><p>发现ik后重启容器</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">restart</span> <span class="string">elasticsearch</span></span><br></pre></td></tr></table></figure><h3 id="452测试分词器"><a class="markdownIt-Anchor" href="#452测试分词器"></a> 4.5.2测试分词器</h3><h4 id="1使用默认分词器"><a class="markdownIt-Anchor" href="#1使用默认分词器"></a> （1）使用默认分词器</h4><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126110748326.png" alt="image-20231126110748326" /></p><h4 id="2使用ik_smart分词器"><a class="markdownIt-Anchor" href="#2使用ik_smart分词器"></a> （2）使用ik_smart分词器</h4><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126110816338.png" alt="image-20231126110816338" /></p><h4 id="3使用ik_max_word-分词器"><a class="markdownIt-Anchor" href="#3使用ik_max_word-分词器"></a> （3）使用ik_max_word 分词器</h4><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126110900124.png" alt="image-20231126110900124" /></p><h4 id="4总结"><a class="markdownIt-Anchor" href="#4总结"></a> （4）总结</h4><p>能够看出不同的分词器， 分词有明显的区别， 所以以后定义一个索引不能再使用默认的 mapping 了， 要手工建立 mapping, 因为要选择分词器。</p><h3 id="453自定义词库"><a class="markdownIt-Anchor" href="#453自定义词库"></a> 4.5.3自定义词库</h3><h3 id="454未自定义词库"><a class="markdownIt-Anchor" href="#454未自定义词库"></a> 4.5.4未自定义词库</h3><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126111345748.png" alt="image-20231126111345748" /></p><p>自定义词库测试</p><ul><li>创建词库</li></ul><blockquote><p><strong>在4.6：搭建好nginx的基础上,搭建nginx在8.x章节</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /mydata/nginx/html/</span><br><span class="line">#创建自定义词库</span><br><span class="line">vim fenci.txt</span><br></pre></td></tr></table></figure><p>添加新词</p><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126114652319.png" alt="image-20231126114652319" /></p><ul><li>修改分词器配置文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /mydata/elasticsearch/plugins/ik/config/IKAnalyzer.cfg.xml</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126120129228.png" alt="image-20231126120129228" /></p><ul><li>重启es</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart elasticsearch</span><br></pre></td></tr></table></figure><ul><li>效果</li></ul><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126120246793.png" alt="image-20231126120246793" /></p><h1 id="5springboot整合es"><a class="markdownIt-Anchor" href="#5springboot整合es"></a> 5.SpringBoot整合ES</h1><h2 id="51xml配置"><a class="markdownIt-Anchor" href="#51xml配置"></a> 5.1xml配置</h2><p>SpringBoot想和ES进行通信传递消息的方式有两种：tcp、http</p><ol><li><p>9300： TCP</p><ol><li>需要的jar包：spring-data-elasticsearch:transport-api.jar；</li><li>springboot 版本不同， transport-api.jar 不同， 不能适配 es 版本</li><li>7.x 已经不建议使用， 8 以后就要废弃</li></ol></li><li><p>9200： HTTP，有以下四种通信方式</p><ol><li>JestClient： 非官方， 更新慢</li><li>RestTemplate： 模拟发 HTTP 请求， ES 很多操作需要自己封装， 麻烦</li><li>HttpClient： 同上</li><li>Elasticsearch-Rest-Client： 官方 RestClient， 封装了 ES 操作， API 层次分明， 上手简单</li></ol></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">可能出现bug，换成以下依赖</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="52配置类"><a class="markdownIt-Anchor" href="#52配置类"></a> 5.2配置类</h2><p>主启动类添加注解：@EnableDiscoverClient</p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126171800066.png" alt="image-20231126171800066" style="zoom: 67%;" /><p>添加：配置类</p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126171821397.png" alt="image-20231126171821397" style="zoom: 50%;" /><h2 id="53测试连接"><a class="markdownIt-Anchor" href="#53测试连接"></a> 5.3测试连接</h2><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126171840588.png" alt="image-20231126171840588" style="zoom: 50%;" /><p>测试结果：</p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126171738371.png" alt="image-20231126171738371" style="zoom: 50%;" /><h2 id="54测试使用"><a class="markdownIt-Anchor" href="#54测试使用"></a> 5.4测试使用</h2><h3 id="541索引新增记录"><a class="markdownIt-Anchor" href="#541索引新增记录"></a> 5.4.1索引(新增)记录</h3><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126223459965.png" alt="image-20231126223459965" style="zoom: 50%;" /><ul><li>测试结果</li></ul><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126181349680.png" alt="image-20231126181349680" style="zoom: 50%;" /><h3 id="542获取数据"><a class="markdownIt-Anchor" href="#542获取数据"></a> 5.4.2获取数据</h3><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126223642236.png" alt="image-20231126223642236" style="zoom: 50%;" /><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#match 字符串类型全文检索</span></span><br><span class="line"><span class="string">GET</span> <span class="string">bank/_search</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;address&quot;:</span> <span class="string">&quot;mill&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>两个查询结果相同</p></blockquote><h3 id="543聚合查询"><a class="markdownIt-Anchor" href="#543聚合查询"></a> 5.4.3聚合查询</h3><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126224123565.png" alt="image-20231126224123565" style="zoom:50%;" /><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126224024399.png" alt="image-20231126224024399" style="zoom:50%;" /><h3 id="544结果转为对象"><a class="markdownIt-Anchor" href="#544结果转为对象"></a> 5.4.4结果转为对象</h3><blockquote><p>具体结果在下面那个hits里</p></blockquote><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126224247804.png" alt="image-20231126224247804" style="zoom:50%;" /><blockquote><p>利用json生成javabean,并使用lombok</p></blockquote><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126224421195.png" alt="image-20231126224421195" style="zoom:50%;" /><ul><li>测试</li></ul><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126224706454.png" alt="image-20231126224706454" style="zoom: 67%;" /><ul><li>结果</li></ul><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20231126224630489.png" alt="image-20231126224630489" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="【技术栈学习】" scheme="https://www.haipeng-lin.cn/categories/%E3%80%90%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AD%A6%E4%B9%A0%E3%80%91/"/>
    
    
    <category term="SpringBoot" scheme="https://www.haipeng-lin.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ学习笔记</title>
    <link href="https://www.haipeng-lin.cn/posts/6982816f.html"/>
    <id>https://www.haipeng-lin.cn/posts/6982816f.html</id>
    <published>2024-10-13T09:17:30.000Z</published>
    <updated>2024-10-14T06:44:07.399Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1rocketmq是什么"><a class="markdownIt-Anchor" href="#1rocketmq是什么"></a> 1.RocketMQ是什么？</h2><p>​  阿里开源的一款的消息中间件，纯Java开发，具有<strong>高吞吐量、高可用性</strong>、适合<strong>大规模分布式系统</strong>应用的特点，性能强劲(零拷贝技术)，支持海量堆积，支持指定次数和时间间隔的失败，消息重发,支持consumer端tag过滤、延迟消息等，在阿里内部进行大规模使用，适合在<strong>电商，互联网金融</strong>等领域使用</p><h2 id="2rocketmq架构设计"><a class="markdownIt-Anchor" href="#2rocketmq架构设计"></a> 2.RocketMQ架构设计</h2><h3 id="21技术架构"><a class="markdownIt-Anchor" href="#21技术架构"></a> 2.1技术架构</h3><p>RocketMQ架构主要由四部分组成，可在2.2部署架构见RocketMQ集群部署图</p><ul><li><strong>Producer：消息生产者</strong>，可集群部署。会先和 NameServer 集群中的随机一台建立长连接，得知当前要发送的 Topic 存在哪台 Broker Master上，然后再与其建立长连接，定时向Broker发送心跳。同时支持多种负载平衡模式发送消息。</li><li><strong>Consumer：消息消费者</strong>，可以集群部署。会先和 NameServer 集群中的随机一台建立长连接，得知当前要消息的 Topic 存在哪台 Broker Master、Slave上，然后它们建立长连接，定时向Broker发送心跳。同时支持集群消费和广播消费消息。</li><li><strong>Broker：主要负责消息的存储、查询消费</strong>，支持主从部署，一个 Master 可以对应多个 Slave。Master 支持读写，Slave 只支持读。Broker 会向集群中的每一台 NameServer 注册自己的路由信息。定期30s向NameServer上报Topic路由信息。</li><li><strong>NameServer：是Topic 路由注册中心</strong>，支持 Broker 的动态注册和发现，保存 Topic 和 Borker 之间的关系。也是集群部署，但是各 NameServer 之间不会互相通信， 各 NameServer 都有完整的路由信息，即无状态。</li></ul><p>RocketMQ的Broker、Topic、Queue的对应关系：</p><ul><li>一个Topic主题可以存储于多个Broker中</li><li>一个Topic主题由多个Queue队列组成。每个Topic分片等分的Queue的数量可以不同，由用户在创建Topic时指定；</li></ul><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410131634180.png" alt="RocketMQ的Broker组织图.drawio" style="zoom:33%;" /><h3 id="22部署架构"><a class="markdownIt-Anchor" href="#22部署架构"></a> 2.2部署架构</h3><p>RocketMQ的Broker有三种部署方式：</p><ul><li>单台Master部署；</li><li>多台Master部署；</li><li>多Master多Slave部署，又可分为以下两种模式（同步方式：同步复制和异步复制（指的一组 master 和 slave 之间数据的同步）<ul><li>多 master 多 slave <strong>异步</strong>复制模式</li><li>多 master 多 slave <strong>同步</strong>复制模式</li></ul></li></ul><p>基础的Rocket高可用，主要采用第3种部署方式，如图所示</p><p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410131146937.jpeg" alt="img" /></p><h3 id="23工作流程"><a class="markdownIt-Anchor" href="#23工作流程"></a> 2.3工作流程</h3><p>结合部署架构图，描述集群工作流程：</p><ol><li>启动NameServer，NameServer起来后监听端口，等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。</li><li>Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker的映射关系。</li><li>收发消息前，先<strong>创建Topic（主题名字，一个Topic由若干Queue组成）</strong>，创建Topic时需要<strong>指定该Topic要存储在哪些Broker</strong>上，也可以在发送消息时自动创建Topic。</li><li>Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并<strong>从NameServer中获取当前发送的Topic存在哪些Broker上</strong>，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。</li><li>Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取<strong>当前订阅Topic存在哪些Broker上</strong>，然后直接跟Broker建立连接通道，开始消费消息。</li></ol><h2 id="3rocketmq支持高可用"><a class="markdownIt-Anchor" href="#3rocketmq支持高可用"></a> 3.RocketMQ支持高可用</h2><p>可分为NameServer高可用、BrokerServer高可用、Producer高可用、Consumer高可用</p><h3 id="31nameserver高可用"><a class="markdownIt-Anchor" href="#31nameserver高可用"></a> 3.1NameServer高可用</h3><p>  由于 NameServer 节点是<strong>无状态</strong>的，且各个节点直接的<strong>数据是一致</strong>的，故存在多个 NameServer 节点的情况下，部分 NameServer 不可用也可以保证 MQ 服务正常运行</p><h3 id="32brokerserver高可用"><a class="markdownIt-Anchor" href="#32brokerserver高可用"></a> 3.2BrokerServer高可用</h3><p>  RocketMQ是通过 <strong>Master 和 Slave 的配合</strong>达到 BrokerServer 模块的高可用性的</p><p>一个 Master 可以配置多个 Slave，同时也支持配置多个 Master-Slave 组。</p><h3 id="33producer高可用"><a class="markdownIt-Anchor" href="#33producer高可用"></a> 3.3Producer高可用</h3><p>​在创建Topic的时候，把<strong>Topic的多个Message Queue创建在多个Broker组上</strong>（相同Broker名称，不同 brokerId的机器组成一个Broker组）</p><p>​这样当一个Broker组的Master不可用后，其他组的Master仍然可用，Producer仍然可以发送消息。</p><h3 id="34consumer高可用"><a class="markdownIt-Anchor" href="#34consumer高可用"></a> 3.4Consumer高可用</h3><p>  Consumer 的高可用是依赖于 Master-Slave 配置的，由于 Master 能够支持读写消息，Slave 支持读消息，当 Master 不可用或繁忙时， Consumer 会被自动切换到从 Slave 读取(自动切换，无需配置)。</p><p>  故当 Master 的机器故障后，消息仍可从 Slave 中被消费</p><h2 id="4五种消息类型"><a class="markdownIt-Anchor" href="#4五种消息类型"></a> 4.五种消息类型</h2><ol><li><strong>普通消息：</strong> 普通消息也称为并发消息，和传统的队列相比，并发消息没有顺序， 但是生产消费都是并行进行的，单机性能可达十万级别的TPS。</li><li><strong>分区有序消息：</strong> 与Kafka中的分区类似，把一个Topic消息分为多个分区“保 存”和消费，在一个分区内的消息就是传统的队列，遵循FIFO（先进先出）原则。</li><li><strong>全局有序消息：</strong> 如果把一个 Topic 的分区数设置为 1，那么该 Topic 中的消息 就是单分区，所有消息都遵循FIFO（先进先出）的原则。</li><li><strong>延迟消息：</strong> 消息发送后，消费者要在一定时间后，或者指定某个时间点才可以消 费。在没有延迟消息时，基本的做法是基于定时计划任务调度，定时发送消息。在 RocketMQ中只需要在发送消息时设置延迟级别即可实现。</li><li><strong>事务消息：</strong> 主要涉及分布式事务，即需要保证在多个操作同时成功或者同时失败 时，消费者才能消费消息。RocketMQ通过发送Half消息、处理本地事务、提交 （Commit）消息或者回滚（Rollback）消息优雅地实现分布式事务</li></ol><h2 id="5安装rocketmq"><a class="markdownIt-Anchor" href="#5安装rocketmq"></a> 5.安装RocketMQ</h2><p>见环境配置总结篇的RocketMQ</p><h2 id="6springboot整合rocketmq"><a class="markdownIt-Anchor" href="#6springboot整合rocketmq"></a> 6.SpringBoot整合RocketMQ</h2><h3 id="61xml配置"><a class="markdownIt-Anchor" href="#61xml配置"></a> 6.1xml配置</h3><p>在pom.xml引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="62yml配置"><a class="markdownIt-Anchor" href="#62yml配置"></a> 6.2yml配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="attr">name-server:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.224</span><span class="string">:9876</span> <span class="comment"># 访问地址</span></span><br><span class="line">  <span class="attr">producer:</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">Pro_Group</span> <span class="comment"># 必须指定group</span></span><br><span class="line">    <span class="attr">send-message-timeout:</span> <span class="number">3000</span> <span class="comment"># 消息发送超时时长，默认3s</span></span><br><span class="line">    <span class="attr">retry-times-when-send-failed:</span> <span class="number">3</span> <span class="comment"># 同步发送消息失败重试次数，默认2</span></span><br><span class="line">    <span class="attr">retry-times-when-send-async-failed:</span> <span class="number">3</span> <span class="comment"># 异步发送消息失败重试次数，默认2</span></span><br></pre></td></tr></table></figure><h3 id="63编写生产者"><a class="markdownIt-Anchor" href="#63编写生产者"></a> 6.3编写生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MQProducerService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;rocketmq.producer.send-message-timeout&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer messageTimeOut;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建议正常规模项目统一用一个TOPIC</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;RLT_TEST_TOPIC&quot;</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 直接注入使用，用于发送消息到broker服务器</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>普通发送</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 普通发送（主题Topic+Message消息）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(User user)</span> &#123;</span><br><span class="line">rocketMQTemplate.convertAndSend(topic, user);</span><br><span class="line"><span class="comment">//  rocketMQTemplate.send(topic, MessageBuilder.withPayload(user).build()); // 等价于上面一行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>发送同步消息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 发送同步消息（阻塞当前线程，等待broker响应发送结果，这样不太容易丢失消息）</span></span><br><span class="line"><span class="comment">* （msgBody也可以是对象，sendResult为返回的发送结果）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> SendResult <span class="title function_">sendMsg</span><span class="params">(String msgBody)</span> &#123;</span><br><span class="line">    <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> rocketMQTemplate.syncSend(topic, MessageBuilder.withPayload(msgBody).build());</span><br><span class="line">    log.info(<span class="string">&quot;【sendMsg】sendResult=&#123;&#125;&quot;</span>, JSON.toJSONString(sendResult));</span><br><span class="line">    <span class="keyword">return</span> sendResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>发送异步消息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 发送异步消息（通过线程池执行发送到broker的消息任务，执行完后回调：在SendCallback中可处理相关成功失败时的逻辑）</span></span><br><span class="line"><span class="comment">  * （适合对响应时间敏感的业务场景）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendAsyncMsg</span><span class="params">(String msgBody)</span> &#123;</span><br><span class="line">    rocketMQTemplate.asyncSend(topic, MessageBuilder.withPayload(msgBody).build(), <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">            <span class="comment">// 处理消息发送成功逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">            <span class="comment">// 处理消息发送异常逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>发送延时消息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 发送延时消息（上面的发送同步消息，delayLevel的值就为0，因为不延时）</span></span><br><span class="line"><span class="comment">* 在start版本中 延时消息一共分为18个等级分别为：1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDelayMsg</span><span class="params">(String msgBody, <span class="type">int</span> delayLevel)</span> &#123;</span><br><span class="line">    rocketMQTemplate.syncSend(topic, MessageBuilder.withPayload(msgBody).build(), messageTimeOut, delayLevel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>发送单向消息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 发送单向消息（只负责发送消息，不等待应答，不关心发送结果，如日志）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendOneWayMsg</span><span class="params">(String msgBody)</span> &#123;</span><br><span class="line">    rocketMQTemplate.sendOneWay(topic, MessageBuilder.withPayload(msgBody).build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>发送带标签消息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 发送带tag的消息，直接在topic后面加上&quot;:tag&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> SendResult <span class="title function_">sendTagMsg</span><span class="params">(String msgBody)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rocketMQTemplate.syncSend(topic + <span class="string">&quot;:tag2&quot;</span>, MessageBuilder.withPayload(msgBody).build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="64编写消费者"><a class="markdownIt-Anchor" href="#64编写消费者"></a> 6.4编写消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MQConsumerService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// topic需要和生产者的topic一致，consumerGroup属性是必须指定的，内容可以随意</span></span><br><span class="line">    <span class="comment">// selectorExpression的意思指的就是tag，默认为“*”，不设置的话会监听所有消息</span></span><br><span class="line">    <span class="meta">@Service</span></span><br><span class="line">    <span class="meta">@RocketMQMessageListener(topic = &quot;RLT_TEST_TOPIC&quot;, selectorExpression = &quot;tag1&quot;, consumerGroup = &quot;Con_Group_One&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerSend</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;User&gt; &#123;</span><br><span class="line">        <span class="comment">// 监听到消息就会执行此方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(User user)</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;监听到消息：user=&#123;&#125;&quot;</span>, JSON.toJSONString(user));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：这个ConsumerSend2和上面ConsumerSend在没有添加tag做区分时，不能共存，</span></span><br><span class="line">    <span class="comment">// 不然生产者发送一条消息，这两个都会去消费，如果类型不同会有一个报错，所以实际运用中最好加上tag，写这只是让你看知道就行</span></span><br><span class="line">    <span class="meta">@Service</span></span><br><span class="line">    <span class="meta">@RocketMQMessageListener(topic = &quot;RLT_TEST_TOPIC&quot;, consumerGroup = &quot;Con_Group_Two&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerSend2</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;String&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String str)</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;监听到消息：str=&#123;&#125;&quot;</span>, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MessageExt：是一个消息接收通配符，不管发送的是String还是对象，都可接收，当然也可以像上面明确指定类型（我建议还是指定类型较方便）</span></span><br><span class="line">    <span class="meta">@Service</span></span><br><span class="line">    <span class="meta">@RocketMQMessageListener(topic = &quot;RLT_TEST_TOPIC&quot;, selectorExpression = &quot;tag2&quot;, consumerGroup = &quot;Con_Group_Three&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;MessageExt&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(MessageExt messageExt)</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] body = messageExt.getBody();</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">            log.info(<span class="string">&quot;监听到消息：msg=&#123;&#125;&quot;</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="65测试"><a class="markdownIt-Anchor" href="#65测试"></a> 6.5测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/rocketmq&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RocketMQController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MQProducerService mqProducerService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/send&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> User.getUser();</span><br><span class="line">        mqProducerService.send(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendTag&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;SendResult&gt; <span class="title function_">sendTag</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> mqProducerService.sendTagMsg(<span class="string">&quot;带有tag的字符消息&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.success(sendResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="【消息队列】" scheme="https://www.haipeng-lin.cn/categories/%E3%80%90%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E3%80%91/"/>
    
    
  </entry>
  
  <entry>
    <title>收集 | 有情怀的网站</title>
    <link href="https://www.haipeng-lin.cn/posts/d1f540b5.html"/>
    <id>https://www.haipeng-lin.cn/posts/d1f540b5.html</id>
    <published>2024-10-10T12:21:25.000Z</published>
    <updated>2024-10-13T09:22:54.018Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1前言"><a class="markdownIt-Anchor" href="#1前言"></a> 1.前言</h1><p>  此文用于收藏有情怀的网站，如办公、编程、休闲、资源等资源</p><h1 id="2办公"><a class="markdownIt-Anchor" href="#2办公"></a> 2.办公</h1><ul><li><p>🥇 <a href="https://www.ypppt.com/">优品ppt</a></p></li><li><p>🥈 <a href="https://www.ttfont.com/">免费天天字体</a></p></li><li><p>🥉 <a href="https://xpdf.cn/pdf-to-word">pdf转word</a></p></li><li><p>🧡 <a href="https://app.diagrams.net/">DrawIO：流程图</a></p></li><li><p>💛 <a href="https://js.design/workspace">即时设计：封面图</a></p></li><li><p>💚 <a href="https://editor.ibaotu.com/complex/index">包图设计：海报图</a></p></li><li><p>📕 <a href="https://chat.chat826.com/#/home">Chat8</a></p></li><li><p>📖 <a href="https://chat18.aichatos68.com/#/chat/1728735290903">Chat18</a></p></li><li><p>📗 <a href="https://chat.openai.com/">ChatGPT</a></p></li><li><p>📗 <a href="https://xinghuo.xfyun.cn/">讯飞星火</a></p></li></ul><h1 id="3编程"><a class="markdownIt-Anchor" href="#3编程"></a> 3.编程</h1><ul><li><p>🏁 <a href="https://gitee.com/y_project/RuoYi">若依框架</a></p></li><li><p>🏳️‍🌈 <a href="https://gitee.com/opentiny/tiny-vue">OpenTiny</a></p></li><li><p><a href="https://programmercarl.com/">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/">Leetcode</a></p></li></ul><h1 id="4休闲"><a class="markdownIt-Anchor" href="#4休闲"></a> 4.休闲</h1><ul><li><p>📽️ <a href="https://vidhub1.cc/">vidhub1</a></p></li><li><p>🎞️ <a href="https://www.4ksj.com/4k-uhd-1.html">4k世界</a></p></li><li><p>🎥 <a href="https://www.meijutt.net/">美剧天堂</a></p></li><li><p>🥰 <a href="https://emoji6.com/emojiall/">emojy1</a></p></li><li><p>😍 <a href="https:/lll/www.emojiall.com/zh-hans">enojy2</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="【随笔】" scheme="https://www.haipeng-lin.cn/categories/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91/"/>
    
    
  </entry>
  
  <entry>
    <title>为什么HashMap线程不安全</title>
    <link href="https://www.haipeng-lin.cn/posts/d0dd6ec8.html"/>
    <id>https://www.haipeng-lin.cn/posts/d0dd6ec8.html</id>
    <published>2024-10-10T04:24:58.000Z</published>
    <updated>2024-10-10T04:28:59.695Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1前言"><a class="markdownIt-Anchor" href="#1前言"></a> 1.前言</h2><p>首先给出结论，HashMap在JDK1.7、1.8下，扩容均会出现线程不安全问题</p><ol><li><p>在JDK1.7中，HashMap会出现以下三个问题：</p><ol><li>多线程扩容，头插法扩容，引起的<strong>死循环</strong>问题</li><li><strong>多线程put的时候可能导致元素丢失</strong></li><li><strong>put非null元素后get出来的却是null</strong></li></ol></li><li><p>在JDK1.8，改用尾插法，避免产生死循环问题，但是可能会出现数据覆盖问题</p></li></ol><h2 id="2jdk17扩容引发的死循环和数据丢失"><a class="markdownIt-Anchor" href="#2jdk17扩容引发的死循环和数据丢失"></a> 2.JDK1.7扩容引发的死循环和数据丢失</h2><p>当前jdk1.7版本的HashMap线程不安全主要是发生在<strong>扩容函数</strong>中，其中调用了HshMap的transfer()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jdk 1.7的transfer方法，HashMap的扩容操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;<span class="comment">// 保存下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);<span class="comment">// 得到新位置下标</span></span><br><span class="line">            e.next = newTable[i];<span class="comment">// 待插入节点连接该位置的后面节点</span></span><br><span class="line">            newTable[i] = e;<span class="comment">// 插入该位置</span></span><br><span class="line">            e = next;<span class="comment">// 得到下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>举例：<ul><li>假设现在有两个线程A、B同时对下面这个HashMap进行扩容操作</li><li>假设HashMap的寻址函数为（ key%数组长度 ）</li></ul></li></ul><p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410091651000.png" alt="image-20241009164819797" /></p><blockquote><p>正常扩容后结果</p></blockquote><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410091651319.png" alt="image-20241009165129150" style="zoom:80%;" /><blockquote><p>假设当线程A执行到上面transfer函数的第11行代码时，CPU时间片耗尽，线程A被挂起。即如下图中位置所示：</p></blockquote><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410091659591.png" alt="image-20241009165927092" style="zoom:80%;" /><blockquote><p>此时线程A中：<strong>e=3、e.next=null、next=7</strong></p></blockquote><p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410091704705.png" alt="image-20241009170427755" /></p><blockquote><p>当线程A的时间片耗尽后，CPU开始执行线程B，并在<strong>线程B中成功的完成了数据迁移</strong></p></blockquote><p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410091705729.png" alt="image-20241009170539713" /></p><blockquote><p>根据 JMM 得出，线程B执行完数据迁移后，此时主内存中newTable和table都是最新的，也就是说：<mark>7.next=3、3.next=null（改变了线程A中的状态）</mark></p><p>随后线程A再次获得CPU时间片继续执行newTable[i] = e，将3放入新数组对应的位置</p><p>执行第一轮循环后线程A的情况如下：</p></blockquote><p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410101228269.png" alt="image-20241009171049905" /></p><blockquote><p>接着继续执行下一轮循环，此时e=7，从主内存中读取e.next时发现主内存中7.next=3，此时 next=3</p><p>并将7采用头插法的方式放入新数组中，并继续执行第二轮循环，结果如下：</p></blockquote><p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410091713800.png" alt="image-20241009171340574" /></p><blockquote><p>执行第三次循环，插入数据3，产生死锁问题和数据丢失问题</p></blockquote><p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410091717575.png" alt="image-20241009171725347" /></p><h2 id="3jdk18扩容引发的数据覆盖问题"><a class="markdownIt-Anchor" href="#3jdk18扩容引发的数据覆盖问题"></a> 3.JDK1.8扩容引发的数据覆盖问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)     <span class="comment">// 如果没有 hash 碰撞，则直接插入</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码只是判断了 hash 是否有碰撞，如果没有就不再做别的检查进行插入操作</p><p>在多线程环境下，如果线程 1 检查完了 hash 没有碰撞，要进行插入时， CPU 时间片使用完毕，此时它被挂起</p><p>线程 2 开始跑，无巧不成书嘛，此时线程 2 经过 hash 之后得到的值和线程 1 的 hash 值一样，线程 2 将值插入进去，<mark>线程 1 恢复运行，因为前面检查了 hash 碰撞，此时插入时不再做任何检查</mark>，直接将值插入</p><p>那么线程 2 插入的值就被覆盖掉了</p><p>HashMap 之所以发生数据覆盖的问题，最主要的原因在于它没有加锁，所以在多线程环境下会发生数据覆盖问题</p><h2 id="4解决hashmap线程不安全的方案"><a class="markdownIt-Anchor" href="#4解决hashmap线程不安全的方案"></a> 4.解决HashMap线程不安全的方案</h2><h3 id="41hashtable"><a class="markdownIt-Anchor" href="#41hashtable"></a> 4.1HashTable</h3><blockquote><p>已废弃，官方建议在多线程环境下使用ConcurrentHashMap类。</p></blockquote><p>HashTable的操作几乎和HashMap一致，主要的区别在于HashTable为了实现多线程安全，在几乎所有的<strong>方法上都加上了synchronized锁</strong>（锁的是类的实例,也就是整个map结构）</p><p>当一个线程访问 Hashtable 的同步方法时，其他线程如果也要访问同步方法，会被阻塞住。举个例子，当一个线程使用 put 方法时，另一个线程不但不可以使用 put 方法，连 get 方法都不可以，而加锁的结果就是HashTable操作的效率十分低下。</p><h3 id="42concurrenthashmap"><a class="markdownIt-Anchor" href="#42concurrenthashmap"></a> 4.2ConcurrentHashMap</h3><h4 id="421jdk17"><a class="markdownIt-Anchor" href="#421jdk17"></a> 4.2.1JDK1.7</h4><ol><li><p>在 JDK 1.7 中，底层<strong>使用分段数组+链表</strong>（ReentrantLock + Segment + HashEntry）机制。原理：把一个 HashMap 分成多个段，每段分配一把锁，保证当前线程执行该段时，不影响其他线程操作其他段的数据（锁粒度：基于 Segment，包含多个 HashEntry）</p></li><li><p>ConcurrentHashMap 定位一个元素的过程需要进行<strong>两次Hash操作</strong>，第一次 Hash 定位到 Segment，第二次 Hash 定位到元素所在的链表的头部，因此，这一种结构的带来的副作用是 Hash 的过程要比普通的 HashMap 要长，但是带来的好处是写操作的时候可以<strong>只对元素所在的 Segment 进行操作即可</strong>，不会影响到其他的 Segment</p></li><li><p>如图为ConcurrentHashMap在 JDK1.7的数据结构图，Segment 继承了 ReeentrantLock类，用于保证线程安全</p> <img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410101113136.png" alt="image-20241010111332095" style="zoom:67%;" /></li></ol><h4 id="422jdk18"><a class="markdownIt-Anchor" href="#422jdk18"></a> 4.2.2JDK1.8</h4><ol><li>在 JDK 1.8 中，底层<strong>Node数组 + 链表 + 红黑树</strong>数据结构，并使用 <strong>CAS乐观锁 + synchronized锁</strong> 保证线程安全</li><li>锁粒度：Node数组的一个Node，实现 Map.Entry，锁粒度降低了</li><li>如图为ConcurrentHashMap在 JDK1.8的数据结构图</li></ol><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410101147282.png" alt="image-20241010114739254" style="zoom:80%;" /><h4 id="423面试题"><a class="markdownIt-Anchor" href="#423面试题"></a> 4.2.3面试题</h4><blockquote><p>（1）ConcurrentHashMap在JDK 7和8之间的区别</p></blockquote><ol><li><strong>JDK1.8的实现降低锁的粒度</strong>，JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry，而JDK1.8锁的粒度就是Node节点</li><li>JDK1.8版本的<strong>数据结构变得更加简单</strong>，使得操作也更加清晰流畅，因为已经使用synchronized来进行同步，所以不需要分段锁的概念，也就不需要Segment这种数据结构了，由于粒度的降低，实现的复杂度也增加</li><li>JDK1.8<strong>使用红黑树来优化链表</strong>，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的，代替一定阈值的链表，这样形成一个最佳拍档</li></ol><blockquote><p>（2）ConcurentHashMap在JDK1.7和JDK1.8分别如何保证线程安全的？</p></blockquote><ol><li>在 JDK 1.7 中，底层<strong>使用分段数组+链表</strong>（ReentrantLock + Segment + HashEntry）机制。原理：把一个 HashMap 分成多个段，每段分配一把锁，保证当前线程执行该段时，不影响其他线程操作其他段的数据（锁粒度：基于 Segment，包含多个 HashEntry）</li><li>在 JDK 1.8 中，底层<strong>Node数组 + 链表 + 红黑树</strong>数据结构，并使用 <strong>CAS乐观锁 + synchronized锁</strong> 保证线程安全。其中CAS乐观锁用于向为空的位置赋值，synchronized锁用于不为空的位置，链表or红黑树，插入节点</li></ol><blockquote><p>（3）在JDK1.8中，ConcurrentHashMap put一个元素的流程</p></blockquote><ol><li><p>首先根据key计算对应的数组下标，如果该位置没有元素，则通过CAS乐观锁自旋的方法去向该位置赋值。</p></li><li><p>如果该位置有元素，则synchronized会加锁</p></li><li><p>加锁成功之后，在判断该元素的类型</p><ol><li>如果是链表节点则进行添加节点到链表中</li><li>如果是红黑树则添加节点到红黑树</li></ol></li><li><p>添加成功后，判断是否需要进行树化</p></li><li><p>执行 addCount 方法，将ConcurrentHashMap的元素个数加1，但是这个操作也是需要并发安全的，并且元素个数加1成功后，会<strong>继续判断是否要进行扩容</strong>，如果需要，则会进行扩容，所以这个方法很重要。</p></li><li><p>同时一个线程在put时如果发现当前ConcurrentHashMap正在进行扩容，则会去帮助扩容</p></li></ol><blockquote><p>（4）ConcurrentHashMap 和HashMap的扩容有什么不同？</p></blockquote><ol><li>HashMap的扩容是创建一个新数组，将值直接放入新数组中，JDK7采用头链接法，会出现死循环，JDK8采用尾链接法，不会造成死循环</li><li>ConcurrentHashMap 扩容是从数组队尾开始拷贝，<strong>拷贝槽点时会锁住槽点</strong>，拷贝完成后将槽点设置为转移节点。所以槽点拷贝完成后将新数组赋值给容器</li></ol><blockquote><p>（5） CAS 算法在 ConcurrentHashMap 中的应用</p></blockquote><ol><li>CAS是一种乐观锁，在执行操作时会判断<strong>内存中的值是否和准备修改前获取的值相同</strong>，如果相同，把新值赋值给对象，否则赋值失败，整个过程都是原子性操作，无线程安全问题</li><li>ConcurrentHashMap 的put操作是结合自旋用到了CAS，如果hash计算出的位置的槽点值为空，就采用CAS+自旋进行赋值，如果检查值为空，就赋值，如果不为空说明有其他线程先赋值了，放弃本次操作，进入下一轮循环</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="【Java基础】" scheme="https://www.haipeng-lin.cn/categories/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91/"/>
    
    
  </entry>
  
  <entry>
    <title>RabbitMQ学习笔记</title>
    <link href="https://www.haipeng-lin.cn/posts/d439760d.html"/>
    <id>https://www.haipeng-lin.cn/posts/d439760d.html</id>
    <published>2024-10-07T09:40:13.000Z</published>
    <updated>2024-10-07T15:01:09.765Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1rabbitmq是什么"><a class="markdownIt-Anchor" href="#1rabbitmq是什么"></a> 1.RabbitMQ是什么？</h1><ol><li>RabbitMQ 是一个在 AMQP（Advanced Message Queuing Protocol ，高级消息队列）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，<mark>支持高并发，支持可扩展</mark>。它支持多种客户端如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX，持久化，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</li><li>RabbitMQ 是<mark>使用 Erlang</mark> 编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。它同时实现了一个 Broker 构架，这意味着消息在发送给客户端时先在中心队列排队，对路由(Routing)、负载均衡(Load balance)或者数据持久化都有很好的支持。</li></ol><h1 id="2特点"><a class="markdownIt-Anchor" href="#2特点"></a> 2.特点</h1><ol><li><strong><mark>可靠性</mark></strong>: RabbitMQ 使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。</li><li><strong><mark>灵活的路由</mark></strong> : 在消息进入队列之前，<mark>通过交换器来路由消息</mark>。对于典型的路由功能， RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起， 也可以通过插件机制来实现自己的交换器。</li><li><strong><mark>扩展性</mark></strong>: 多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。</li><li><strong><mark>高可用性</mark></strong> : 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。</li><li><strong>多种协议</strong>: RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP， MQTT 等多种消息 中间件协议。</li><li><strong>多语言客户端</strong> :RabbitMQ 几乎支持所有常用语言，比如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。</li><li><strong>管理界面</strong> : RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。</li><li><strong>插件机制</strong> : RabbitMQ 提供了许多插件 ， 以实现从多方面进行扩展，当然也可以编写自 己的插件</li></ol><h1 id="3rabbit核心概念"><a class="markdownIt-Anchor" href="#3rabbit核心概念"></a> 3.Rabbit核心概念</h1><p>RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。可以把消息传递的过程想象成：当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ 就好比由邮局、邮箱和邮递员组成的一个系统。从计算机术语层面来说，RabbitMQ 模型更像是一种交换机模型。</p><p>RabbitMQ 的整体模型架构如下：</p><p><img src="https://oss.javaguide.cn/github/javaguide/rabbitmq/96388546.jpg" alt="图1-RabbitMQ 的整体模型架构" /></p><h2 id="31-producer和consumer"><a class="markdownIt-Anchor" href="#31-producer和consumer"></a> 3.1 Producer和Consumer</h2><ul><li><strong>Producer(生产者)</strong> :生产消息的一方（邮件投递者）</li><li><strong>Consumer(消费者)</strong> :消费消息的一方（邮件收件人）</li></ul><ol><li>消息一般由 2 部分组成：<strong>消息头</strong>（或者说是标签 Label）和 <strong>消息体</strong>。</li><li><mark><strong>消息体</strong></mark> 也可以称为 payLoad ,<mark>消息体是不透明的</mark></li><li><mark><strong>消息头</strong></mark> 则由一系列的可选属性组成，这些属性包括 <mark>routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）</mark> 等。生产者把消息交由 RabbitMQ 后，RabbitMQ 会根据消息头把消息发送给感兴趣的 Consumer(消费者)。</li></ol><h2 id="32-exchange"><a class="markdownIt-Anchor" href="#32-exchange"></a> 3.2 Exchange</h2><p>在 RabbitMQ 中，消息并不是直接被投递到 <strong>Queue(消息队列)</strong> 中的，中间还必须经过 <strong>Exchange(交换器)</strong> 这一层，<mark><strong>Exchange(交换器)</strong> 会把我们的消息分配到对应的 <strong>Queue(消息队列)</strong></mark> 中。</p><p><strong>Exchange(交换器)</strong> 用来接收生产者发送的消息并将这些消息路由给服务器中的队列中，如果路由不到，或许会返回给 <strong>Producer(生产者)</strong> ，或许会被直接丢弃掉 。这里可以将 RabbitMQ 中的交换器看作一个简单的实体。</p><p><strong>RabbitMQ 的 Exchange(交换器) 有 4 种类型，不同的类型对应着不同的路由策略</strong>：<mark><strong>direct(默认)</strong>，<strong>fanout</strong>, <strong>topic</strong>, 和 <strong>headers</strong></mark>，不同类型的 Exchange 转发消息的策略有所区别。这个会在介绍 <strong>Exchange Types(交换器类型)</strong> 的时候介绍到。</p><p>Exchange(交换器) 示意图如下：</p><p><img src="https://oss.javaguide.cn/github/javaguide/rabbitmq/24007899.jpg" alt="Exchange(交换器) 示意图" /></p><ol><li>RabbitMQ 中通过 <mark><strong>Binding(绑定)</strong></mark> 将 <strong>Exchange(交换器)</strong> 与 <strong>Queue(消息队列)</strong> 关联起来，在绑定的时候一般会指定一个 <strong><mark>BindingKey(绑定建)</mark></strong> ,这样 RabbitMQ 就知道如何正确将消息路由到队列了,如下图所示。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和 Queue 的绑定可以是多对多的关系。</li><li>生产者将<mark>消息发给交换器</mark>的时候，一般会指定一个 ==<strong>RoutingKey(路由键)</strong>，==用来指定这个消息的路由规则，而这个 <strong>RoutingKey 需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效</strong>。</li></ol><p><img src="https://oss.javaguide.cn/github/javaguide/rabbitmq/70553134.jpg" alt="Binding(绑定) 示意图" /></p><h2 id="33-queue"><a class="markdownIt-Anchor" href="#33-queue"></a> 3.3 Queue</h2><ol><li><strong>Queue(消息队列)</strong> 用来<mark>保存消息直到发送给消费者</mark>。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</li><li><strong>RabbitMQ</strong> 中消息只能存储在 <strong>队列</strong> 中，这一点和 <strong>Kafka</strong> 这种消息中间件相反。<mark>Kafka 将消息存储在 <strong>topic（主题）</strong></mark> 这个逻辑层面，而相对应的队列逻辑只是 topic 实际存储文件中的位移标识。 RabbitMQ 的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。</li><li><strong><mark>多个消费者可以订阅同一个队列</mark></strong>，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免消息被重复消费。</li></ol><h2 id="34-broker"><a class="markdownIt-Anchor" href="#34-broker"></a> 3.4 Broker</h2><p>对于 RabbitMQ 来说，<mark>一个 RabbitMQ Broker 可以简单地看作一个 RabbitMQ 服务节点</mark>，或者 RabbitMQ 服务实例。大多数情况下也可以将一个 RabbitMQ Broker 看作一台 RabbitMQ 服务器。</p><p>下图展示了生产者将消息存入 RabbitMQ Broker,以及消费者从 Broker 中消费数据的整个流程。</p><p><img src="https://oss.javaguide.cn/github/javaguide/rabbitmq/67952922.jpg" alt="消息队列的运转过程" /></p><h2 id="35-exchange-types"><a class="markdownIt-Anchor" href="#35-exchange-types"></a> 3.5 Exchange Types</h2><p>RabbitMQ 常用的 Exchange Type 有 <strong>fanout</strong>、<strong>direct</strong>、<strong>topic</strong>、<strong>headers</strong> 这四种（AMQP 规范里还提到两种 Exchange Type，分别为 system 与 自定义，这里不予以描述）。</p><h3 id="351fanout"><a class="markdownIt-Anchor" href="#351fanout"></a> 3.5.1fanout</h3><p>fanout 类型的 Exchange 路由规则非常简单，它<mark>会把所有发送到该 Exchange 的消息路由到所有与它绑定的 Queue</mark> 中，不需要做任何判断操作，所以 fanout 类型是所有的交换机类型里面速度最快的。fanout 类型常用来<mark>广播消息</mark>。</p><h3 id="352direct"><a class="markdownIt-Anchor" href="#352direct"></a> 3.5.2direct</h3><p>direct 类型的 Exchange 路由规则也很简单，它会把消息路由到<mark>那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中</mark>。</p><p><img src="https://oss.javaguide.cn/github/javaguide/rabbitmq/37008021.jpg" alt="direct 类型交换器" /></p><p>以上图为例，如果发送消息的时候设置路由键为“warning”,那么消息会路由到 Queue1 和 Queue2。如果在发送消息的时候设置路由键为&quot;Info”或者&quot;debug”，消息只会路由到 Queue2。如果以其他的路由键发送消息，则消息不会路由到这两个队列中。</p><h3 id="353topic"><a class="markdownIt-Anchor" href="#353topic"></a> 3.5.3topic</h3><p>topic 类型的交换器在direct的匹配规则基础上进行了扩展，它与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，但这里的<mark>匹配规则有些不同</mark>，它约定：</p><ul><li>RoutingKey 为一个点号“．”分隔的字符串（被点号“．”分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;</li><li>BindingKey 和 RoutingKey 一样也是点号“．”分隔的字符串；</li><li>BindingKey 中可以存在两种特殊字符串“<em>”和“#”，用于做模糊匹配，其中“</em><mark>”用于匹配一个单词</mark>，<mark>“#”用于匹配多个单词(可以是零个)</mark>。</li></ul><p><img src="https://oss.javaguide.cn/github/javaguide/rabbitmq/73843.jpg" alt="topic 类型交换器" /></p><ul><li>路由键为 “com.rabbitmq.client” 的消息会同时路由到 Queue1 和 Queue2;</li><li>路由键为 “com.hidden.client” 的消息只会路由到 Queue2 中；</li><li>路由键为 “com.hidden.demo” 的消息只会路由到 Queue2 中；</li><li>路由键为 “java.rabbitmq.demo” 的消息只会路由到 Queue1 中；</li><li>路由键为 “java.util.concurrent” 的消息将会被丢弃或者返回给生产者（需要设置 mandatory 参数），因为它没有匹配任何路由键。</li></ul><h3 id="354headers不推荐"><a class="markdownIt-Anchor" href="#354headers不推荐"></a> 3.5.4headers（不推荐）</h3><p>headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定队列和交换器时指定一组键值对，当发送消息到交换器时，RabbitMQ 会获取到该消息的 headers（也是一个键值对的形式)，对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。</p><h1 id="4springboot整合rabbitmq"><a class="markdownIt-Anchor" href="#4springboot整合rabbitmq"></a> 4.Springboot整合RabbitMQ</h1><blockquote><ul><li>引入amqp依赖场景;RabbitAutoCon&gt;figuration就会自动生</li><li>给容器中自动配置了RabbitTemplate、AmqpAdmin、CachingConnectionFactory、RabbitMessagingTemplate</li><li>@EnableRabbit:(在创建交换机,队列时可以不需要,发送消息可以不需要这个注解，监听消息必须使用这个注解)</li></ul></blockquote><h2 id="41导入依赖"><a class="markdownIt-Anchor" href="#41导入依赖"></a> 4.1导入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--rabbitmq--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="42xml配置"><a class="markdownIt-Anchor" href="#42xml配置"></a> 4.2xml配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.234</span><span class="number">.133</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><h2 id="43开启rabbitmq相关功能"><a class="markdownIt-Anchor" href="#43开启rabbitmq相关功能"></a> 4.3开启rabbitmq相关功能</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@EnableRabbit</span><br></pre></td></tr></table></figure><h2 id="44整合测试"><a class="markdownIt-Anchor" href="#44整合测试"></a> 4.4整合测试</h2><h3 id="441认识rabbitmqautoconfiguration"><a class="markdownIt-Anchor" href="#441认识rabbitmqautoconfiguration"></a> 4.4.1认识RabbitmqAutoConfiguration</h3><p>里面自动注入的组件</p><p>RabbitTeamplate：用于发送消息<br />AmqpAdmin：需要一个连接对象<br />CachingConnectionFactory：连接创建工厂<br />RabbitMessagingTemplate：操作消息的类<br />首先就是创建AmqpAdmin，并且这个时候需要配置一下连接工厂的配置信息，主要就是host、port和virtual-host虚拟主机</p><h3 id="442创建exchange-queue-binding"><a class="markdownIt-Anchor" href="#442创建exchange-queue-binding"></a> 4.4.2创建exchange、queue、binding</h3><blockquote><p>参数</p><ul><li>exchange:name、durable（持久化）、autodelete（自动删除）</li><li>queue：name、durable、excusive（排他，其它连接是否能够传输信息进来）、autodelete</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">exchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//注意，创建交换机就指定了交换机的类型为direct</span></span><br><span class="line">    <span class="type">DirectExchange</span> <span class="variable">directExchange</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;hello.java.exchange&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">    amqpAdmin.declareExchange(directExchange);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">queue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Queue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;hello.java.queue&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">true</span>);</span><br><span class="line">    amqpAdmin.declareQueue(queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">binding</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Binding</span> <span class="variable">binding</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Binding</span>(<span class="string">&quot;hello.java.queue&quot;</span>, Binding.DestinationType.QUEUE,<span class="string">&quot;hello.java.exchange&quot;</span>,<span class="string">&quot;hello&quot;</span>,<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line">    amqpAdmin.declareBinding(binding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="443发送消息"><a class="markdownIt-Anchor" href="#443发送消息"></a> 4.4.3发送消息</h3><blockquote><p>思路</p><p>①第一个就是要知道在传送消息的时候是需要依靠模板rabbitTemplate，它里面有一个messageConverter，这个转换器主要就是能够把消息变成对应的形式。通<mark>常用的是simple，这个转换器就是序列化转换成byte数组来传输</mark>，但是我们可以增加自己配置一个Json的Config转换器。发送消息用的是json状态</p><p>②接着就是通过模板来发送</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRabbitConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>发送消息用例：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">MemberResVo</span> <span class="variable">memberResVo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MemberResVo</span>();</span><br><span class="line">    memberResVo.setCity(<span class="string">&quot;sss&quot;</span>);</span><br><span class="line">    memberResVo.setId(<span class="number">123L</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 参数如下：交换机名称、消息的路由键、消息内容、（消息的唯一id：new CorrelationData(UUID.randomUUID().toString)）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;hello.java.exchange&quot;</span>,<span class="string">&quot;hello&quot;</span>,memberResVo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="444接收消息"><a class="markdownIt-Anchor" href="#444接收消息"></a> 4.4.4接收消息</h3><blockquote><p>思路</p><p>①开启注解EnableRabbit才能够使用@RabbitListener来监听，并且指定监听队列可以是多个。</p><p>②然后就发送消息进行测试</p><p>③<mark>RabbitHandler主要只能对方法起作用，@RabbitListener类和方法都可以</mark>，但是handler有利于方法的重载：用于接收不同类型的消息</p></blockquote><p><img src="https://img-blog.csdnimg.cn/direct/b7e031601b6b4b5b984f38739722e814.jpeg#pic_center" alt="在这里插入图片描述" /></p><h1 id="5rabbitmq实现消息的可靠抵达"><a class="markdownIt-Anchor" href="#5rabbitmq实现消息的可靠抵达"></a> 5.RabbitMQ实现消息的可靠抵达</h1><h2 id="51引入背景"><a class="markdownIt-Anchor" href="#51引入背景"></a> 5.1引入背景</h2><p>为保证消息不丢失，可靠抵达，可以使用事务消息，但是性能下降<strong>250倍</strong>，为此引入确认机制，来实现消息的可靠抵达</p><h2 id="52确认机制分类"><a class="markdownIt-Anchor" href="#52确认机制分类"></a> 5.2确认机制分类</h2><p>RabbitMQ 消息确认机制分为两大类：<mark><strong>发送方确认、接收方确认</strong></mark>。</p><p>其中发送方确认又分为：<mark>生产者到交换器到确认、交换器到队列的确认</mark>。如下图</p><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240319101439936.png" alt="image-20240319095647841" /></p><ul><li><mark>confirmCallback 确认模式</mark>：确认消息是否到达消息代理</li><li><mark>returnCallback退回模式</mark>：若消息没有传递给指定队列，就触发这个失败回调</li><li><mark>ack机制：消费者确认模式</mark><ul><li>CK机制是消费者从RabbitMQ收到消息并处理完成后，反馈给RabbitMQ，<mark>RabbitMQ收到反馈后才将此消息从队列中删除</mark>。</li><li>如果一个消费者在处理消息出现了网络不稳定、服务器异常等现象，那么就不会有ACK反馈，RabbitMQ会认为这个消息没有正常消费，会将消息重新放入队列中</li></ul></li></ul><h3 id="521confirmcallback-确认模式消息生产者确认"><a class="markdownIt-Anchor" href="#521confirmcallback-确认模式消息生产者确认"></a> 5.2.1ConfirmCallback (确认模式：消息生产者确认)</h3><h4 id="1开启确认配置"><a class="markdownIt-Anchor" href="#1开启确认配置"></a> （1）开启确认配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#老版本</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line"><span class="attr">publisher-confirms:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#新版本</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line"><span class="attr">publisher-confirms-type:</span> <span class="string">correlated</span></span><br></pre></td></tr></table></figure><h4 id="2实现confirmcallback回调接口"><a class="markdownIt-Anchor" href="#2实现confirmcallback回调接口"></a> （2）实现ConfirmCallback回调接口</h4><ul><li>ConfirmCallback 是一个<mark>回调接口</mark>，消息发送到 Broker 后触发回调，确认消息是否到达 Broker 服务器，<strong>也就是<mark>只确认是否正确到达 Exchange 中</mark>。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRabbitConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//消息只要被 broker 接收到就会执行 confirmCallback，如果是 cluster 模式，需要所有broker 接收到才会调用 confirmCallback。</span></span><br><span class="line">    <span class="comment">//确认消息送到交换机(Exchange)回调</span></span><br><span class="line">    <span class="meta">@PostConstruct</span><span class="comment">//创建MyBabbiConfig对象后，执行该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRabbitTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//确认消息送到队列(Queue)回调</span></span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;\n确认消息送到队列(Queue)结果：&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;发生消息：&quot;</span> + returnedMessage.getMessage());</span><br><span class="line">                System.out.println(<span class="string">&quot;回应码：&quot;</span> + returnedMessage.getReplyCode());</span><br><span class="line">                System.out.println(<span class="string">&quot;回应信息：&quot;</span> + returnedMessage.getReplyText());</span><br><span class="line">                System.out.println(<span class="string">&quot;交换机：&quot;</span> + returnedMessage.getExchange());</span><br><span class="line">                System.out.println(<span class="string">&quot;路由键：&quot;</span> + returnedMessage.getRoutingKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>被 broker 接收到只能<mark>表示 message 已经到达交换机</mark>，并不能保证消息一定会被投递到目标 queue 里。所以需要用到<mark>接下来的 returnCallback</mark></p></blockquote><h3 id="522returncallback回退模式交换机确认"><a class="markdownIt-Anchor" href="#522returncallback回退模式交换机确认"></a> 5.2.2ReturnCallback（回退模式：交换机确认）</h3><ul><li>通<mark>过实现 ReturnCallback 接口</mark>，启动消息失败返回，此接口<mark>是在交换器路由不到队列时触发回调</mark></li><li>该方法可以不使用，因为交换器和队列是在代码里绑定的，<mark>如果消息成功投递到 Broker 后几乎不存在绑定队列失败，除非你代码写错了。</mark></li></ul><h4 id="1开启回退配置"><a class="markdownIt-Anchor" href="#1开启回退配置"></a> （1）开启回退配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">rabbit:</span></span><br><span class="line"><span class="comment">#开启发送端消息抵达Queue确认</span></span><br><span class="line"><span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#只要消息不能抵达queue时，该消息不会被丢弃，而是会被返回给生产者：可以记录下详细到投递数据，定期的巡检或者自动纠错都需要这些数据</span></span><br><span class="line"><span class="attr">template:</span></span><br><span class="line"><span class="attr">mandatory:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="2实现returncallback回调接口"><a class="markdownIt-Anchor" href="#2实现returncallback回调接口"></a> （2）实现ReturnCallback回调接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRabbitConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostConstruct</span><span class="comment">//创建MyBabbiConfig对象后，执行该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRabbitTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//确认消息送到队列(Queue)失败回调：注意是失败</span></span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;\n确认消息送到队列(Queue)结果：&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;发生消息：&quot;</span> + returnedMessage.getMessage());</span><br><span class="line">                System.out.println(<span class="string">&quot;回应码：&quot;</span> + returnedMessage.getReplyCode());</span><br><span class="line">                System.out.println(<span class="string">&quot;回应信息：&quot;</span> + returnedMessage.getReplyText());</span><br><span class="line">                System.out.println(<span class="string">&quot;交换机：&quot;</span> + returnedMessage.getExchange());</span><br><span class="line">                System.out.println(<span class="string">&quot;路由键：&quot;</span> + returnedMessage.getRoutingKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//确认消息送到队列(Queue)回调</span></span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;\n确认消息送到队列(Queue)结果：&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;发生消息：&quot;</span> + returnedMessage.getMessage());</span><br><span class="line">                System.out.println(<span class="string">&quot;回应码：&quot;</span> + returnedMessage.getReplyCode());</span><br><span class="line">                System.out.println(<span class="string">&quot;回应信息：&quot;</span> + returnedMessage.getReplyText());</span><br><span class="line">                System.out.println(<span class="string">&quot;交换机：&quot;</span> + returnedMessage.getExchange());</span><br><span class="line">                System.out.println(<span class="string">&quot;路由键：&quot;</span> + returnedMessage.getRoutingKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="523ack机制确认模式消费者确认"><a class="markdownIt-Anchor" href="#523ack机制确认模式消费者确认"></a> 5.2.3ACK机制（确认模式：消费者确认）</h3><ol><li>消费者确认发生在监听队列的消费者处理业务失败，如：发生了异常，不符合要求的数据等，这些场景我们就需要手动处理消息，比如重新发送或者丢弃。</li><li>RabbitMQ 消息确认机制（ACK）默认是自动确认的，自动确认会在消息发送给消费者后立即确认，但<mark>存在丢失消息</mark>的可能，如果消费端消费逻辑抛出异常，假如你用回滚了也只是保证了数据的一致性，但是消息还是丢了，也就是消费端没有处理成功这条消息，那么就相当于丢失了消息。</li></ol><h4 id="1消息接收确认模式类型"><a class="markdownIt-Anchor" href="#1消息接收确认模式类型"></a> （1）消息接收确认模式类型</h4><ol><li><p>AcknowledgeMode.NONE：<mark>自动确认</mark>。</p><ul><li>默认自动ack，<mark>消息被消费者收到（注意：只是收到），就会从broker的queue中移除</mark></li><li>但<mark>存在丢失消息</mark>的可能，如果<mark>消费端消费逻辑抛出异常</mark>，假如你用回滚了也只是保证了数据的一致性，但是消息还是丢了</li></ul></li><li><p>AcknowledgeMode.AUTO：根据情况确认。</p></li><li><p>AcknowledgeMode.MANUAL：<mark>手动确认</mark>。</p><p>确认过程：就算消费者已经拿到了消息,<mark>但是没有确认</mark>,队列中的消息仍然不能移除,<mark>只不过状态由ready变为unacked</mark>，消息处理分为以下三种情况：</p><ol><li><mark><strong>消息处理成功</strong></mark>，<mark>ack()，接受下一个消息，此消息broker就会移除</mark></li><li><mark><strong>消息处理失败</strong></mark>，nack()/reject()，重新发送给其他人进行处理，或者容错处理后ack</li><li>消息一直<mark>没有调用ack/nack</mark>方法，<mark>broker认为此消息正在被处理，不会投递给别人</mark>，此时客户端断开，消息不会被broker移除，会投递给别人</li></ol><p><img src="https://img-blog.csdnimg.cn/20210121164244709.jpg" alt="img" /></p></li></ol><h4 id="2手动确认回复方法"><a class="markdownIt-Anchor" href="#2手动确认回复方法"></a> （2）手动确认回复方法</h4><ul><li>消费者获取到消息，成功处理，可以回复Ack给Broker<ul><li>basic.ack：用于<mark>肯定确认</mark>；<mark>broker将移除此消息</mark></li><li>basic.nack：用于<mark>否定确认</mark>；<mark><strong>可以指定broker是否丢弃此消息</strong></mark>，可以批量</li><li>basic.reject：用于<mark>否定确认当前消息</mark>；同上，但<mark>不能批量</mark></li></ul></li></ul><h4 id="3basicack方法"><a class="markdownIt-Anchor" href="#3basicack方法"></a> （3）basicAck方法</h4><p>basicAck 方法用于确认当前消息，Channel 类中的 basicAck 方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">basicAck</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ol><li><mark><strong>long deliveryTag</strong></mark>：<mark>唯一标识 ID</mark>，当一个消费者向 RabbitMQ 注册后，会建立起一个 Channel ，RabbitMQ 会用 basic.deliver 方法向消费者推送消息，这个方法携带了一个 delivery tag， 它代表了 <mark>RabbitMQ 向该 Channel 投递的这条消息的唯一标识 ID</mark>，是一个单调递增的正整数，delivery tag 的范围仅限于 Channel</li><li>**<mark>boolean multiple</mark>：**是否<mark>批处理</mark>，当该参数为 true 时，则可以一次性确认 delivery_tag 小于等于传入值的所有消息。</li></ol><h4 id="4basicnack方法"><a class="markdownIt-Anchor" href="#4basicnack方法"></a> （4）basicNack方法</h4><ol><li>basicNack 方法<mark>用于否定当前消息</mark>。</li><li>basicReject 方法一次只能拒绝一条消息</li><li>如果想批量拒绝消息，则可以使用 basicNack 方法。<mark>消费者客户端可以使用 channel.basicNack 方法</mark>来实现，方法定义如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">basicNack</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple, <span class="type">boolean</span> requeue)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ol><li>**long deliveryTag：**唯一标识 ID。</li><li>**boolean multiple：**上面已经解释。</li><li>**boolean requeue：**如果 <mark>requeue 参数设置为 true</mark>，则 <mark>RabbitMQ 会重新将这条消息存入队列</mark>，以便发送给下一个订阅的消费者； 如果 requeue 参数设置为 false，则 RabbitMQ 立即会还把消息从队列中移除，而不会把它发送给新的消费者。</li></ol><h4 id="5basicreject方法"><a class="markdownIt-Anchor" href="#5basicreject方法"></a> （5）basicReject方法</h4><p>basicReject 方法用于明确拒绝当前的消息而不是确认。</p><p>Channel 类中的basicReject 方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">basicReject</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> requeue)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ol><li>**long deliveryTag：**唯一标识 ID。</li><li>**boolean requeue：**上面已经解释。</li></ol><blockquote><p>测试场景：</p><ul><li>发送五个消息测试,</li><li>此时关闭服务服务,消息的状态由unacked变为ready,下次客户端服务启动又会接收到消息ready变为unacked</li><li>除非手动确认</li></ul></blockquote><h4 id="6开启手动ack机制"><a class="markdownIt-Anchor" href="#6开启手动ack机制"></a> （6）开启手动ack机制</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">listener:</span></span><br><span class="line"><span class="attr">simple:</span></span><br><span class="line"><span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure><h4 id="7消费者消费消息并手动确认"><a class="markdownIt-Anchor" href="#7消费者消费消息并手动确认"></a> （7）消费者消费消息并手动确认</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pjb.receiver;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接收者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pan_junbiao</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> <span class="keyword">implements</span> <span class="title class_">ChannelAwareMessageListener</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;queue_name&quot;</span>.equals(message.getMessageProperties().getConsumerQueue()))</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费的消息来自的队列名为：&quot;</span>+message.getMessageProperties().getConsumerQueue());</span><br><span class="line">                System.out.println(<span class="string">&quot;接收消息: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;执行queue_name中的消息的业务处理流程......&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;fanout.A&quot;</span>.equals(message.getMessageProperties().getConsumerQueue()))</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费的消息来自的队列名为：&quot;</span> + message.getMessageProperties().getConsumerQueue());</span><br><span class="line">                System.out.println(<span class="string">&quot;接收消息: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;执行fanout.A中的消息的业务处理流程......&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 确认消息，参数说明：</span></span><br><span class="line"><span class="comment">             * long deliveryTag：唯一标识 ID。</span></span><br><span class="line"><span class="comment">             * boolean multiple：是否批处理，当该参数为 true 时，</span></span><br><span class="line"><span class="comment">             * 则可以一次性确认 deliveryTag 小于等于传入值的所有消息。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicAck(deliveryTag, <span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 否定消息，参数说明：</span></span><br><span class="line"><span class="comment">             * long deliveryTag：唯一标识 ID。</span></span><br><span class="line"><span class="comment">             * boolean multiple：是否批处理，当该参数为 true 时，</span></span><br><span class="line"><span class="comment">             * 则可以一次性确认 deliveryTag 小于等于传入值的所有消息。</span></span><br><span class="line"><span class="comment">             * boolean requeue：如果 requeue 参数设置为 true，</span></span><br><span class="line"><span class="comment">             * 则 RabbitMQ 会重新将这条消息存入队列，以便发送给下一个订阅的消费者；</span></span><br><span class="line"><span class="comment">             * 如果 requeue 参数设置为 false，则 RabbitMQ 立即会还把消息从队列中移除，</span></span><br><span class="line"><span class="comment">             * 而不会把它发送给新的消费者。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//channel.basicNack(deliveryTag, true, false);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 拒绝消息，参数说明：</span></span><br><span class="line"><span class="comment">             * long deliveryTag：唯一标识 ID。</span></span><br><span class="line"><span class="comment">             * boolean requeue：如果 requeue 参数设置为 true，</span></span><br><span class="line"><span class="comment">             * 则 RabbitMQ 会重新将这条消息存入队列，以便发送给下一个订阅的消费者；</span></span><br><span class="line"><span class="comment">             * 如果 requeue 参数设置为 false，则 RabbitMQ 立即会还把消息从队列中移除，</span></span><br><span class="line"><span class="comment">             * 而不会把它发送给新的消费者。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicReject(deliveryTag, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="53总结"><a class="markdownIt-Anchor" href="#53总结"></a> 5.3总结</h2><p>​RabbitMQ系列第五篇介绍了实现消息的可靠抵达的两大模式：发送者确认、消费者确认；其中发送确认又可以分为消息生产者到交换机的确认（confirmcallback接口：消息到达交换机回调）、交换机到队列的确认（returncallback接口：消息到达不了队列回调）；而消费者回调ACK机制可分为自动确认、手动确认、根据情况确认三种类型；自动确认可能会出现消息丢失问题（消息到达消费者后，队列立刻删除该消息，但是此时消费者次此时出现异常或者宕机），手动确认的三个方法（basicAck、basicNack、basicReject）</p><h1 id="6消息重复消费问题"><a class="markdownIt-Anchor" href="#6消息重复消费问题"></a> 6.消息重复消费问题</h1><h2 id="61问题介绍"><a class="markdownIt-Anchor" href="#61问题介绍"></a> 6.1问题介绍</h2><p>什么是<mark>消息重复消费</mark>？首先我们来看一下消息的传输流程。消息生产者–&gt;MQ–&gt;消息消费者；消息生产者发送消息到MQ服务器，MQ服务器存储消息，消息消费者监听MQ的消息，发现有消息就消费消息。</p><p>所以消息重复也就出现在**<mark>两个阶段</mark>**</p><p>1**：生产者多发送了消息给MQ；**</p><p>2**：MQ的一条消息被消费者消费了多次**。</p><p>具体场景如下：</p><ol><li><mark><strong>生产者发送消息给MQ</strong></mark>，<mark>在MQ确认的时候出现了网络波动</mark>，生产者没有收到确认，这时候生产者就会重新发送这条消息，导致MQ会接收到重复消息。</li><li><mark>消费者消费成功后</mark>，给MQ确认的时候出现了网络波动，<mark>MQ没有接收到确认</mark>，为了保证消息不丢失，MQ就会继续给消费者投递之前的消息。这时候消费者就接收到了两条一样的消息。由于重复消息是由于网络原因造成的，无法避免。</li></ol><h2 id="62解决思路"><a class="markdownIt-Anchor" href="#62解决思路"></a> 6.2解决思路</h2><ol><li><mark>发送消息时让每个消息携带一个全局的唯一ID</mark></li><li>在消费消息时先判断消息是否已经被消费过，保证消息消费逻辑的幂等性。具体消费过程为：<ul><li>消费者获取到消息后先<mark>根据id去查询redis/db是否存在该消息</mark></li><li>如果不存在，则正常消费，消费完毕后写入redis/db</li><li>如果存在，则证明消息被消费过，直接丢弃</li></ul></li></ol><h2 id="63将该消息存储到redis"><a class="markdownIt-Anchor" href="#63将该消息存储到redis"></a> 6.3将该消息存储到Redis</h2><h3 id="631将id存入string单消费者场景"><a class="markdownIt-Anchor" href="#631将id存入string单消费者场景"></a> 6.3.1将id存入string（单消费者场景）</h3><h4 id="1实现思路"><a class="markdownIt-Anchor" href="#1实现思路"></a> （1）实现思路</h4><ul><li>将id号存入value中，并且value类型为string</li><li>即以队列名称为key，以消息id为值</li><li><mark>每次消息过来都覆盖之前的消息</mark></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;queueName4&quot;)</span><span class="comment">//发送的队列名称     @RabbitListener注解到类和方法都可以</span></span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage1</span><span class="params">(Message message)</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    <span class="comment">//获取唯一id</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">messageId</span> <span class="operator">=</span> message.getMessageProperties().getMessageId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取redis中该队列名称对应的value值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">messageRedisValue</span> <span class="operator">=</span> redisUtil.get(<span class="string">&quot;queueName4&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检验唯一id是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (messageRedisValue.equals(messageId)) &#123;</span><br><span class="line">        <span class="comment">//存在</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;消息：&quot;</span>+msg+<span class="string">&quot;, id:&quot;</span>+messageId);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//以队列为key，id为value</span></span><br><span class="line">    redisUtil.set(<span class="string">&quot;queueName4&quot;</span>,messageId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2问题"><a class="markdownIt-Anchor" href="#2问题"></a> （2）问题</h4><ol><li><mark><strong>并发冲突</strong></mark>：如果<mark>多个消费者</mark>同时操作 Redis 中的已消费消息列表，由于 Redis 是<mark>单线程</mark>处理命令，可能会出现并发冲突导致数据不一致或丢失问题。特别是在高并发情况下，使用字符串类型的 ID 可能会增加并发冲突的风险</li><li><strong>内存占用</strong>：字符串类型的 ID 在内存中占用空间相对较大，尤其是对于大量消息的情况下，会增加 Redis 的内存占用。</li><li><strong>比较效率</strong>：字符串类型的 ID 比较起来相对复杂，需要进行字符串比较操作。</li></ol><h3 id="632将id存入list中多消费场景"><a class="markdownIt-Anchor" href="#632将id存入list中多消费场景"></a> 6.3.2将id存入list中（多消费场景）</h3><h4 id="1实现思路-2"><a class="markdownIt-Anchor" href="#1实现思路-2"></a> （1）实现思路</h4><ul><li>以该队列名称为key，id为value</li><li>适合多消费场景的原因：<ul><li><strong><mark>顺序性</mark></strong>：List 是一个有序集合，可以<mark>按照消息的顺序存储消息 ID</mark>。在多消费者场景下，保持消息的顺序通常是很重要的，以确保消息按照正确的顺序被消费。</li><li><strong><mark>原子性操作</mark></strong>：Redis 的 List 提供了多个原子性操作，比如从列表两端推入/弹出元素，这些操作可以确保多个消费者同时访问列表时不会出现数据竞争和并发问题。</li><li><strong><mark>支持阻塞操作</mark></strong>：List 提供了阻塞式的弹出操作（如 BLPOP、BRPOP），可以在没有消息时阻塞等待新消息的到来，这对于实现消费者轮询机制非常有用。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;queueName4&quot;)</span><span class="comment">//发送的队列名称     @RabbitListener注解到类和方法都可以</span></span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage2</span><span class="params">(Message message)</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">messageId</span> <span class="operator">=</span> message.getMessageProperties().getMessageId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取</span></span><br><span class="line">    List&lt;String&gt; messageRedisValue = redisUtil.lrange(<span class="string">&quot;queueName4&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (messageRedisValue.contains(messageId)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;消息：&quot;</span>+msg+<span class="string">&quot;, id:&quot;</span>+messageId);</span><br><span class="line"> </span><br><span class="line">    redisUtil.lpush(<span class="string">&quot;queueName4&quot;</span>,messageId);<span class="comment">//存入list</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="633将id以key增量存入string中并设置过期时间"><a class="markdownIt-Anchor" href="#633将id以key增量存入string中并设置过期时间"></a> 6.3.3将id以key增量存入string中并设置过期时间</h3><h4 id="1实现思路-3"><a class="markdownIt-Anchor" href="#1实现思路-3"></a> （1）实现思路</h4><p>以<mark>消息id为key</mark>，<mark>消息内容为value</mark>存入string中，==设置过期时间（==可承受的redis服务器异常时间，比如设置过期时间为10分钟，如果redis服务器断了20分钟，那么未消费的数据都会丢了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;queueName4&quot;)</span><span class="comment">//发送的队列名称     @RabbitListener注解到类和方法都可以</span></span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage2</span><span class="params">(Message message)</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">messageId</span> <span class="operator">=</span> message.getMessageProperties().getMessageId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">String</span> <span class="variable">messageRedisValue</span> <span class="operator">=</span> redisUtil.get(messageId,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (msg.equals(messageRedisValue)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;消息：&quot;</span>+msg+<span class="string">&quot;, id:&quot;</span>+messageId);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//以id为key，消息内容为value，过期时间10分钟</span></span><br><span class="line">    redisUtil.set(messageId,msg,<span class="number">10L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="64总结"><a class="markdownIt-Anchor" href="#64总结"></a> 6.4总结</h2><p>该篇文章介绍了消息重复消费问题及解决方案，问题可能产生的两个阶段（生产消息多发、消费者重复消息）；解决方案：将消息发送时携带一个唯一id，消费方拿到消息时先去reids/db中有没有该数据，若没有则可以消费，否则不可以消费；并介绍了基于Redsi解决消息重复消费问题，①以队列名称为key，消息id为value，且value为string类型（适合只有一个消费方）②以队列名称为key，消息id为value，且value为list类型（适合有多个消费方场景）③以消息id为key，内容为value，并设置过期时间</p><h1 id="7rabbitmq实现json-map格式数据的发送与接收"><a class="markdownIt-Anchor" href="#7rabbitmq实现json-map格式数据的发送与接收"></a> 7.RabbitMQ实现JSON、Map格式数据的发送与接收</h1><p>在实现的项目开发中，经常使用Json、Map格式数据。下面将介绍RabbitMQ实现Json、Map格式数据的发送与接收。</p><h2 id="71消息发送端"><a class="markdownIt-Anchor" href="#71消息发送端"></a> 7.1消息发送端</h2><p>在消息发送端服务引入依赖、yml配置、RabbitMQ配置类、消息发送类</p><h3 id="711引入依赖"><a class="markdownIt-Anchor" href="#711引入依赖"></a> 7.1.1引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- AMQP客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="712yml配置"><a class="markdownIt-Anchor" href="#712yml配置"></a> 7.1.2yml配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">rabbitmq-provider</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> </span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> </span><br></pre></td></tr></table></figure><h3 id="713rabbitmqconfig配置类非常重要"><a class="markdownIt-Anchor" href="#713rabbitmqconfig配置类非常重要"></a> 7.1.3RabbitMQConfig配置类——（非常重要）</h3><p>在项目中，创建<mark>配置类</mark>，配置==<strong>消息确认</strong><mark>，<strong><mark>Json转换器</mark></strong>，</mark><strong>队列名称</strong>==等，并将队列交由 IoC 管理。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pjb.config;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.CachingConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.CorrelationData;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RabbitMQ配置类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DIRECT_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;direct_queue&quot;</span>; <span class="comment">//Direct队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DIRECT_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;direct_exchange&quot;</span>; <span class="comment">//交换器名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DIRECT_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;direct_routing_key&quot;</span>; <span class="comment">//路由键</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAY_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;delay_queue&quot;</span>; <span class="comment">//延时队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAY_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;delay_exchange&quot;</span>; <span class="comment">//交换器名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAY_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delay_routing_key&quot;</span>; <span class="comment">//路由键</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CachingConnectionFactory connectionFactory;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RabbitTemplate <span class="title function_">createRabbitTemplate</span><span class="params">(ConnectionFactory connectionFactory)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">RabbitTemplate</span> <span class="variable">rabbitTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>();</span><br><span class="line">        rabbitTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//设置Json转换器</span></span><br><span class="line">        rabbitTemplate.setMessageConverter(jsonMessageConverter());</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//设置开启Mandatory,才能触发回调函数,无论消息推送结果怎么样都强制调用回调函数</span></span><br><span class="line">        rabbitTemplate.setMandatory(<span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//确认消息送到交换机(Exchange)回调</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;\n确认消息送到交换机(Exchange)结果：&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;相关数据：&quot;</span> + correlationData);</span><br><span class="line">                System.out.println(<span class="string">&quot;是否成功：&quot;</span> + ack);</span><br><span class="line">                System.out.println(<span class="string">&quot;错误原因：&quot;</span> + cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//确认消息送到队列(Queue)回调</span></span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;\n确认消息送到队列(Queue)结果：&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;发生消息：&quot;</span> + returnedMessage.getMessage());</span><br><span class="line">                System.out.println(<span class="string">&quot;回应码：&quot;</span> + returnedMessage.getReplyCode());</span><br><span class="line">                System.out.println(<span class="string">&quot;回应信息：&quot;</span> + returnedMessage.getReplyText());</span><br><span class="line">                System.out.println(<span class="string">&quot;交换机：&quot;</span> + returnedMessage.getExchange());</span><br><span class="line">                System.out.println(<span class="string">&quot;路由键：&quot;</span> + returnedMessage.getRoutingKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Json转换器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Jackson2JsonMessageConverter <span class="title function_">jsonMessageConverter</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Direct交换器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(DIRECT_EXCHANGE, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DIRECT_QUEUE, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">directBinding</span><span class="params">(DirectExchange directExchange, Queue directQueue)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将队列和交换机绑定, 并设置用于匹配键：routingKey路由键</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue).to(directExchange).with(DIRECT_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/******************************延时队列******************************/</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CustomExchange <span class="title function_">delayExchange</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        args.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomExchange</span>(DELAY_EXCHANGE, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayQueue</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Queue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DELAY_QUEUE, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">delaybinding</span><span class="params">(Queue delayQueue, CustomExchange delayExchange)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayQueue).to(delayExchange).with(DELAY_ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面将讲述创建交换器、创建队列、将交换器和队列进行绑定各种方法</p><h4 id="1创建交换器方法"><a class="markdownIt-Anchor" href="#1创建交换器方法"></a> （1）创建交换器方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Direct交换器</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 创建交换器，参数说明：</span></span><br><span class="line"><span class="comment">        * String name：交换器名称</span></span><br><span class="line"><span class="comment">        * boolean durable：设置是否持久化，默认是 false。durable 设置为 true 表示持久化，反之是非持久化。</span></span><br><span class="line"><span class="comment">        * 持久化可以将交换器存盘，在服务器重启的时候不会丢失相关信息。</span></span><br><span class="line"><span class="comment">        * boolean autoDelete：设置是否自动删除，为 true 则设置队列为自动删除，</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(DIRECT_EXCHANGE, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="2创建队列方法"><a class="markdownIt-Anchor" href="#2创建队列方法"></a> （2）创建队列方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 队列</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> Queue <span class="title function_">directQueue</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 创建队列，参数说明：</span></span><br><span class="line"><span class="comment">       * String name：队列名称。</span></span><br><span class="line"><span class="comment">       * boolean durable：设置是否持久化，默认是 false。durable 设置为 true 表示持久化，反之是非持久化。</span></span><br><span class="line"><span class="comment">       * 持久化的队列会存盘，在服务器重启的时候不会丢失相关信息。</span></span><br><span class="line"><span class="comment">       * boolean exclusive：设置是否排他，默认也是 false。为 true 则设置队列为排他。</span></span><br><span class="line"><span class="comment">       * boolean autoDelete：设置是否自动删除，为 true 则设置队列为自动删除，</span></span><br><span class="line"><span class="comment">       * 当没有生产者或者消费者使用此队列，该队列会自动删除。</span></span><br><span class="line"><span class="comment">       * Map&lt;String, Object&gt; arguments：设置队列的其他一些参数。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DIRECT_QUEUE, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="3绑定方法"><a class="markdownIt-Anchor" href="#3绑定方法"></a> （3）绑定方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 绑定</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   Binding <span class="title function_">directBinding</span><span class="params">(DirectExchange directExchange, Queue directQueue)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//将队列和交换机绑定, 并设置用于匹配键：routingKey路由键</span></span><br><span class="line">       <span class="keyword">return</span> BindingBuilder.bind(directQueue).to(directExchange).with(DIRECT_ROUTING_KEY);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="4创建死信交换器-死信队列-绑定关系"><a class="markdownIt-Anchor" href="#4创建死信交换器-死信队列-绑定关系"></a> （4）创建死信交换器、死信队列、绑定关系</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> CustomExchange <span class="title function_">delayExchange</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">       Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       args.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomExchange</span>(DELAY_EXCHANGE, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Queue <span class="title function_">delayQueue</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">Queue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DELAY_QUEUE, <span class="literal">true</span>);</span><br><span class="line">       <span class="keyword">return</span> queue;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Binding <span class="title function_">delaybinding</span><span class="params">(Queue delayQueue, CustomExchange delayExchange)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> BindingBuilder.bind(delayQueue).to(delayExchange).with(DELAY_ROUTING_KEY).noargs();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="5发送消息方立即发送json格式数据延迟发送map格式数据"><a class="markdownIt-Anchor" href="#5发送消息方立即发送json格式数据延迟发送map格式数据"></a> （5）发送消息方（立即发送JSON格式数据/延迟发送Map格式数据）</h4><h5 id="1实体类"><a class="markdownIt-Anchor" href="#1实体类"></a> ①实体类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pjb.entity;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户信息实体类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> userId; <span class="comment">//用户编号</span></span><br><span class="line">    <span class="keyword">private</span> String userName; <span class="comment">//用户姓名</span></span><br><span class="line">    <span class="keyword">private</span> String blogUrl; <span class="comment">//博客地址</span></span><br><span class="line">    <span class="keyword">private</span> String blogRemark; <span class="comment">//博客信息</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//省略getter与setter方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2service层"><a class="markdownIt-Anchor" href="#2service层"></a> ②service层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pjb.sender;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.pjb.entity.UserInfo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户消息发送服务接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserSender</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送用户信息Json格式数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userInfo 用户信息实体类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendUserJson</span><span class="params">(UserInfo userInfo)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延时发送用户信息Map格式数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userMap 用户信息Map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDelayUserMap</span><span class="params">(Map userMap)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3serviceimpl类"><a class="markdownIt-Anchor" href="#3serviceimpl类"></a> ③serviceImpl类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pjb.sender.impl;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.pjb.config.RabbitMqConfig;</span><br><span class="line"><span class="keyword">import</span> com.pjb.entity.UserInfo;</span><br><span class="line"><span class="keyword">import</span> com.pjb.sender.UserSender;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.AmqpException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessagePostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户消息发送服务类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSenderImpl</span> <span class="keyword">implements</span> <span class="title class_">UserSender</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//时间格式</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送用户信息Json格式数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userInfo 用户信息实体类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendUserJson</span><span class="params">(UserInfo userInfo)</span></span><br><span class="line">    &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMqConfig.DIRECT_EXCHANGE, RabbitMqConfig.DIRECT_ROUTING_KEY, userInfo);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;Json格式数据消息发送成功，发送时间：&quot;</span> + dateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延时发送用户信息Map格式数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userMap 用户信息Map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDelayUserMap</span><span class="params">(Map userMap)</span></span><br><span class="line">    &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMqConfig.DELAY_EXCHANGE, RabbitMqConfig.DELAY_ROUTING_KEY, userMap, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//消息延迟5秒</span></span><br><span class="line">                message.getMessageProperties().setHeader(<span class="string">&quot;x-delay&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">                <span class="keyword">return</span> message;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;Map格式数据消息发送成功，发送时间：&quot;</span> + dateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>发送消息核心方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 发送消息，参数说明：</span></span><br><span class="line"><span class="comment">       * String exchange：交换器名称。</span></span><br><span class="line"><span class="comment">       * String routingKey：路由键。</span></span><br><span class="line"><span class="comment">       * Object object：发送内容。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      rabbitTemplate.convertAndSend(RabbitMqConfig.DIRECT_EXCHANGE, RabbitMqConfig.DIRECT_ROUTING_KEY, userInfo);</span><br></pre></td></tr></table></figure><h2 id="72消息接收端"><a class="markdownIt-Anchor" href="#72消息接收端"></a> 7.2消息接收端</h2><h3 id="721引入依赖"><a class="markdownIt-Anchor" href="#721引入依赖"></a> 7.2.1引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- AMQP客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="722yml配置"><a class="markdownIt-Anchor" href="#722yml配置"></a> 7.2.2yml配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 项目名称</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">rabbitmq-consumer</span></span><br><span class="line">  <span class="comment"># RabbitMQ服务配置</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="comment"># 重试机制</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#是否开启消费者重试</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">5</span> <span class="comment">#最大重试次数</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="string">5000ms</span> <span class="comment">#重试间隔时间（单位毫秒）</span></span><br><span class="line">          <span class="attr">max-interval:</span> <span class="string">1200000ms</span> <span class="comment">#重试最大时间间隔（单位毫秒）</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">2</span> <span class="comment">#间隔时间乘子，间隔时间*乘子=下一次的间隔时间，最大不能超过设置的最大间隔时间</span></span><br></pre></td></tr></table></figure><h3 id="723rabbitmqconfig配置类非常重要"><a class="markdownIt-Anchor" href="#723rabbitmqconfig配置类非常重要"></a> 7.2.3RabbitMQConfig配置类——（非常重要）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pjb.config;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.pjb.receiver.impl.AckReceiver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.AcknowledgeMode;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.CachingConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RabbitMQ配置类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DIRECT_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;direct_queue&quot;</span>; <span class="comment">//Direct队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAY_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;delay_queue&quot;</span>; <span class="comment">//延时队列名称</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息接收确认处理类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AckReceiver ackReceiver;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CachingConnectionFactory connectionFactory;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端配置</span></span><br><span class="line"><span class="comment">     * 配置手动确认消息、消息接收确认</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SimpleMessageListenerContainer <span class="title function_">simpleMessageListenerContainer</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//消费者数量，默认10</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENT</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//每个消费者获取最大投递数量 默认50</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">DEFAULT_PREFETCH_COUNT</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="type">SimpleMessageListenerContainer</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMessageListenerContainer</span>(connectionFactory);</span><br><span class="line">        container.setConcurrentConsumers(DEFAULT_CONCURRENT);</span><br><span class="line">        container.setMaxConcurrentConsumers(DEFAULT_PREFETCH_COUNT);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// RabbitMQ默认是自动确认，这里改为手动确认消息</span></span><br><span class="line">        container.setAcknowledgeMode(AcknowledgeMode.MANUAL);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//添加队列，可添加多个队列</span></span><br><span class="line">        container.addQueues(<span class="keyword">new</span> <span class="title class_">Queue</span>(DIRECT_QUEUE,<span class="literal">true</span>));</span><br><span class="line">        container.addQueues(<span class="keyword">new</span> <span class="title class_">Queue</span>(DELAY_QUEUE,<span class="literal">true</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//设置消息处理类</span></span><br><span class="line">        container.setMessageListener(ackReceiver);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="724统一消息处理类ackreceiver"><a class="markdownIt-Anchor" href="#724统一消息处理类ackreceiver"></a> 7.2.4统一消息处理类——AckReceiver</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pjb.receiver.impl;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.pjb.config.RabbitMqConfig;</span><br><span class="line"><span class="keyword">import</span> com.pjb.receiver.UserReceiver;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息接收确认处理类</span></span><br><span class="line"><span class="comment"> * 所有的消息，都由该类接收</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pan_junbiao</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AckReceiver</span> <span class="keyword">implements</span> <span class="title class_">ChannelAwareMessageListener</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户消息接收类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserReceiver userReceiver;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//时间格式</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息接收成功，接收时间：&quot;</span> + dateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//获取队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> message.getMessageProperties().getConsumerQueue();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//接收用户信息Json格式数据</span></span><br><span class="line">        <span class="keyword">if</span> (queueName.equals(RabbitMqConfig.DIRECT_QUEUE))</span><br><span class="line">        &#123;</span><br><span class="line">            userReceiver.receiverUserJson(message, channel);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//延时接收用户信息Map格式数据</span></span><br><span class="line">        <span class="keyword">if</span> (queueName.equals(RabbitMqConfig.DELAY_QUEUE))</span><br><span class="line">        &#123;</span><br><span class="line">            userReceiver.receiverDelayUserMap(message, channel);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//多个队列的处理，则如上述代码，继续添加方法....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="725接收消息"><a class="markdownIt-Anchor" href="#725接收消息"></a> 7.2.5接收消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pjb.receiver;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户消息接收接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserReceiver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收用户信息Json格式数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiverUserJson</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延时接收用户信息Map格式数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiverDelayUserMap</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1接收json数据"><a class="markdownIt-Anchor" href="#1接收json数据"></a> （1）接收JSON数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 接收用户信息Json格式数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiverUserJson</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//获取消息唯一id</span></span><br><span class="line">       <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line">       <span class="keyword">try</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//将JSON格式数据转换为实体对象——非常重要、重要、重要</span></span><br><span class="line">           <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">           <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> mapper.readValue(message.getBody(), UserInfo.class);</span><br><span class="line"></span><br><span class="line">           System.out.println(<span class="string">&quot;接收者收到JSON格式消息：&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;用户编号：&quot;</span> + userInfo.getUserId());</span><br><span class="line">           System.out.println(<span class="string">&quot;用户名称：&quot;</span> + userInfo.getUserName());</span><br><span class="line">           System.out.println(<span class="string">&quot;博客地址：&quot;</span> + userInfo.getBlogUrl());</span><br><span class="line">           System.out.println(<span class="string">&quot;博客信息：&quot;</span> + userInfo.getBlogRemark());</span><br><span class="line"></span><br><span class="line">           <span class="comment">//确认消息</span></span><br><span class="line">           channel.basicAck(deliveryTag, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 否定消息，参数说明：</span></span><br><span class="line"><span class="comment">            * long deliveryTag：唯一标识 ID。</span></span><br><span class="line"><span class="comment">            * boolean multiple：是否批处理，当该参数为 true 时，</span></span><br><span class="line"><span class="comment">            * 则可以一次性确认 deliveryTag 小于等于传入值的所有消息。</span></span><br><span class="line"><span class="comment">            * boolean requeue：如果 requeue 参数设置为 true，</span></span><br><span class="line"><span class="comment">            * 则 RabbitMQ 会重新将这条消息存入队列，以便发送给下一个订阅的消费者；</span></span><br><span class="line"><span class="comment">            * 如果 requeue 参数设置为 false，则 RabbitMQ 立即会还把消息从队列中移除，</span></span><br><span class="line"><span class="comment">            * 而不会把它发送给新的消费者。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="comment">//channel.basicNack(deliveryTag, true, false);</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (Exception e)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 拒绝消息，参数说明：</span></span><br><span class="line"><span class="comment">            * long deliveryTag：唯一标识 ID。</span></span><br><span class="line"><span class="comment">            * boolean requeue：如果 requeue 参数设置为 true，</span></span><br><span class="line"><span class="comment">            * 则 RabbitMQ 会重新将这条消息存入队列，以便发送给下一个订阅的消费者；</span></span><br><span class="line"><span class="comment">            * 如果 requeue 参数设置为 false，则 RabbitMQ 立即会还把消息从队列中移除，</span></span><br><span class="line"><span class="comment">            * 而不会把它发送给新的消费者。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           channel.basicReject(deliveryTag, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="2接收map数据"><a class="markdownIt-Anchor" href="#2接收map数据"></a> （2）接收map数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 延时接收用户信息Map格式数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiverDelayUserMap</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//将JSON格式数据转换为Map对象</span></span><br><span class="line">          <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">          <span class="type">JavaType</span> <span class="variable">javaType</span> <span class="operator">=</span> mapper.getTypeFactory().constructMapType(Map.class, String.class, Object.class);</span><br><span class="line">          Map&lt;String, Object&gt; resultMap = mapper.readValue(message.getBody(),javaType);</span><br><span class="line"> </span><br><span class="line">          System.out.println(<span class="string">&quot;接收者收到Map格式消息：&quot;</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot;用户编号：&quot;</span> + resultMap.get(<span class="string">&quot;userId&quot;</span>));</span><br><span class="line">          System.out.println(<span class="string">&quot;用户名称：&quot;</span> + resultMap.get(<span class="string">&quot;userName&quot;</span>));</span><br><span class="line">          System.out.println(<span class="string">&quot;博客地址：&quot;</span> + resultMap.get(<span class="string">&quot;blogUrl&quot;</span>));</span><br><span class="line">          System.out.println(<span class="string">&quot;博客信息：&quot;</span> + resultMap.get(<span class="string">&quot;userRemark&quot;</span>));</span><br><span class="line"> </span><br><span class="line">          <span class="comment">//确认消息</span></span><br><span class="line">          channel.basicAck(deliveryTag, <span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line">          <span class="comment">//否定消息</span></span><br><span class="line">          <span class="comment">//channel.basicNack(deliveryTag, true, false);</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception e)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//拒绝消息</span></span><br><span class="line">          channel.basicReject(deliveryTag, <span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="73总结"><a class="markdownIt-Anchor" href="#73总结"></a> 7.3总结</h2><ol><li>RabbitMQ系列第七篇文章主要介绍了如何实现JSON、Map格式数据的发送与接收；</li><li>在发送服务端中，核心为RabbitMQ的配置文件（配置json转换器、设置交换机、队列、绑定交换机与队列）发送消息的核心方法为RabbitTemplate.convertAndSend方法，传入指定交换机、路由键、以及要发送的消息内容；</li><li>在接收服务端中，核心依然为配置文件中的客户端配置：①手动确认信息；②添加监听队列；③设置统一消息处理类，接着在消息处理类中获取消息的队列名称，根据不同的队列名称调用不同的消息处理类；</li><li>在接收json格式的处理类中，通过ObjectMapper对象的readValue方法，将message中的body内容，转成想要的对象；</li><li>在接收map格式的处理中，先通过ObjectMapper对象的getTypeFactroy()的constructMapType()，构造出JavaType对象，接着使用ObjectMapper对象的readValue方法和JavaType对象，将message中的body内容转成map格式</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="【消息队列】" scheme="https://www.haipeng-lin.cn/categories/%E3%80%90%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E3%80%91/"/>
    
    
  </entry>
  
  <entry>
    <title>消息队列基础知识</title>
    <link href="https://www.haipeng-lin.cn/posts/f0fb6932.html"/>
    <id>https://www.haipeng-lin.cn/posts/f0fb6932.html</id>
    <published>2024-10-07T09:39:33.000Z</published>
    <updated>2024-10-07T14:59:38.760Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1什么是消息队列"><a class="markdownIt-Anchor" href="#1什么是消息队列"></a> 1.什么是消息队列？</h1><p>​消息队列是一种先进先出（FIFO）的数据结构，用于在应用程序之间传递消息。它提供了一种解耦、异步和可靠的消息传递机制，使得应用程序可以独立地运行，并通过消息队列进行通信。</p><p>​参与消息传递的双方称为 <strong>生产者</strong> 和 <strong>消费者</strong> ，生产者负责发送消息，消费者负责处理消息。</p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410071729898.png" alt="img" style="zoom: 67%;" /><h1 id="2消息队列作用"><a class="markdownIt-Anchor" href="#2消息队列作用"></a> 2.消息队列作用</h1><ol><li>通过<mark>异步处理</mark>提高系统性能，减少响应所需时间</li><li>削峰，限流（先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息）</li><li>降低系统耦合性，我们知道<mark>如果模块之间不存在直接调用</mark>，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。还是直接上图吧：</li></ol><p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E8%A7%A3%E8%80%A6.png" alt="解耦" /></p><p><strong>消息队列使用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。</p><h1 id="3消息队列的缺点"><a class="markdownIt-Anchor" href="#3消息队列的缺点"></a> 3.消息队列的缺点</h1><ol><li><strong>系统可用性降低：</strong> 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了！</li><li><strong>系统复杂性提高：</strong> 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li><li><strong><mark>一致性问题</mark>：</strong> 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了</li></ol><h1 id="4jms和amqp"><a class="markdownIt-Anchor" href="#4jms和amqp"></a> 4.JMS和AMQP</h1><ul><li><p><mark>JMS</mark>（java message service）：java消息服务</p><p>支持java平台，不跨语言，本质就是javaAPI，相当于就是一个规范。提供大量的message结构</p></li><li><p><mark>AMQP</mark>（advanced message queuing protocol）：高级消息队列协议</p><ul><li>跨语言跨平台，是一个网络线级协议。<mark>只提供byte数组传输</mark>。</li><li>RabbitMQ是AMQP的实现</li></ul></li></ul><p>对比如下：</p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240113171522233.png" alt="image-20240113171522233" style="zoom: 67%;" /><h2 id="41-jms的两种消息模型"><a class="markdownIt-Anchor" href="#41-jms的两种消息模型"></a> 4.1 JMS的两种消息模型</h2><h3 id="411点对点p2p模型"><a class="markdownIt-Anchor" href="#411点对点p2p模型"></a> 4.1.1点对点（P2P）模型</h3><p>使用**队列（Queue）*<em>作为消息通信载体；满足*<em>生产者与消费者模式</em></em>，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。比如：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</p><h3 id="412发布订阅pubsub模型"><a class="markdownIt-Anchor" href="#412发布订阅pubsub模型"></a> 4.1.2发布/订阅（Pub/Sub）模型</h3><p>（Topic)*<em>作为消息通信载体，类似于*<em>广播模式</em></em>；发布者发布一条消息，该消息通过主题传递给所有的订阅者</p><h1 id="5消息队列技术选型"><a class="markdownIt-Anchor" href="#5消息队列技术选型"></a> 5.消息队列技术选型</h1><h2 id="51-kafka"><a class="markdownIt-Anchor" href="#51-kafka"></a> 5.1 Kafka</h2><p>Kafka 是 LinkedIn 开源的一个分布式流式处理平台，已经成为 Apache 顶级项目，早期被用来用于处理海量的日志，后面才慢慢发展成了一款功能全面的高性能消息队列。</p><ol><li><strong><mark>消息队列</mark></strong>：<mark>发布和订阅消息流</mark>，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。</li><li><strong><mark>容错的持久方式存储记录消息流</mark></strong>：Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。</li><li><strong>流式处理平台：</strong> 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。</li></ol><p>Kafka 是一个分布式系统，由通过高性能 TCP 网络协议进行通信的服务器和客户端组成，可以部署在在本地和云环境中的裸机硬件、虚拟机和容器上。</p><h2 id="52-rocketmq"><a class="markdownIt-Anchor" href="#52-rocketmq"></a> 5.2 RocketMQ</h2><p>RocketMQ 是阿里开源的一款云原生“消息、事件、流”实时数据处理平台，借鉴了 Kafka，已经成为 Apache 顶级项目。</p><ol><li><mark><strong>云原生</strong></mark>：生与云，长与云，无限弹性扩缩，K8s 友好</li><li><mark><strong>高吞吐</strong></mark>：万亿级吞吐保证，同时满足微服务与大数据场景。</li><li>流处理：提供轻量、高扩展、高性能和丰富功能的流计算引擎。</li><li>金融级：金融级的稳定性，广泛用于交易核心链路。</li><li>架构极简：零外部依赖，Shared-nothing 架构。</li><li><mark><strong>生态友好</strong></mark>：无缝对接微服务、实时计算、数据湖等周边生态。</li></ol><h2 id="53-rabbitmq"><a class="markdownIt-Anchor" href="#53-rabbitmq"></a> 5.3 RabbitMQ</h2><p>RabbitMQ 是采用 Erlang 语言实现 AMQP(Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。</p><ol><li><strong><mark>可靠性</mark>：</strong> RabbitMQ 使用一些机制来保证消息的可靠性，如持久化、传输确认及发布确认等。</li><li><strong><mark>灵活的路由</mark>：</strong> 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。这个后面会在我们讲 RabbitMQ 核心概念的时候详细介绍到。</li><li><strong>扩展性：</strong> 多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。</li><li><strong>高可用性：</strong> 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。</li><li><strong>支持多种协议：</strong> RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP、MQTT 等多种消息中间件协议。</li><li><strong>多语言客户端：</strong> RabbitMQ 几乎支持所有常用语言，比如 Java、Python、Ruby、PHP、C#、JavaScript 等。</li><li><strong>易用的管理界面：</strong> RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。在安装 RabbitMQ 的时候会介绍到，安装好 RabbitMQ 就自带管理界面。</li><li><strong>插件机制：</strong> RabbitMQ 提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。感觉这个有点类似 Dubbo 的 SPI 机</li></ol><h2 id="54技术选型"><a class="markdownIt-Anchor" href="#54技术选型"></a> 5.4技术选型</h2><table><thead><tr><th>特性</th><th>Kafka</th><th>RocketMQ</th><th>RabbitMQ</th><th>ActiveMQ</th></tr></thead><tbody><tr><td><strong>单机吞吐量</strong></td><td>10万级</td><td>10万级</td><td>万级</td><td>10万级</td></tr><tr><td><strong>开发语言</strong></td><td>Scala</td><td>Java</td><td>Erlang</td><td>Java</td></tr><tr><td><strong>高可用</strong></td><td>分布式</td><td>分布式</td><td>主从</td><td>分布式</td></tr><tr><td><strong>消息延迟</strong></td><td>ms级</td><td>ms级</td><td>us级</td><td>ms级</td></tr><tr><td><strong>消息丢失</strong></td><td>理论上不会丢失</td><td>理论上不会丢失</td><td>低</td><td>低</td></tr><tr><td><strong>消费模式</strong></td><td>拉取</td><td>推拉</td><td>推拉</td><td></td></tr><tr><td><strong>持久化</strong></td><td></td><td>文件</td><td>内存，文件</td><td>内存，文件，数据库</td></tr><tr><td><strong>支持协议</strong></td><td>自定义协议</td><td>自定义协议</td><td>AMQP，XMPP, SMTP,STOMP</td><td>AMQP,MQTT,OpenWire,STOMP</td></tr><tr><td><strong>社区活跃度</strong></td><td>高</td><td>中</td><td>高</td><td>高</td></tr><tr><td><strong>管理界面</strong></td><td></td><td>web console</td><td>好</td><td>一般</td></tr><tr><td><strong>部署难度</strong></td><td>中</td><td></td><td>低</td><td></td></tr><tr><td><strong>部署方式</strong></td><td>独立</td><td>独立</td><td>独立</td><td>独立，嵌入</td></tr><tr><td><strong>成熟度</strong></td><td>成熟</td><td>比较成熟</td><td>成熟</td><td>成熟</td></tr><tr><td><strong>综合评价       综合评价       综合评价       综合评价     综合评价       综合评价</strong></td><td>优点：拥有强大的性能及吞吐量，兼容性很好。 </br>缺点：由于支持消息堆积，导致延迟比较高。</td><td>优点：性能好，稳定可靠，有活跃的中文社区，特点响应快。  </br>缺点：兼容性较差，但随着影响力的扩大，该问题会有改善。</td><td>优点：产品成熟，容易部署和使用，拥有灵活的路由配置。  </br>缺点：性能和吞吐量较差，不易进行二次开发。</td><td>优点：产品成熟，支持协议多，支持多种语言的客户端。  </br>缺点：社区不活跃，存在消息丢失的可能。</td></tr></tbody></table><p>总结起来，电商、金融等对事务性要求很高的，可以考虑RocketMQ；技术挑战不是特别高，用 RabbitMQ 是不错的选择；如果是大数据领域的实时计算、日志采集等场景可以考虑 Kafka。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="【消息队列】" scheme="https://www.haipeng-lin.cn/categories/%E3%80%90%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E3%80%91/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL锁机制</title>
    <link href="https://www.haipeng-lin.cn/posts/a7a1030b.html"/>
    <id>https://www.haipeng-lin.cn/posts/a7a1030b.html</id>
    <published>2024-09-26T06:58:22.000Z</published>
    <updated>2024-09-26T07:54:33.879Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="mysql锁机制"><a class="markdownIt-Anchor" href="#mysql锁机制"></a> MySQL锁机制</h1><h2 id="1作用"><a class="markdownIt-Anchor" href="#1作用"></a> 1.作用</h2><p>MySQL的锁机制，用于保证数据一致性和完整性</p><h2 id="2分类"><a class="markdownIt-Anchor" href="#2分类"></a> 2.分类</h2><blockquote><p>从四个角度分类</p></blockquote><ul><li><p>锁的粒度：全局锁、表级锁、行级锁、页级锁</p></li><li><p>锁的区间：间隙锁、临建锁</p></li><li><p>锁的性能：乐观锁、悲观锁</p></li><li><p>锁的级别：共享锁（读锁）、排他锁（写锁/独占锁）</p></li></ul><h2 id="3按锁的粒度分"><a class="markdownIt-Anchor" href="#3按锁的粒度分"></a> 3.按锁的粒度分</h2><h3 id="31行级锁"><a class="markdownIt-Anchor" href="#31行级锁"></a> 3.1行级锁</h3><ul><li><p>行级锁是指对数据库表中的<mark>某一行数据</mark>进行锁定，其他事务可以访问该表的其他行。</p></li><li><p>MySQL在支持行级锁的存储引擎中（如InnoDB）使用以下几种方式：</p><ul><li><p><strong>共享锁（S锁）</strong>：允许多个事务<mark>读取数据</mark>，但不允许修改。</p></li><li><p><strong>排他锁（X锁）</strong>：允许一个事务对数据进行修改，其他事务<mark>不允许读取或修改</mark></p></li></ul></li><li><p>行锁主要通过 <code>SELECT ... FOR UPDATE</code> 和 <code>SELECT ... LOCK IN SHARE MODE</code> 来实现</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启一个事务</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取行级排他锁</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 此时，其他事务无法修改和读取id为1的行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启一个事务</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取行级共享锁，允许其他事务读取该行，但不允许修改</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 此时，其他事务无法修改id为1的行数据，但是可以读取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--- 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="32表级锁"><a class="markdownIt-Anchor" href="#32表级锁"></a> 3.2表级锁</h3><ul><li><p>表级锁则是对整个表进行锁定。当一个事务锁定了表，其他事务无法对该表进行任何操作</p></li><li><p>分类：</p><ul><li><strong>读锁</strong>：其他事务可以读，但不能写。</li><li><strong>写锁</strong>：其他事务不能读也不能写。</li></ul></li><li><p>实现姿势：表锁可以通过 <code>LOCK TABLES</code> 命令显式地锁定整个表。</p><ul><li><p>写锁：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启一个事务</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 锁定整个表为写锁</span></span><br><span class="line">LOCK TABLES your_table WRITE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行一些操作</span></span><br><span class="line"><span class="keyword">UPDATE</span> your_table <span class="keyword">SET</span> column_name <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 解锁表</span></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></li><li><p>读锁：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启一个事务</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 锁定整个表为读锁</span></span><br><span class="line">LOCK TABLES your_table READ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行一些读取操作</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 解锁表</span></span><br><span class="line">UNLOCK TABLES;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="4按锁的区间分"><a class="markdownIt-Anchor" href="#4按锁的区间分"></a> 4.按锁的区间分</h2><ul><li><p>间隙锁</p><ul><li>定义：间隙锁用于==锁定一个范围（开区间）==而不是单个行。当事务在范围内的一行上持有锁时，<mark>其他事务无法在这个范围内插入新的数据</mark>，但是可以在范围之外插入新的数据。</li><li>举例：假设一个表中的索引列有序且不重复，事务A持有了某个范围内的间隙锁，这个范围可能是一段索引范围，比如(10,20)，这时其他事务无法在这个范围内插入新的行。</li></ul></li><li><p>临建锁</p><ul><li>定义：：临建锁是一种<mark>结合了行锁和间隙锁的锁类型</mark>，它在锁定一个范围时同时锁定了<mark>该范围内的行以及范围之间的间隙</mark>。</li><li>举例：考虑一个范围查询，比如查询索引列值在(10,20)之间的行，临建锁会锁定这个范围内的行，同时锁定范围之间的间隙，防止其他事务在这个范围内插入新的行或者改变已有行的值。</li></ul></li></ul><h2 id="5按锁的性能分"><a class="markdownIt-Anchor" href="#5按锁的性能分"></a> 5.按锁的性能分</h2><ul><li><p>乐观锁：</p><ul><li><p>定义：乐观锁认为数据在被操作时很少发生冲突，因此在访问数据时不会立即加锁，<mark>而是在更新数据时检查数据是否被其他事务修改过</mark>，如果没有则更新成功，否则进行回滚或者重试。</p></li><li><p>举例：在MySQL中，可以使用乐观锁的方式是在更新数据时<mark>检查数据的版本号或者时间戳</mark>是否与当前操作一致</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name </span><br><span class="line"><span class="keyword">SET</span> column1 <span class="operator">=</span> value1, version <span class="operator">=</span> new_version <span class="keyword">WHERE</span> id <span class="operator">=</span> x <span class="keyword">AND</span> version <span class="operator">=</span> old_version;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>悲观锁：</p><ul><li><p>定义：悲观锁认为数据在被操作时会发生冲突，因此<mark>在访问数据之前会先加锁，确保其他事务无法修改该数据</mark>，直到当前事务完成操作并释放锁。</p></li><li><p>举例：在MySQL中，可以使用SELECT … FOR UPDATE语句来获取悲观锁，例如</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span> </span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="6按锁的级别分"><a class="markdownIt-Anchor" href="#6按锁的级别分"></a> 6.按锁的级别分</h2><ul><li><p>共享锁：</p><ul><li><p>定义：共享锁允许<mark>多个事务同时读取同一行数据</mark>，但阻止其他事务在该行上获取排他锁；</p></li><li><p>举例：在 MySQL 中，可以使用 <code>SELECT ... LOCK IN SHARE MODE</code> 或者 <code>SELECT ... FOR SHARE</code> 来获取共享锁，例如</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span> </span><br><span class="line">LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>排他锁：</p><ul><li><p>定义：排他锁（也称为写锁）<mark>阻止其他事务对同一行数据进行读取或写入操作</mark>，只有<mark>获取了排他锁的事务才能对数据进行修改</mark>。</p></li><li><p>举例：在 MySQL 中，可以使用 <code>SELECT ... FOR UPDATE</code> 来获取排他锁，例如</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span> </span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="7拓展意向锁"><a class="markdownIt-Anchor" href="#7拓展意向锁"></a> 7.拓展：意向锁</h2><h3 id="71意向锁概述"><a class="markdownIt-Anchor" href="#71意向锁概述"></a> 7.1意向锁概述</h3><p>MySQL 中的意向锁（Intention Lock）是一种用于<mark>管理表级锁的锁机制</mark>，用于<mark>在表级别上指示事务将要在表的哪些行上获取锁</mark>。</p><p>意向锁并不是实际的锁，而是一种指示，通常用于协调事务对表级锁的获取，以提高并发性能和降低死锁的风险。</p><h3 id="72意向锁分类"><a class="markdownIt-Anchor" href="#72意向锁分类"></a> 7.2意向锁分类</h3><p>可分为两种类型：意向共享锁和意向排他锁</p><ul><li><p>意向共享锁（Intention Share Lock）：</p><ul><li>特点：表明事务将要在表的某些行上获取共享锁。当一个事务打算获取某行的共享锁时，会<mark>在表级别请求意向共享锁</mark>。</li><li>作用：意向共享锁是为了协调多个事务同时获取共享锁而引入的，在获取共享锁之前，<mark>需要先检查是否存在排他锁，以防止与其他事务的排他锁冲突</mark>。</li></ul></li><li><p>意向排他锁（Intention Exclusive Lock）：</p><ul><li>特点：表明事务将要在表的某些行上获取排他锁。当一个事务打算获取某行的排他锁时，会<mark>在表级别请求意向排他锁</mark>。</li><li>作用：意向排他锁是为了协调多个事务同时获取排他锁而引入的，在获取排他锁之前，<mark>需要先检查是否存在共享锁或其他事务的排他锁，以防止与其他事务的共享锁或排他锁冲突</mark>。</li></ul></li></ul><h3 id="73意向锁作用"><a class="markdownIt-Anchor" href="#73意向锁作用"></a> 7.3意向锁作用</h3><p>没有意向锁时，<mark>事务在获取表级锁/行级锁之前可能需要频繁地检查整个表</mark>，以确定是否有其他事务已经持有了排他锁或共享锁。这会增加系统的开销，降低并发性能。</p><p>举例：</p><p>事务 A 获取了某一行的排他锁，并未提交：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>事务 B 想要获取 <code>users</code> 表的表锁（共享锁）/行级锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES users READ;</span><br></pre></td></tr></table></figure><p>因为共享锁与排他锁<code>互斥</code>，所以事务 B 在视图对 <code>users</code> 表加共享锁的时候，必须保证：</p><ul><li>当前没有其他事务持有 users 表的排他锁。</li><li><mark>当前没有其他事务持有 users 表中任意一行的排他锁</mark> 。</li></ul><p>为了检测是否满足第二个条件，事务 B 必须在确保 <code>users</code>表不存在任何排他锁的前提下，<mark>去检测表中的每一行是否存在排他锁</mark>。</p><p>很明显这是一个效率很差的做法，但是有了<strong>意向锁</strong>之后，情况就不一样了：</p><h4 id="731意向锁的兼容互斥性"><a class="markdownIt-Anchor" href="#731意向锁的兼容互斥性"></a> 7.3.1意向锁的兼容互斥性</h4><blockquote><p>特点：<mark>多个事务可以对同一张表多个意向排他锁</mark></p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">意向共享锁（IS）</th><th style="text-align:center">意向排他锁（IX）</th></tr></thead><tbody><tr><td style="text-align:center"><strong>意向共享锁（IS）</strong></td><td style="text-align:center">兼容</td><td style="text-align:center">兼容</td></tr><tr><td style="text-align:center"><strong>意向排他锁（IX）</strong></td><td style="text-align:center">兼容</td><td style="text-align:center">兼容</td></tr></tbody></table><p>即<strong>意向锁之间是互相兼容的</strong>，虽然意向锁和自家兄弟互相兼容，<mark>但是它会与普通的<strong>排他 / 共享锁</strong>互斥</mark>：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">意向共享锁（IS）</th><th style="text-align:center">意向排他锁（IX）</th></tr></thead><tbody><tr><td style="text-align:center"><strong>共享锁（S）</strong></td><td style="text-align:center"><mark>兼容</mark></td><td style="text-align:center">互斥</td></tr><tr><td style="text-align:center"><strong>排他锁（X）</strong></td><td style="text-align:center">互斥</td><td style="text-align:center">互斥</td></tr></tbody></table><p><strong>注意：<mark>这里的排他 / 共享锁指的都是表锁！！！</mark></strong></p><p><strong>意向锁不会与行级的共享 / 排他锁互斥！！！</strong></p><h4 id="732例子1意向锁和表级的共享排他锁互斥"><a class="markdownIt-Anchor" href="#732例子1意向锁和表级的共享排他锁互斥"></a> 7.3.2例子1（意向锁和表级的共享/排他锁互斥）</h4><p>回到刚才 <code>users</code> 表的例子：</p><p>事务 A 获取了某一行的排他锁，并未提交：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><ul><li>此时 <code>users</code> 表存在两把锁：<mark><code>users</code> 表上的<strong>意向排他锁</strong>与 id 为 6 的数据行上的<strong>排他锁</strong></mark>。</li></ul><p>事务 B 想要获取 <code>users</code> 表的表锁（共享锁）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES users READ;</span><br></pre></td></tr></table></figure><ul><li>此时<code>事务 B</code> 检测事务 A 持有 <code>users</code> 表的<strong>意向排他锁</strong>，就可以<mark>得知<code>事务 A</code> 必然持有该表中某些数据行的<strong>排他锁</strong></mark>，</li><li>么<code>事务 B</code> 对 <code>users</code> 表的加锁请求就会被排斥（阻塞），而<mark>无需去检测表中的每一行数据是否存在排他锁</mark>。</li></ul><h4 id="733例子2意向锁和行级的共享锁排他锁兼容"><a class="markdownIt-Anchor" href="#733例子2意向锁和行级的共享锁排他锁兼容"></a> 7.3.3例子2（意向锁和行级的共享锁/排他锁兼容）</h4><ul><li>意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性</li></ul><p>事务 A 获取了某一行的排他锁，并未提交：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><ul><li>此时 <code>users</code> 表存在两把锁：<ul><li><mark><code>users</code> 表上的<strong>意向排他锁</strong></mark></li><li><mark>id 为 6 的数据行上的<strong>排他锁</strong></mark>。</li></ul></li></ul><p>事务 B 想要获取 <code>users</code> 表的表锁（共享锁）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES users READ;</span><br></pre></td></tr></table></figure><ul><li>此时<code>事务 B</code> 检测事务 A 持有 <code>users</code> 表的<strong>意向排他锁</strong>，就可以<mark>得知<code>事务 A</code> 必然持有该表中某些数据行的<strong>排他锁</strong></mark>，</li><li>么<code>事务 B</code> 对 <code>users</code> 表的加锁请求就会被排斥（阻塞），而<mark>无需去检测表中的每一行数据是否存在排他锁</mark>。</li></ul><p>最后<code>事务 C</code> 也想获取 <code>users</code> 表中某一行的<strong>排他锁</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE id = 5 FOR UPDATE;</span><br></pre></td></tr></table></figure><ol><li><code>事务 C</code> 申请 <code>users</code> 表的<strong>意向排他锁</strong>。</li><li><code>事务 C</code> 检测到<code>事务 A</code> 持有 <code>users</code> 表的<strong>意向排他锁</strong>。</li><li>因为意向锁之间并不互斥，所以==<code>事务 C</code> 获取到了 <code>users</code> 表的<strong>意向排他锁</strong>==。</li><li>因为id 为 5 的数据行上不存在任何<strong>排他锁</strong>，最终<code>事务 C</code> 成功获取到了该数据行上的<strong>排他锁</strong>。</li></ol><h3 id="74小结"><a class="markdownIt-Anchor" href="#74小结"></a> 7.4小结</h3><blockquote><p>意向锁的引入主要是为了提高并发性能。<strong>通过引入意向锁，MySQL 可以<mark>更有效地管理表级锁</mark>，减<mark>少了在并发环境下的锁冲突</mark>，从而提高了系统的并发处理能力。</strong></p><p>在没有意向锁之前，<mark>如果一张表里面已经有行锁了</mark>，<mark>此时我们再添加表锁</mark>，为了防止表锁和行锁发生冲突，<mark>表锁就需要遍历整个表中的数据检查是否有行锁</mark>。为了优化表锁检索行锁的过程，我们引入意向锁。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="【MySQL】" scheme="https://www.haipeng-lin.cn/categories/%E3%80%90MySQL%E3%80%91/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL三大日志文件</title>
    <link href="https://www.haipeng-lin.cn/posts/f8d0a55c.html"/>
    <id>https://www.haipeng-lin.cn/posts/f8d0a55c.html</id>
    <published>2024-09-21T08:42:03.000Z</published>
    <updated>2024-09-21T08:53:19.990Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="2mysql三大日志文件"><a class="markdownIt-Anchor" href="#2mysql三大日志文件"></a> 2.MySQL三大日志文件</h1><h2 id="21日志文件列表"><a class="markdownIt-Anchor" href="#21日志文件列表"></a> 2.1日志文件列表</h2><ol><li><mark><strong>redo log：重做日志</strong></mark>，记录了对于 InnoDB 表的每个写操作，不是 SQL 级别的，而是物理级别的，主要用于崩溃恢复</li><li><mark><strong>undo log：回滚日志</strong></mark>，记录数据被修改前的值，用于事务的回滚</li><li><mark><strong>bin log：二进制日志</strong></mark>，记录了所有修改数据库状态的 SQL 语句，以及每个语句的执行时间，如 INSERT、UPDATE、DELETE 等，但不包括 SELECT 和 SHOW 这类的操作</li><li><mark><strong>slow query log：慢查询日志</strong></mark>，记录执行时间超过 long_query_time 值的所有 SQL 语句。这个时间值是可配置的，默认情况下，慢查询日志功能是关闭的。可以用来识别和优化慢 SQL</li><li><mark><strong>error log：错误日志</strong></mark>，记录 MySQL 服务器启动、运行或停止时出现的问题</li></ol><h3 id="211-redo-log"><a class="markdownIt-Anchor" href="#211-redo-log"></a> 2.1.1 redo log</h3><ol><li>redo log，重做日志</li><li><strong>内容：</strong> 物理格式的日志，记录的是物理数据页面的修改的信息，其 redo log 是顺序写入 redo log file 的物理文件中去的</li><li><strong>作用：</strong> 确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启 mysql 服务的时候，根据 redo log 进行重做，从而达到事务的持久性这一特性</li></ol><h3 id="212-bin-log"><a class="markdownIt-Anchor" href="#212-bin-log"></a> 2.1.2 bin log</h3><ol><li>bin log，二进制日志</li><li><strong>内容：</strong> 所有执行增删改的SQL 语句，以及每个语句的执行时间，以便进行数据恢复和主从复制</li><li><strong>作用：</strong> 用于复制，在主从复制中，从库利用主库上的 binlog 进行重播，实现主从同步。 用于数据库的基于时间点的还原</li></ol><h3 id="213-undo-log"><a class="markdownIt-Anchor" href="#213-undo-log"></a> 2.1.3 undo log</h3><ol><li>undo log，回滚日志</li><li><strong>内容：</strong> 逻辑格式的日志，在执行 undo 的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于 redo log 的</li><li><strong>作用：</strong> 保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</li></ol><h2 id="22redo-log日志详讲"><a class="markdownIt-Anchor" href="#22redo-log日志详讲"></a> 2.2redo log日志详讲</h2><ol><li>原因：mysql，如果每次更新操作都要写进磁盘，然后磁盘要找到对应记录，然后再更细，整个过程 io 成本、查找成本都很高</li><li>解决方案：WAL 技术（Write-Ahead Logging）。先写日志，再写磁盘</li><li>具体过程：<ol><li>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里面，并更新内存，这个时候更新就算完成了。</li><li>同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</li><li>InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写</li></ol></li></ol><h2 id="23-binglog和redo-log有什么区别"><a class="markdownIt-Anchor" href="#23-binglog和redo-log有什么区别"></a> 2.3 binglog和redo log有什么区别？</h2><ol><li><strong><mark>文件级别不同：</mark></strong><ol><li>redo log 是 InnoDB 引擎特有的</li><li>binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用</li></ol></li><li><strong><mark>文件内容不同：</mark></strong><ol><li>redo log 是物理日志，记录的是 “在某个数据页上做了什么修改”</li><li>binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如 “给 ID=2 这一行的 c 字段加 1</li></ol></li><li><mark><strong>文件写入不同：</strong></mark><ol><li>redo log 是循环写的，空间固定会用完；</li><li>binlog 是可以追加写入的。“追加写” 是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志</li></ol></li></ol><h2 id="24一条更新语句的执行过程"><a class="markdownIt-Anchor" href="#24一条更新语句的执行过程"></a> 2.4一条更新语句的执行过程</h2><ol><li>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。、</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="【MySQL】" scheme="https://www.haipeng-lin.cn/categories/%E3%80%90MySQL%E3%80%91/"/>
    
    
  </entry>
  
  <entry>
    <title>MVCC-多版本并发控制</title>
    <link href="https://www.haipeng-lin.cn/posts/8b489829.html"/>
    <id>https://www.haipeng-lin.cn/posts/8b489829.html</id>
    <published>2024-09-21T08:40:58.000Z</published>
    <updated>2024-09-21T08:50:09.248Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3mysql中的mvcc机制"><a class="markdownIt-Anchor" href="#3mysql中的mvcc机制"></a> 3.MySQL中的MVCC机制</h1><h2 id="31前言"><a class="markdownIt-Anchor" href="#31前言"></a> 3.1前言</h2><ol><li>MVCC，全名叫做多版本并发控制，允许<mark>多个事务</mark>同时对数据库<mark>进行读写操作</mark>，解决了一个数据的多版本读写冲突；传统的锁机制可以实现并发控制，但<mark>会导致阻塞和死锁等问题</mark></li><li>核心思想：在数据库中，通过undo log维护多个数据版本，并根据事务的隔离级别来决定哪个版本数据对特定事务是可见的</li><li>实现的三个重要部分：<ol><li>隐藏字段</li><li>undo log版本链</li><li>readView快照</li></ol></li></ol><h2 id="32undo-log日志"><a class="markdownIt-Anchor" href="#32undo-log日志"></a> 3.2undo log日志</h2><ol><li>undo log（回滚日志）中记录了修改前的数据值，以及撤销操作所需的信息，以便在事务回滚或 MVCC 中使用</li></ol><h2 id="33三个隐藏字段"><a class="markdownIt-Anchor" href="#33三个隐藏字段"></a> 3.3三个隐藏字段</h2><ol><li>InnoDB会自动为每个undo log 回滚日志加上三个字段：<ol><li>DB_ROW_ID：隐藏主键</li><li><mark>DB_TRX_ID</mark>：创建该undo log 数据的事务ID</li><li><mark>DB_ROLL_PTR</mark>：回滚指针，指向这个事务之前的 undo log</li></ol></li></ol><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240804142639223.png" alt="image-20240804142639223" /></p><h2 id="34undo-log版本链"><a class="markdownIt-Anchor" href="#34undo-log版本链"></a> 3.4undo log版本链</h2><ol><li>undo log 版本链：基于undo log 回滚日志实现，维护了一条数据的多个版本</li></ol><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240804144543255.png" alt="image-20240804144543255" /></p><h2 id="35当前读vs快照读"><a class="markdownIt-Anchor" href="#35当前读vs快照读"></a> 3.5当前读VS快照读</h2><ol><li><p><strong>当前读</strong></p><ol><li><mark>读取的是当前记录的最新版本</mark>，读取的时候需要保证其他并发事务不能修改当前记录，对当前记录加锁</li><li>例子：Insert、Update、Delete、Select… for update（写锁）、Select… lock in share mode（读锁）</li></ol></li><li><p><strong>快照读：</strong></p><ol><li>最普通的Select查询SQL语句</li><li>读取的是数据的可见版本，有可能是历史数据、当前版本，<mark>不加锁，是非阻塞读</mark></li><li>底层依赖：当执行“快照读”SQL语句时，依据==ReadView（快照）==来提取数据</li></ol></li></ol><h2 id="36readview"><a class="markdownIt-Anchor" href="#36readview"></a> 3.6ReadView</h2><ol><li>ReadView，一个保存事务ID的list列表。记录的是<mark>本事务执行时，MySQL还有哪些事务在执行</mark>，且还没有提交</li><li><strong>一种数据结构，包含四个字段：</strong><ol><li>m_ids：当前<mark>活跃</mark>的事务编号集合</li><li>min_trx_id：最小活跃事务编号</li><li>max_trx_id：预分配事务编号，即当前最大事务编号+1</li><li><mark>creator_trx_id：ReadView创建者的事务编号</mark></li></ol></li><li><strong>不同隔离级别下快照生成的时机：</strong><ol><li>RC（读已提交）：每一次select，都生成一个 ReadView</li><li>RR（可重复读）：开启一个事务之后，只有第一个select语句才会生成一张快照，此后读的都是快照中的数据，直到事务提交</li><li>Serializable（可序列化）：快照读退化成当前读（加锁，阻塞，读取到的是最新的数据）</li></ol></li><li><strong>根据ReadView快照访问undo log 版本链数据的规则：</strong><ol><li>若 该版本的创建事务id <mark>等于</mark> 当前事务id  ？可以访问该版本，因为数据是当前这个事务更改的；</li><li>若 该版本的创建事务id <mark>小于</mark> 快照中 最小活跃事务编号？可以访问该版本，因为数据已经提交了；</li><li>若 该版本的创建事务id <mark>大于</mark> 快照中 预分配事务id？<mark>不可以访问该版本</mark>，因为该事务修改的数据是在 ReadView生成后才开启的；</li><li>若 快照中最小活跃事务编号 &lt;=  该版本的创建事务id &lt;= 预分配事务id 并且 <mark>该版本的创建事务id不在活跃事务编号集合中</mark>，可以访问该版本，因为该数据已经提交；</li></ol></li></ol><h2 id="37举例"><a class="markdownIt-Anchor" href="#37举例"></a> 3.7举例</h2><h3 id="371rc读已提交"><a class="markdownIt-Anchor" href="#371rc读已提交"></a> 3.7.1RC（读已提交）</h3><ol><li><strong>其中事务4的两次快照读均会产生ReadView，如下：</strong></li></ol><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240416111607748.png" alt="image-20240416111607748" /></p><ol start="2"><li><strong>分析第一个ReadView：</strong></li></ol><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240416112044314.png" alt="image-20240416112044314" /></p><ol start="3"><li><strong>分析第二个ReadView：</strong></li></ol><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240416112809451.png" alt="image-20240416112809451" /></p><ol start="4"><li><p>小结：</p><ol><li>在RC（读已提交）的事务隔离级别下，同一事务的两次快照读均会产生两个快照（ReadView）；</li><li>第一个快照读读取的数据是 事务一修改并提交的数据：张三</li><li>第二个快照读读取的数据是 事务二修改并提交的数据：张小三</li><li>同一事务的<mark>两个不同select（快照读）读取的数据不一样，产生不可重复读现象</mark></li></ol></li><li><p>思考：应该怎么解决？</p></li><li><p>解决：设置隔离级别为 RR（可重复读），<mark>同一事务从始至终只会生成一个快照</mark></p></li></ol><h3 id="372rr可重复读"><a class="markdownIt-Anchor" href="#372rr可重复读"></a> 3.7.2RR（可重复读）</h3><ol><li>隔离级别为 RR（可重复读），<mark>同一事务从始至终只会生成一个快照</mark>，即不会产生 不可重复读问题</li></ol><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240416113413125.png" alt="image-20240416113413125" /></p><h2 id="38扩展rr能解决幻读问题吗"><a class="markdownIt-Anchor" href="#38扩展rr能解决幻读问题吗"></a> 3.8扩展：RR能解决幻读问题吗？</h2><ol><li><p>结论：RR（可重复读）可以解决<mark>一部分幻读问题</mark></p></li><li><p>原因：</p><ol><li><p>同一事务的连续多次快照读，ReadView会产生复用，没有幻读问题</p></li><li><p>特例：当两次快照读之间存在当前读，ReadView会重新生成，导致幻读问题</p><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240416115328840.png" alt="image-20240416115328840" /></p></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="【MySQL】" scheme="https://www.haipeng-lin.cn/categories/%E3%80%90MySQL%E3%80%91/"/>
    
    
  </entry>
  
  <entry>
    <title>电脑组件</title>
    <link href="https://www.haipeng-lin.cn/posts/dc5c111d.html"/>
    <id>https://www.haipeng-lin.cn/posts/dc5c111d.html</id>
    <published>2024-09-19T03:12:37.000Z</published>
    <updated>2024-09-19T08:28:14.595Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>​这篇文章用于记录新手小白对电脑组件的认识过程，增强自身的知识储备，同时希望用简洁易懂的文字帮助小白也能看得懂电脑配置。</p><ul><li>推荐B站up主</li></ul><div calss='anzhiyu-tag-link'><a class="tag-Link" target="_blank" href="https://space.bilibili.com/1488429768">    <div class="tag-link-tips">引用站外地址</div>    <div class="tag-link-bottom">        <div class="tag-link-left" style="background-image: url(https://api.iowen.cn/favicon/space.bilibili.com/1488429768.png);"></div>        <div class="tag-link-right">            <div class="tag-link-title">古一搞机研究所</div>            <div class="tag-link-sitename"></div>        </div>        <i class="fa-solid fa-angle-right"></i>    </div>    </a></div><div calss='anzhiyu-tag-link'><a class="tag-Link" target="_blank" href="https://space.bilibili.com/14871346">    <div class="tag-link-tips">引用站外地址</div>    <div class="tag-link-bottom">        <div class="tag-link-left" style="background-image: url(https://api.iowen.cn/favicon/space.bilibili.com/14871346.png);"></div>        <div class="tag-link-right">            <div class="tag-link-title">硬件茶谈</div>            <div class="tag-link-sitename"></div>        </div>        <i class="fa-solid fa-angle-right"></i>    </div>    </a></div><details class="folding-tag" ><summary> 硬件茶谈234243 </summary>              <div class='content'>              <p>硬件茶谈234243</p>              </div>            </details><h1 id="电脑组件"><a class="markdownIt-Anchor" href="#电脑组件"></a> 电脑组件</h1><blockquote><p>电脑组件有CPU、显卡、内存、固态、主板、电源、机箱、散热（风扇）</p></blockquote><ul><li>CPU：中央处理单元（Central Processing Unit）的缩写，也叫处理器，是<mark>计算机的运算核心和控制核心</mark>。人靠大脑思考，电脑靠CPU来运算、控制。让电脑的各个部件顺利工作，起到协调和控制作用</li><li>显卡（GPU）：<mark>负责在显示屏上显示一切信息</mark>。打个比方，它就像是人的眼睛，没有了它，电脑就无法驱动形成图像了。显卡性能好，电脑的图形处理能力就高，尤其在玩游戏时更能发现这个（所以很多游戏会要求显卡性能）<ul><li>“集成显卡” 与 “独立显卡”的区别</li><li>集成显卡是集成在主板或CPU里面的显卡，集成在CPU里面的显卡又叫做核心显卡。</li><li>独立显卡是以独立板卡形式存在，可在具备显卡接口的主板上自由插拔的显卡。</li></ul></li><li>内存：负责硬盘等硬件上的数据与CPU之间数据交换处理；缓存系统中的临时数据；断电后数据丢失</li><li>固态：固态硬盘（SSD）是一种用于存储数据的设备，它使用闪存技术来存储信息</li><li>主板：<mark>连接所有其他设备的设备</mark>，是其他设备的载体，主板主要是为CPU、内存、显卡、硬盘等提供平台，相当于人体的躯干，关联着各个器官</li><li>电源：用于供电</li><li>机箱：放置和固定各电脑配件，起到一个承托和保护作用。</li><li>散热（风扇）：用于降温</li></ul><h2 id="1cpu"><a class="markdownIt-Anchor" href="#1cpu"></a> 1.CPU</h2><ul><li><p>CPU目前主要有两大品牌：Intel（英特尔）、AMD（超微半导体）</p></li><li><p>区分好坏要看<mark>核心数量越多，线程越多</mark>，CPU缓存越大，CPU主频越高其<mark>性能越好</mark>，价格也要更高</p><blockquote><p>CPU性能天梯图：<a href="https://www.mydrivers.com/zhuanti/tianti/cpu/">https://www.mydrivers.com/zhuanti/tianti/cpu/</a></p></blockquote></li><li><p>CPU的核心我们比喻成厨师做菜</p><ul><li>单核心单线程就是一个厨师一个灶台</li><li>单核心双线程就是一个厨师两个灶台</li><li>四核心四线程就是四个厨师四个灶台</li></ul></li><li><p>如何辨别英特尔型号？</p>  <img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202409182308624.png" alt="image-20240918230832446" style="zoom: 50%;" /><ul><li>Intel家族系列有：Core（酷睿）、Pentium（奔腾）、Celeron（赛扬）、Xeon（至强）、Atom（凌动）等</li><li><mark>Intel后缀命名（桌面版）</mark>：<ul><li><strong>K：</strong> 表示支持超频且内置核显的CPU型号，例如型号：i5-12600K、i7-12700K；</li><li><strong>F：</strong> 表示无内置核显，例如型号：i5-12400F、i7-12700F；</li><li><strong>KF：</strong> 表示支持超频且无内置核显的CPU型号，例如型号：i5-12600KF，i7-12700KF。</li><li><strong>T：</strong> 表示低功耗版，相同型号下功耗更低，性能也差一些，例如型号：i7-10700T；</li><li><strong>X/XE：</strong> 表示至尊旗舰级，例如型号：i9-10980XE。</li><li><strong>KS：</strong> 可以理解为官方超频版，提升了主频的版本，例如i9-9900K和i9-9900KS，i9-9900KS出厂的主频要高于K，例如型号：i9-9900KS。</li></ul></li><li><mark>Intel后缀命名（移动版）</mark>：<ul><li><strong>U：</strong> 低电压，性能弱些但功耗低，通常出现在<strong>轻薄本</strong>中，举例型号：i7 10510U；</li><li><strong>H：</strong> 标压，性能强，通常出现在<strong>游戏本</strong>中，举例型号：i5-11300H</li><li><strong>Y：</strong> 超低电压，性能很弱功耗非常低，通常出现在轻薄本中，举例型号：i3-10110Y；</li><li><strong>HK：</strong> 一般使用在intel高端发烧级CPU上，可超频，举例型号：i9-11980HK；</li><li><strong>G：</strong> G1、G4以及G7等，G后面的数字表示[核显性能]强弱，数字越大代表核显性能越强，通常数字小于4的是集成的普通超高清(UHD)核显，大于等于4的是集成的高性能锐炬(Iris)核显。intel移动版CPU后缀，举例型号：i5-1155G7、i3-1115G4、i3-1005G1；</li><li><strong>HQ：</strong> 标准电压，Q板载四核，早期的老后缀，举例型号：i7-7700HQ；</li><li><strong>MQ：</strong> 标准电压，Q插拔四核，早期的老后缀，举例型号：i7-4810MQ；</li><li><strong>M：</strong> 早期后缀M就是移动端CPU，只是为了与台式机区别开，举例型号：i7-2620M</li></ul></li></ul></li><li><p>如何辨别AMD CPU？</p>  <img src="https://pic4.zhimg.com/80/v2-8353f2c538af6e53c26c63be22180a03_1440w.webp" alt="img" style="zoom: 67%;" /><ul><li><strong>“锐龙”</strong> 代表AMD品牌下面向普通消费者的一个CPU系列，按照系列划分，有Ryzen（锐龙）、Ryzen Pro（锐龙Pro）、Ryzen Threadripper（锐龙线程撕裂者）、EPYC（霄龙），除了EPYC霄龙隶属于服务器CPU外，Ryzen锐龙系列都是有消费级桌面、移动产品。</li><li><strong>“R5”</strong> 代表这款CPU定位中端，在其下面还有R3，在其上面还有R7和R9，同一代中，数字越大，性能越强；但是不同代数之间，性能不能直接相比，比如5代的R5在理论性能上是强于3代R7的。</li><li><strong>“5”</strong> 代表这款CPU的代数，说明其已经发展到第5代了，数字越大越新；</li><li><strong>“600”</strong> 这三位数字代表<strong>AMD SKU型号划分</strong>，Ryzen 7有800/700，Ryzen 5有600/500/400，Ryzen 3有300/200。同样地，数字越大，频率越高，在Ryzen 5里面甚至会有更多核心和线程；</li><li><strong>“X”</strong> 带X的表示支持XFR技术，自适应动态扩频，除了睿频以外，还能够让CPU做工在高于睿频频率的工作状态，而频率的最大值受到散热器散热效果而变化，简单来说就是，散热器越强，频率越高</li></ul></li><li><p>AMD后缀（桌面版）：</p><ul><li><strong>G：</strong> 表示属于APU，内置强大的核显，举例型号：R5 5600G、R7 5700G。</li><li><strong>X：</strong> 不同于intel CPU的X后缀，带X结尾是指支持<strong>XFR技术</strong>的处理器，XFR是一种<strong>超频技术</strong>，是在<a href="https://zhida.zhihu.com/search?q=Boost&amp;zhida_source=entity&amp;is_preview=1">Boost</a>加速频率的基础上允许再次超频运行的一种技术，这个技术能让频率随不同散热解决方案(风冷/水冷/液氮)而升降，散热越牛逼超频越强悍。</li><li><strong>XT：</strong> 相当于X的加强版，也可以说是特挑体质版，相同型号下XT比X性能略有提升，举例型号R9 3900XT、R7 3800XT、R5 3600XT；</li></ul></li><li><p>AMD后缀（移动版）：</p><ul><li><strong>U：</strong> 低电压，性能弱些但功耗低，通常出现在轻薄本中，举例型号：R7-5700U；</li><li><strong>H：</strong> 标压，性能强，通常出现在游戏本中，举例型号：R5-5600H；</li><li><strong>HX：</strong> 一般使用在AMD高端发烧级CPU上，至尊版，举例型号：R9-5980HX；</li><li><strong>HS：</strong> 相当于H功耗略低，通常出现在轻薄全能本，性能较强，举例型号：R7 5800HS、R5 5600HS</li></ul></li></ul><h2 id="2显卡"><a class="markdownIt-Anchor" href="#2显卡"></a> 2.显卡</h2><ul><li>主流的显卡品牌有 NVIDIA（英伟达）和AMD，Intel的显卡种类比较少</li><li>国内封装好的品牌有：七彩虹（芯片系列：<a href="https://www.colorful.cn/home/productlist?mid=102%EF%BC%89%E3%80%81">https://www.colorful.cn/home/productlist?mid=102）、</a></li><li>显卡性能天梯图：<a href="https://www.mydrivers.com/zhuanti/tianti/gpu/">https://www.mydrivers.com/zhuanti/tianti/gpu/</a></li></ul><h1 id="心仪搭配"><a class="markdownIt-Anchor" href="#心仪搭配"></a> 心仪搭配</h1><ul><li>购买链接：<a href="https://mall.bilibili.com/neul-next/detailuniversal/detail.html?isMerchant=1&amp;page=detailuniversal_detail&amp;saleType=0&amp;itemsId=10177304&amp;loadingShow=1&amp;noTitleBar=1&amp;msource=cps_comments_1488429768&amp;track_id=na_522511996_BV1GM4m117Pj_A&amp;from=&amp;from_spmid=__SPMID__">b站</a></li><li><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202409191105847.png" alt="image-20240919110518565" style="zoom: 67%;" /></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="【数码】" scheme="https://www.haipeng-lin.cn/categories/%E3%80%90%E6%95%B0%E7%A0%81%E3%80%91/"/>
    
    
    <category term="装机" scheme="https://www.haipeng-lin.cn/tags/%E8%A3%85%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>综合知识</title>
    <link href="https://www.haipeng-lin.cn/posts/e3771f5f.html"/>
    <id>https://www.haipeng-lin.cn/posts/e3771f5f.html</id>
    <published>2024-09-16T15:27:49.000Z</published>
    <updated>2024-09-16T15:29:26.413Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计算机网络"><a class="markdownIt-Anchor" href="#计算机网络"></a> 计算机网络</h1><h2 id="1计算机网络基础"><a class="markdownIt-Anchor" href="#1计算机网络基础"></a> 1.计算机网络基础</h2><h3 id="11七层模型"><a class="markdownIt-Anchor" href="#11七层模型"></a> 1.1七层模型</h3><p><strong><mark>OSI 七层模型</mark></strong> 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：</p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202409162242806.png" alt="image-20240916085205640" style="zoom: 67%;" /><p>每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。</p><h3 id="12tcpip四层模型"><a class="markdownIt-Anchor" href="#12tcpip四层模型"></a> 1.2TCP/IP四层模型</h3><p><strong>TCP/IP 四层模型</strong> 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：</p><ol><li>应用层</li><li>传输层</li><li>网络层</li><li>网络接口层</li></ol><p>需要注意的是，我们并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示：</p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202409162242432.png" alt="image-20240916224055514" style="zoom: 50%;" /><blockquote><p>为什么网络要分层？</p></blockquote><ul><li><p><strong>各层之间相互独立</strong>：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）<strong>。这个和我们对开发时系统进行分层是一个道理。</strong></p></li><li><p><strong>提高了灵活性和可替换性</strong>：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。并且，每一层都可以根据需要进行修改或替换，而不会影响到整个网络的结构。<strong>这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。</strong></p></li><li><p><strong>大问题化小</strong>：分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 <strong>这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。</strong></p></li></ul><h3 id="13应用层常见的协议"><a class="markdownIt-Anchor" href="#13应用层常见的协议"></a> 1.3应用层常见的协议</h3><p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202409162242285.png" alt="image-20240319183654966" /></p><ul><li><strong>HTTP（Hypertext Transfer Protocol，超文本传输协议）</strong>：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li><li><strong>SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）</strong>：基于 TCP 协议，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。</li><li><strong>POP3/IMAP（邮件接收协议）</strong>：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。</li><li><strong>FTP（File Transfer Protocol，文件传输协议）</strong> : 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。</li><li><strong>Telnet（远程登陆协议）</strong>：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。</li><li><strong>SSH（Secure Shell Protocol，安全的网络传输协议）</strong>：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务</li><li><strong>RTP（Real-time Transport Protocol，实时传输协议）</strong>：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。</li><li><strong>DNS（Domain Name System，域名管理系统）</strong>: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题。</li></ul><h3 id="14网络层常见的协议"><a class="markdownIt-Anchor" href="#14网络层常见的协议"></a> 1.4网络层常见的协议</h3><ul><li><strong>IP（Internet Protocol，网际协议）</strong>：TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</li><li><strong>ARP（Address Resolution Protocol，地址解析协议）</strong>：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</li><li><strong>ICMP（Internet Control Message Protocol，互联网控制报文协议）</strong>：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。</li><li><strong>NAT（Network Address Translation，网络地址转换协议）</strong>：NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。</li><li><strong>OSPF（Open Shortest Path First，开放式最短路径优先）</strong> ）：一种内部网关协议（Interior Gateway Protocol，IGP），也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。</li><li><strong>RIP(Routing Information Protocol，路由信息协议）</strong>：一种内部网关协议（Interior Gateway Protocol，IGP），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。</li><li><strong>BGP（Border Gateway Protocol，边界网关协议）</strong>：一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）的路由选择协议，具有高度的灵活性和可扩展性</li></ul><h2 id="2http"><a class="markdownIt-Anchor" href="#2http"></a> 2.HTTP</h2><h3 id="21用户从浏览器输入url到页面的国过程"><a class="markdownIt-Anchor" href="#21用户从浏览器输入url到页面的国过程"></a> 2.1用户从浏览器输入URL到页面的国过程</h3><p>总体来说分为以下几个步骤:</p><ol><li>在浏览器中输入指定网页的 URL。</li><li>浏览器<mark>通过 DNS 协议，获取域名对应的 IP 地址</mark>。</li><li>浏览器根据 IP 地址和端口号，向<mark>目标服务器发起一个 TCP 连接请</mark>求。</li><li>浏览器在 TCP 连接上，向服务器<mark>发送一个 HTTP 请求报文</mark>，请求获取网页的内容。</li><li>服务器收到 HTTP 请求报文后，处理请求，并<mark>返回 HTTP 响应报文</mark>给浏览器。</li><li>浏览器收到 HTTP 响应报文后，<mark>解析响应体中的 HTML 代码</mark>，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。</li><li>浏览器在不需要和服务器通信时，<mark>可以主动关闭 TCP 连接</mark>，或者等待服务器的关闭请求</li></ol><h3 id="22http和https的区别"><a class="markdownIt-Anchor" href="#22http和https的区别"></a> 2.2HTTP和HTTPS的区别</h3><p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202409162245862.png" alt="HTTP 和 HTTPS 对比" /></p><ul><li><mark>端口号</mark>：HTTP 默认是 80，HTTPS 默认是 443。</li><li><mark>URL 前缀</mark>：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li><li><mark>安全性和资源消耗</mark>：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li><li><mark>SEO（搜索引擎优化）</mark>：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。</li></ul><h3 id="23uri和url的区别"><a class="markdownIt-Anchor" href="#23uri和url的区别"></a> 2.3URI和URL的区别</h3><ul><li>URI(Uniform Resource Identifier) 是<mark>统一资源标志符</mark>，可以<mark>唯一标识一个资源</mark>。</li><li>URL(Uniform Resource Locator) 是<mark>统一资源定位符</mark>，可以<mark>提供该资源的路径</mark>。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li></ul><p><mark>URI 的作用像身份证号一样</mark>，<mark>URL 的作用更像家庭住址一样</mark>。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p><h3 id="24get和post的区别"><a class="markdownIt-Anchor" href="#24get和post的区别"></a> 2.4GET和POST的区别</h3><p>GET 和 POST 是 HTTP 协议中两种常用的请求方法，它们在不同的场景和目的下有不同的特点和用法。一般来说，可以从以下几个方面来区分二者（重点搞清两者在语义上的区别即可）：</p><ol><li><mark>语义（主要区别）</mark><ul><li>GET 通常用于获取或查询资源</li><li>POST 通常用于创建或修改资源。</li></ul></li><li><mark>请求参数格式</mark><ul><li>GET 请求的参数通常放在 URL 中，形成查询字符串（querystring），GET 请求的 URL 长度受到浏览器和服务器的限制</li><li>POST 请求的参数通常放在请求体（body）中，<mark>可以有多种编码格式，如 application/x-www-form-urlencoded、multipart/form-data、application/json</mark> 等。而 POST 请求的 body 大小则没有明确的限制。</li></ul></li><li><mark>缓存</mark><ul><li>由于 GET 请求是幂等的，它可以被浏览器或其他中间节点（如代理、网关）缓存起来，以提高性能和效率</li><li>POST 请求则不适合被缓存，因为它可能有副作用，每次执行可能需要实时的响应。</li></ul></li><li><mark>安全性</mark><ul><li>GET 请求和 POST 请求如果使用 HTTP 协议的话，那都不安全，因为 <mark>HTTP 协议本身是明文传输</mark>的，</li><li><mark>两者必须使用 HTTPS 协议来加密传输数据</mark>。另外，GET 请求相比 POST 请求更容易泄露敏感数据，因为 GET 请求的参数通常放在 URL 中。</li></ul></li></ol><h2 id="3dns"><a class="markdownIt-Anchor" href="#3dns"></a> 3.DNS</h2><h3 id="31dns的作用"><a class="markdownIt-Anchor" href="#31dns的作用"></a> 3.1DNS的作用</h3><p>DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是**<mark>域名和 IP 地址的映射问题</mark>**。</p><p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202409162254907.png" alt="DNS:域名系统" /></p><p>在一台电脑上，可能存在浏览器 DNS 缓存，操作系统 DNS 缓存，路由器 DNS 缓存。如果以上缓存都查询不到，那么 DNS 就闪亮登场了。</p><p>目前 DNS 的设计采用的是分布式、层次数据库结构，<strong>DNS 是<mark>应用层协议</mark>，它可以在 UDP 或 TCP 协议之上运行，端口为 53</strong> 。</p><h3 id="32dns服务器的类型"><a class="markdownIt-Anchor" href="#32dns服务器的类型"></a> 3.2DNS服务器的类型</h3><p>DNS 服务器自底向上可以依次分为以下几个层级(所有 DNS 服务器都属于以下四个类别之一):</p><ol><li><mark><strong>根 DNS 服务器</strong></mark>。根 DNS 服务器提供 TLD 服务器的 IP 地址。目前世界上只有 13 组根服务器，我国境内目前仍没有根服务器。</li><li><mark>顶级域 DNS 服务器（TLD 服务器）</mark>。顶级域是指域名的后缀，如<code>com</code>、<code>org</code>、<code>net</code>和<code>edu</code>等。国家也有自己的顶级域，如<code>uk</code>、<code>fr</code>和<code>ca</code>。TLD 服务器提供了权威 DNS 服务器的 IP 地址。</li><li><mark>权威 DNS 服务器</mark>。在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。</li><li><mark>本地 DNS 服务器</mark>。每个 ISP（互联网服务提供商）都有一个自己的本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 层次结构中。严格说来，不属于 DNS 层级结构</li></ol><h2 id="4tcp与udp"><a class="markdownIt-Anchor" href="#4tcp与udp"></a> 4.TCP与UDP</h2><h3 id="41tcp与udp的区别"><a class="markdownIt-Anchor" href="#41tcp与udp的区别"></a> 4.1TCP与UDP的区别</h3><ol><li><p><mark>是否面向连接</mark>：</p><ul><li>UDP 在传送数据之前不需要先建立连接。</li><li>TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li></ul></li><li><p><mark>是否是可靠传输</mark>：远的主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</p></li><li><p><mark>是否有状态</mark>：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（<strong>这很渣男！</strong>）。</p></li><li><p><mark>传输效率</mark>：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</p></li><li><p><mark>传输形式</mark>：TCP 是面向字节流的，UDP 是面向报文的。</p></li><li><p><mark>首部开销</mark>：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</p></li><li><p><mark>是否提供广播或多播服务</mark>：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</p></li></ol><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">TCP</th><th style="text-align:center">UDP</th></tr></thead><tbody><tr><td style="text-align:center">是否面向连接</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">是否可靠</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">是否有状态</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">传输效率</td><td style="text-align:center">较慢</td><td style="text-align:center">较快</td></tr><tr><td style="text-align:center">传输形式</td><td style="text-align:center">字节流</td><td style="text-align:center">数据报文段</td></tr><tr><td style="text-align:center">首部开销</td><td style="text-align:center">20 ～ 60 bytes</td><td style="text-align:center">8 bytes</td></tr><tr><td style="text-align:center">是否提供广播或多播服务</td><td style="text-align:center">否</td><td style="text-align:center">是</td></tr></tbody></table><h3 id="42tcp三次握手"><a class="markdownIt-Anchor" href="#42tcp三次握手"></a> 4.2TCP三次握手</h3><p>建立一个 TCP 连接需要“三次握手”，缺一不可：</p><ol><li><strong><mark>一次握手</mark></strong>:客户端发送带有 <mark>SYN（SEQ=x） 标志</mark>的数据包 -&gt; 服务端，然后客户端进入 <strong>SYN_SEND</strong> 状态，等待服务器的确认；（x为客户端的序列号）</li><li><strong><mark>二次握手</mark></strong>:服务端发送带有 <mark>SYN+ACK(SEQ=y,ACK=x+1) 标志</mark>的数据包 –&gt; 客户端,然后服务端进入 <strong>SYN_RECV</strong> 状态（ACK即服务器确认收到客户端的序列号，后加一返回）</li><li><strong><mark>三次握手</mark></strong>:客户端发送带有 <mark>ACK(ACK=y+1)</mark> 标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入<strong>ESTABLISHED</strong> 状态，完成 TCP 三次握手。</li></ol><h3 id="43为什么要三次握手"><a class="markdownIt-Anchor" href="#43为什么要三次握手"></a> 4.3为什么要三次握手？</h3><p>三次握手的目的是<mark>建立可靠的通信信道</mark>，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是<mark>双方确认<strong>自己与对方的发送与接收</strong>是正常的</mark>。</p><ol><li><strong><mark>第一次握手</mark></strong>：Client 什么都不能确认；<mark>Server 确认了对方发送正常</mark>，<mark>自己接收正常</mark></li><li><strong><mark>第二次握手</mark></strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常（<mark><strong>还差确认自己发送、对方接送正常</strong></mark>）</li><li><strong>第三次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：<mark><strong>自己发送</strong></mark>、接收正常，对方发送、<mark><strong>接收正常</strong></mark></li></ol><table><thead><tr><th style="text-align:center">Client角度</th><th style="text-align:center">第一次握手</th><th style="text-align:center">第二次握手</th><th style="text-align:center">第三次握手</th></tr></thead><tbody><tr><td style="text-align:center">Client 自己发送正常</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Server 对方接收正常</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Server对方发送正常</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Client自己接收正常</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr></tbody></table><table><thead><tr><th style="text-align:center">Server角度</th><th style="text-align:center">第一次握手</th><th style="text-align:center">第二次握手</th><th style="text-align:center">第三次握手</th></tr></thead><tbody><tr><td style="text-align:center">Client 对方发送正常</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Server 自己接收正常</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Server对方发送正常</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><strong><mark>√</mark></strong></td></tr><tr><td style="text-align:center">Client自己接收正常</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><strong><mark>√</mark></strong></td></tr></tbody></table><h3 id="44tcp四次挥手"><a class="markdownIt-Anchor" href="#44tcp四次挥手"></a> 4.4TCP四次挥手</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-waves-four-times.png" alt="TCP 四次挥手图解" /></p><p>断开一个 TCP 连接则需要“四次挥手”，缺一不可：</p><ol><li><strong>第一次挥手</strong>：客户端发送一个 FIN（SEQ=x） 标志的数据包-&gt;服务端，用来<mark>关闭客户端到服务器的数据传送</mark>。然后客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li><li><strong>第二次挥手</strong>：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （ACK=x+1）标志的数据包-&gt;客户端 。然后<mark>服务端进入 <strong>CLOSE-WAIT</strong> 状态</mark>，客户端进入 <strong>FIN-WAIT-2</strong> 状态。</li><li><strong>第三次挥手</strong>：服务端发送一个 FIN (SEQ=y)标志的数据包-&gt;客户端，<mark>请求关闭连接</mark>，然后服务端进入 <strong>LAST-ACK</strong> 状态。</li><li><strong>第四次挥手</strong>：客户端发送 ACK (ACK=y+1)标志的数据包-&gt;服务端，然后客户端进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。</li></ol><p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong></p><h3 id="45为什么要四次挥手"><a class="markdownIt-Anchor" href="#45为什么要四次挥手"></a> 4.5为什么要四次挥手？</h3><p>TCP 是全双工通信，可以双向传输数据。<mark>任何一方都可以在数据传送结束后发出连接释放的通知</mark>，待对方确认后进入==<strong>半关闭状态</strong>==。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p><p>举个例子：A 和 B 打电话，通话即将结束后。</p><ol><li><strong>第一次挥手</strong>：A 说“我没啥要说的了”</li><li><strong>第二次挥手</strong>：B 回答“我知道了”，但是 <mark>B 可能还会有要说的话</mark>，A 不能要求 B 跟着自己的节奏结束通话</li><li><strong>第三次挥手</strong>：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”</li><li><strong>第四次挥手</strong>：A 回答“知道了”，这样通话才算结束。</li></ol><h3 id="46为什么不能把服务器发送的ack和fin合并起来变成三次挥手"><a class="markdownIt-Anchor" href="#46为什么不能把服务器发送的ack和fin合并起来变成三次挥手"></a> 4.6为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手？</h3><p>因为服务器收到客户端断开连接的请求时，<mark><strong>可能还有一些数据没有发完</strong></mark>，这时<mark>先回复 ACK，表示接收到了断开连接的请求</mark>。等到数据发完之后再发 FIN，<mark>断开服务器到客户端的数据传送</mark>。</p><h3 id="47若第二次挥手时服务器的ack没有送达客户端会怎么样"><a class="markdownIt-Anchor" href="#47若第二次挥手时服务器的ack没有送达客户端会怎么样"></a> 4.7若第二次挥手时服务器的ACK没有送达客户端，会怎么样？</h3><p>客户端没有收到 ACK 确认，<mark>会重新发送 FIN 请求</mark>。</p><h1 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h1><h2 id="1进程线程协程"><a class="markdownIt-Anchor" href="#1进程线程协程"></a> 1.进程/线程/协程</h2><h3 id="11进程和线程的异同"><a class="markdownIt-Anchor" href="#11进程和线程的异同"></a> 1.1进程和线程的异同</h3><p>进程和线程之间的区别可以从本质区别、开销方面、稳定性方面、内存分配方面、包含关系共五个角度去分析：</p><ol><li><mark>本质区别</mark>：<ul><li>进程是<mark>操作系统资源分配</mark>的基本单位，是程序的一次执行，比如我们在电脑上每开启的一次微信窗口</li><li>线程是<mark>任务调度和执行</mark>的基本单位，是进程的一个实体，是CPU调度和分派的基本单位</li></ul></li><li><mark>开销方面</mark>：<ul><li>每个进程都有独立的代码和数据空间（程序上下文），<mark>程序之间的切换会有较大的开销</mark>；</li><li>线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），<mark>线程之间切换的开销小</mark></li></ul></li><li><mark>内存分配方面</mark>：<ul><li>系统在运行的时候<mark>会为每个进程分配不同的内存空间</mark></li><li>而对线程而言，除了CPU外，<mark>系统不会为线程分配内存</mark>（线程所使用的资源来自其所属进程的资源），<mark>线程组之间只能共享资源</mark></li></ul></li><li><strong><mark>包含关系</mark></strong>：<ul><li>没有线程的进程可以看做是单线程的</li><li>如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；</li><li><mark>线程是进程的一部分</mark>，所以线程也被称为轻权进程或者轻量级进程</li></ul></li></ol><h3 id="12进程线程优缺点"><a class="markdownIt-Anchor" href="#12进程线程优缺点"></a> 1.2进程/线程优缺点</h3><ul><li><p>进程优点：</p><ul><li>顺序程序的特点：具有封闭性和可再现性；</li><li>程序的并发执行和资源共享。多道程序设计出现后，实现了程序的并发执行和资源共享，提高了系统的资源利用率</li></ul></li><li><p>进程缺点：</p><ul><li>操作系统调度<mark>切换多个线程要比切换调度进程在速度上快的多</mark>。</li><li>而且<mark>进程间内存无法共享，通讯也比较麻烦</mark>。</li></ul></li><li><p>线程优点：</p><ul><li>线程之间切换速度快</li><li>线程间内存共享，资源共享</li></ul></li><li><p>线程缺点：</p><ul><li>调度时, 要保存线程状态，频繁调度, 需要占用大量的机时；</li><li>程序设计上容易出错（线程同步问题）</li></ul></li></ul><h3 id="13进程之间通信的方法"><a class="markdownIt-Anchor" href="#13进程之间通信的方法"></a> 1.3进程之间通信的方法</h3><ol><li>由于每个<mark>进程的用户空间都是独立的</mark>，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。</li><li>Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是<mark>管道，管道分为「匿名管道」和「命名管道」</mark>。<ul><li><strong><mark>匿名管道</mark></strong>：顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「|」竖线就是匿名管道，通信的数据是<strong>无格式的流并且大小受限</strong>，通信的方式是<strong>单向</strong>的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，匿名管道是只能**<mark>用于存在父子关系</mark>的进程间通信**，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。</li><li><mark><strong>命名管道</strong></mark>：突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么<strong>毫无关系的进程就可以通过这个设备文件进行通信</strong>。另外，不管是匿名管道还是命名管道，进程写入的数据都是<strong>缓存在内核</strong>中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</li><li><strong><mark>消息队列</mark></strong>：克服了管道通信的数据是<strong>无格式的字节流的问题</strong>，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟<strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程</strong>。</li><li><strong><mark>共享内存</mark></strong>：以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，它<strong>直接分配一个共享空间，每个进程都可以直接访问</strong>，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有最快的进程间通信方式之名。但是便捷高效的共享内存通信，<strong>带来新的问题，多进程竞争同个共享资源会造成数据的错乱</strong>。</li><li>需要**<mark>信号量</mark><strong>来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。</strong><mark>信号量不仅可以实现访问的互斥性，还可以实现进程间的同步</mark>**，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 <strong>P 操作和 V 操作</strong>。</li></ul></li></ol><h3 id="14线程之间通信的方法"><a class="markdownIt-Anchor" href="#14线程之间通信的方法"></a> 1.4线程之间通信的方法</h3><p>在Linux系统中，线程间通信的方式包括：</p><ul><li><strong><mark>互斥锁（Mutex）</mark></strong>：线程可以使用互斥锁来保护共享资源，确保同时只有一个线程可以访问该资源。</li><li><strong><mark>条件变量</mark></strong>：线程可以使用条件变量来等待特定条件的发生，以实现线程间的协调和通知。</li><li><strong><mark>信号量</mark></strong>：线程可以使用信号量来控制对共享资源的访问，实现线程间的同步和互斥。</li><li><strong><mark>读写锁</mark></strong>：允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。</li></ul><h3 id="15什么是线程上下文切换"><a class="markdownIt-Anchor" href="#15什么是线程上下文切换"></a> 1.5什么是线程上下文切换</h3><p>线程在执行过程中会有<mark>自己的运行条件和状态（也称上下文）</mark>，比如<mark>程序计数器，虚拟机栈和本地方法栈</mark>等。</p><p>当出现如下情况的时候，会发生线程切换。</p><ul><li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li><li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</li><li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li></ul><p>线程切换意味着需要保存当前<strong>线程的上下文（比如程序计数器，虚拟机栈和本地方法栈）</strong>，<mark>留待线程下次占用 CPU 的时候<strong>恢复现场</strong></mark>。并<strong>加载下一个</strong>将要占用 CPU 的<strong>线程上下文</strong>。这就是所谓的 <strong>上下文切换</strong>。频繁上下文切换就会造成整体效率低下。</p><h3 id="16什么是线程死锁如何避免"><a class="markdownIt-Anchor" href="#16什么是线程死锁如何避免"></a> 1.6什么是线程死锁？如何避免？</h3><ul><li><p>死锁（Deadlock）描述的是这样一种情况：多个进程/线程<strong>同时被阻塞</strong>，它们中的**<mark>一个或者全部</mark><strong>都在等待==某个</strong>资源被释放**==。由于进程/线程被无限期地阻塞，因此程序不可能正常终止。</p></li><li><p>四个必要条件</p><ul><li><mark>互斥</mark>（x）：资源是独占的且排他使用，<mark>进程互斥使用资源</mark>，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源被另一进程占有时，则申请者等待直到资源被占有者释放。</li><li><mark>请求并保持</mark>：进程每次申请它所需要的一部分资源，<mark>在申请新的资源的同时，继续占用已分配到的资源</mark>。</li><li><mark>非抢占</mark>：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放</li><li><mark>循环等待</mark>（资源有序分配，即标序号）：在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所深情地资源。</li></ul></li><li><p>破坏死锁：那么避免死锁问题就只需要破环其中一个条件就可以，最常见的并且可行的就是**<mark>使用资源有序分配法</mark>，来破环环路等待条件**。</p><ul><li>例如：进程PA，使用资源的顺序是R1，R2；<br />进程PB，使用资源的顺序是R2，R1；<br />若<mark>采用动态分配有可能形成环路条件，造成死锁</mark>。<br />采用有序资源分配法：R1的编号为1，R2的编号为2；<br />PA：申请次序应是：R1，R2<br />PB：申请次序应是：R1，R2</li></ul></li></ul><h3 id="17杀死进程的方法"><a class="markdownIt-Anchor" href="#17杀死进程的方法"></a> 1.7杀死进程的方法</h3><ul><li>linux</li></ul><p>首先，使用ps命令查找进程的PID（进程ID），然后使用kill命令加上PID来终止进程。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep &lt;进程名&gt;   // 查找进程的PID</span><br><span class="line">kill &lt;PID&gt;              // 终止进程</span><br></pre></td></tr></table></figure><ul><li>windows</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | findstr &quot;1098&quot; //查询端口号对应的进程id</span><br><span class="line">taskkill /T /F /PID //强制（/F参数）杀死 PID 为 xxx 的所有进程，包括子进程（/T参数）</span><br></pre></td></tr></table></figure><h2 id="2协程少问"><a class="markdownIt-Anchor" href="#2协程少问"></a> 2.协程（少问）</h2><h3 id="21协程的定义"><a class="markdownIt-Anchor" href="#21协程的定义"></a> 2.1协程的定义？</h3><ol><li>协程， 我们又称为微线程，协程它不像线程和进程那样，需要进行系统内核上的上下文切换，<mark>协程的上下文切换是由开发人员决定的</mark>。</li><li>协程是一种用户级的轻量级线程。协程<mark>拥有自己的寄存器上下文和栈</mark>。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。</li></ol><h3 id="22使用协程的原因"><a class="markdownIt-Anchor" href="#22使用协程的原因"></a> 2.2使用协程的原因？</h3><ol><li>与线程相关的概念就是<mark>抢占式多任务</mark>（Preemptive multitasking），而与协程相关的是<mark>协作式多任务</mark></li><li>不管是进程还是线程，每次阻塞、切换都需要陷入系统调用(system call)，先让CPU跑操作系统的调度程序，然后再由调度程序决定该跑哪一个进程(线程)。由于抢占式调度执行顺序无法确定的特点，<mark><strong>使用线程时需要非常小心地处理同步问题</strong></mark>，而协程完全不存在这个问题（事件驱动和异步程序也有同样的优点）。</li><li>因为协程是<mark>用户自己来编写调度逻辑</mark>的，对于我们的CPU来说，协程其实是单线程，所以CPU不用去考虑怎么调度、切换上下文，这就省去了CPU的切换开销，所以协程在一定程度上又好于多线程。</li></ol><h3 id="23协程的优缺点"><a class="markdownIt-Anchor" href="#23协程的优缺点"></a> 2.3协程的优缺点</h3><ul><li><p>优点：</p><ul><li>无需系统内核的上下文切换，减小开销；</li><li>无需原子操作锁定及同步的开销，不用担心资源共享的问题；</li><li>单线程即可实现高并发，单核 CPU 即便支持上万的协程都不是问题，所以很适合用于高并发处理，尤其是在应用在网络爬虫中。</li></ul></li><li><p>缺点：</p><ul><li><p>无法使用 CPU 的多核</p></li><li><p>处处都要使用非阻塞代码</p></li></ul></li></ul><h2 id="3线程的生命周期"><a class="markdownIt-Anchor" href="#3线程的生命周期"></a> 3.线程的生命周期</h2><h3 id="31线程的六种生命状态"><a class="markdownIt-Anchor" href="#31线程的六种生命状态"></a> 3.1线程的六种生命状态</h3><ul><li>如图，线程有六种生命状态：新建、可执行（就绪、运行）、阻塞、等待、计时等待、死亡</li></ul><p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202409162309766.png" alt="image-20240326084258385" /></p><h3 id="32sleep方法和wait的异同"><a class="markdownIt-Anchor" href="#32sleep方法和wait的异同"></a> 3.2sleep()方法和wait()的异同</h3><ul><li>相同点：两者都可以暂停线程的执行</li><li>不同点：<ul><li><mark><strong>是否有释放锁</strong></mark>：<ul><li>sleep()方法没有释放锁（synchronized的锁），用于暂停执行任务</li><li>wait() 方法释放了锁，用于线程之间的交互</li></ul></li><li><mark><strong>是否自动苏醒</strong></mark>：<ul><li>sleep()方法执行完成后，线程会<strong>自动苏醒</strong>，或者也可以使用 wait(long timeout) <strong>超时</strong>后线程会<strong>自动苏醒</strong>。</li><li>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用<strong>同一个对象</strong>上的 <strong><code>notify()</code>或者 <code>notifyAll()</code></strong> 方法。</li></ul></li><li><mark><strong>归属类不同：</strong></mark><ul><li>sleep()是 <mark><strong>Thread 类</strong><mark>的静态本地方法**（sleep()方法是让当前</mark>线程暂停执行</mark>，<mark>不涉及对象锁</mark>）**</li><li>wait() 则是 ==<strong>Object类的</strong>==本地方法，<mark>wait()是让获得对象锁的线程实现等待</mark>，会自动释放当前线程占有的对象锁）。</li></ul></li></ul></li></ul><h3 id="33notify和notifyall的区别"><a class="markdownIt-Anchor" href="#33notify和notifyall的区别"></a> 3.3notify()和notifyAll的区别</h3><p>同样是唤醒等待的线程，同样最多只有一个线程能获得锁，同样不能控制哪个线程获得锁。</p><p>区别在于：</p><ul><li>notify：<ul><li><mark>唤醒一个线程</mark>，其他线程依然处于wait的等待唤醒状态</li><li><mark>如果被唤醒的线程结束时没调用notify，其他线程就永远没人去唤醒</mark>，只能等待超时，或者被中断</li></ul></li><li>notifyAll：<ul><li>唤醒全部线程，<mark>所有线程退出wait的状态，开始竞争锁</mark></li><li>但<mark>只有一个线程能抢到</mark>，这个线程执行完后，其他线程又会有一个幸运儿脱颖而出得到锁</li></ul></li></ul><h3 id="34为什么wait要包在同步块中"><a class="markdownIt-Anchor" href="#34为什么wait要包在同步块中"></a> 3.4为什么wait()要包在同步块中？</h3><ul><li><strong><mark>线程安全</mark></strong>：在同步块中调用<code>wait()</code>方法可以确保线程在调用<code>wait()</code>前已经获取了对象的锁，避免多线程之间的竞争和数据不一致性问题。</li><li><strong><mark>对象监视器</mark></strong>：<code>wait()</code>方法会释放对象的监视器（monitor），其他线程可以获取该对象的监视器并执行同步操作，确保线程之间的协作和同步。</li><li><strong><mark>唤醒机制</mark></strong>：当调用<code>wait()</code>方法后，线程会进入等待状态，只有在其他线程调用<code>notify()</code>或<code>notifyAll()</code>方法唤醒该线程时，线程才会继续执行。在同步块中调用<code>wait()</code>可以保证线程被正确唤醒。</li></ul><h3 id="35如何停止一个线程的运行"><a class="markdownIt-Anchor" href="#35如何停止一个线程的运行"></a> 3.5如何停止一个线程的运行?</h3><p>主要有这些方法：</p><ul><li><strong><mark>异常法停止</mark></strong>：线程调用interrupt()方法后，在线程的run方法中判断当前对象的interrupted()状态，如果是中断状态则抛出异常，达到中断线程的效果。</li><li><strong><mark>在沉睡中停止</mark></strong>：先将线程sleep，然后调用interrupt标记中断状态，interrupt会将阻塞状态的线程中断。会抛出中断异常，达到停止线程的效果</li><li><strong><mark>stop()暴力停止</mark></strong>：线程调用stop()方法会被暴力停止，方法已弃用，该方法会有不好的后果：强制让线程停止有可能使一些请理性的工作得不到完成。</li><li><strong><mark>使用return停止线程</mark></strong>：调用interrupt标记为中断状态后，在run方法中判断当前线程状态，如果为中断状态则return，能达到停止线程的效果。</li></ul><h2 id="4软连接和硬连接有什么区别"><a class="markdownIt-Anchor" href="#4软连接和硬连接有什么区别"></a> 4.软连接和硬连接有什么区别？</h2><ul><li><p><strong>软连接</strong>：实际上是一个<mark>指向目标文件的路径的符号链接</mark>，类似于Windows系统中的快捷方式，创建软连接不会占用目标文件的inode节点，只是<mark>简单地指向目标文件的路径</mark>。删除原始文件后，软连接仍然存在，但指向的目标文件失效，称为&quot;悬空链接&quot;。软链接可以跨文件系统创建软连接。</p></li><li><p><strong>硬连接</strong>：是指<mark>多个文件实际上指向同一个inode节点，即多个文件共享同一块数据块</mark>。创建硬连接会增加目标文件的链接计数，删除任何一个硬连接并不会影响其他硬连接指向的文件数据。只能在同一文件系统内创建硬连接。</p></li></ul><h2 id="5内核态和用户态"><a class="markdownIt-Anchor" href="#5内核态和用户态"></a> 5.内核态和用户态</h2><p>内核态和用户态是操作系统中的两种运行模式。它们的主要区别<mark>在于权限和可执行的操作</mark>：</p><ol><li><mark><strong>内核态</strong></mark>（Kernel Mode）：在内核态下，<mark>CPU可以执行所有的指令和访问所有的硬件资源</mark>。这种模式下的操作具有更高的权限，主要用于操作系统内核的运行。</li><li><mark><strong>用户态</strong></mark>（User Mode）：在用户态下，<mark>CPU只能执行部分指令集，无法直接访问硬件资源</mark>。这种模式下的操作权限较低，主要用于运行用户程序。</li></ol><p>内核态的底层操作主要包括：内存管理、进程管理、设备驱动程序控制、系统调用等。这些操作涉及到操作系统的核心功能，需要较高的权限来执行。</p><p>分为内核态和用户态的原因主要有以下几点：</p><ol><li><mark><strong>安全性</strong></mark>：通过对权限的划分，用户程序无法直接访问硬件资源，从而避免了恶意程序对系统资源的破坏。</li><li><mark><strong>稳定性</strong></mark>：用户态程序出现问题时，不会影响到整个系统，避免了程序故障导致系统崩溃的风险。</li><li><mark><strong>隔离性</strong></mark>：内核态和用户态的划分使得操作系统内核与用户程序之间有了明确的边界，有利于系统的模块化和维护。</li></ol><p>内核态和用户态的划分有助于保证操作系统的安全性、稳定性和易维护性。</p><h2 id="6有哪些进程调度算法"><a class="markdownIt-Anchor" href="#6有哪些进程调度算法"></a> 6.有哪些进程调度算法</h2><h3 id="61先来先服务调度算法"><a class="markdownIt-Anchor" href="#61先来先服务调度算法"></a> 6.1先来先服务调度算法</h3><p>顾名思义，先来后到，<strong>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/be03d024cb580776e7b311f15695a8f6.png" alt="图片" /></p><h3 id="62最短作业优先调度算法"><a class="markdownIt-Anchor" href="#62最短作业优先调度算法"></a> 6.2最短作业优先调度算法</h3><p>顾名思义，它会**<mark>优先选择运行时间最短的进</mark>程来运行**，这有助于提高系统的吞吐量。</p><h3 id="63高响应比优先调度算法"><a class="markdownIt-Anchor" href="#63高响应比优先调度算法"></a> 6.3高响应比优先调度算法</h3><p><strong>每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行</strong></p><p>响应比优先级」的计算公式：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1dbf64926e5650d2544d3d34e3b369fc.png" alt="图片" /></p><h3 id="64时间片轮转调度算法"><a class="markdownIt-Anchor" href="#64时间片轮转调度算法"></a> 6.4时间片轮转调度算法</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/247cd863568e4914c95cf5121b2d1d12.png" alt="图片" /></p><p><strong>每个进程被分配一个时间段，称为时间片（*Quantum*），即允许该进程在该时间段中运行。</strong></p><ul><li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外一个进程；</li><li>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="【知识总结】" scheme="https://www.haipeng-lin.cn/categories/%E3%80%90%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%E3%80%91/"/>
    
    
  </entry>
  
  <entry>
    <title>随笔 | 大学四年历程</title>
    <link href="https://www.haipeng-lin.cn/posts/a062b9f3.html"/>
    <id>https://www.haipeng-lin.cn/posts/a062b9f3.html</id>
    <published>2024-09-12T00:31:07.000Z</published>
    <updated>2024-10-12T14:15:56.252Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>  其实想写大学四年历程这篇文章很久了，但一直抽不出时间来。我不想等到明年毕业才写，担心记忆会越来越模糊，慢慢消散，免得遗憾，也是为了以后看时还能回忆青春（站可能都关了<s>bushi</s>）现在实习结束，在学校上课设，所以趁这个机会，回顾在仲园（仲恺校园）这三、四年的流水账。</p><p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202409201839163.png" alt="" /></p><h1 id="初遇"><a class="markdownIt-Anchor" href="#初遇"></a> 初遇</h1><p>  时间回到2021年7月中旬的某天中午，说好的12点出高考成绩，没想到提前发短信，533分，排名9w。悬着的心终于死了，当时想着有公办本科学校能收留我就行哈哈。</p><p>  那天晚上我姐就和我聊了一下仲恺的学校信息和理工科专业。仲恺海珠校区，到越秀、天河、荔湾、番禺，半个小时或一个小时就能到，到时候大三/四找实习方便一点，不用租房，可以住在学校，今年找实习就住了学校嘿嘿；仲恺信科院专业在本质上分为两类：<mark>软件类和硬件类</mark> ，软件类有计算机和大数据专业，硬件类有物联网、电子、网络等专业，9w排名可以冲冲计算机专业。<br />  那为什么最后选择计算机专业哩，首先当时对电脑有兴趣，第二，软件类比硬件类好学一点，学习资料多，而且一台电脑就够学了，第三，学校的硬件设施类都是20世纪的，还是软件方便，以及想趁年轻赚多一点点钱，所以第一专业就填了计算机。</p><p>  10几天后，录取结果出来了，因为21年学校扩招，我就踩线录取到了第一志愿：计算机，梦开始的地方。</p><p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410122208915.png" alt="" /></p><h1 id="开篇"><a class="markdownIt-Anchor" href="#开篇"></a> 开篇</h1><p>  2021年9月16日，那天初次到达仲园，我是第一个到宿舍的，六人间。</p><p>  第一印象就是宿舍也太烂了叭，虽然已经做了心里预期，但还是有点小震惊，我高中有个同学是被仲恺的宿舍吓跑的，最后去了广海~。宿舍门窗都是上个世纪的，宿舍被吐槽最多的便是<mark>空调的外机是朝向厕所</mark>的，每次到阳台/厕所都得经历过一次汗的沐浴（怎么会有这样子设计的！）</p><blockquote><p>叙利亚宿舍！</p></blockquote><p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/image-20240912093722185.png" alt="" /></p><blockquote><p>忍不了一点，当时军训完，我们就动手装修宿舍，附上装修完的效果</p></blockquote><p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202409132344365.png" alt="" /></p><p>  回到开学那天，为期14天的军训生活便开始了，第一天晚上主要是认识教官、教官跟我们说每次集合的地点和地点。整个军训过程，我觉得强度挺大滴，但是累并快乐和充实着，早上6点到7点晨训、7点50到12点早训（第一天本来是7点30就要集合，但是食堂太多人了，很多还没吃上早餐，就得去集合，所以后面改了）、14点30到18点下午训、19点到22点晚训。</p><p>  我记得那时候天气蛮热的，十四天中就一两天有雨，其他均是大太阳，依稀记得早上5点半下去，7点训完，衣服已经湿透了哈哈哈。</p><p>  我记得早中晚训开始前都有一个环节，那便是站军姿，伴随着军训指挥台上教官在喊：“两脚跟并拢，两脚尖分开约六十度，两腿挺直”，下面的各营教官便开始互查各营学生的军姿情况：“你的腰带松得已经放入一瓶水壶了”，“双手有没有十指合拢！来，夹上扑克牌”，“你的帽子呢、鞋子呢？”，记得有人把帽子放在宿舍楼梯的上下楼梯转角处，忘记带上，教官发在群里问，这是谁的帽子，快来领。</p><p>  军训的内容有正步、队列、军体拳、敬礼、蹲下等等内容，突然感慨时间真的过得很快，这些已经过去了三年了，好快，好快。</p><h1 id="学习"><a class="markdownIt-Anchor" href="#学习"></a> 学习</h1><p>  我们在大一上便上了C语言、离散数学、高等数学…，离散数学和大三的计组是潇姐教的，潇姐是我们大学里最喜欢的老师之一，人美心善，讲课过程仲致力于追求让我们听得懂，布置的作业又不会很难，期末有安排复习，真的很好。大一上期末考试，刚刚考完离散数学时，潇姐拉的离散数学交流群的消息都是”<mark>老师  菜菜  捞捞  呜呜</mark>“、”水果捞“、”海底捞“，哈哈哈哈。</p><p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202409132350621.png" alt="" /></p><p>  我在大一上就确定了我未来的就业方向，<mark>Java后端</mark>。为什么不选择其他方向的呢？前端：需要调页面样式，不能接触到后端核心业务，可替代性高，越来越多的后端把前端的活也干了；算法：不太感冒，就业门槛高；运维：发展空间小。</p><p>  当时听师兄说，来学 Java ，学一把个月，做点项目，就可以月入过万了，但是现在来看几乎不可能，太难了现在。</p><p>  确定好了方向之后，大一上便开始学习，技能掌握如下：Java 基础、MySQL 、Redis 、JavaWeb（已过时）、Spring 、SpringMVC 、SpringBoot 、RabbitMQ 、SpringCloud。之后就是大三下顺利找到了一个立白金控（宝凯道融）的 Java 开发实习。</p><p>  你问我在仲恺待得最久、最多的地方是什么？我想除了洗澡休息睡觉的宿舍之外，便是<mark>图书馆</mark>，图书馆伴随了我的备考四六级、专业技能学习、期末复习、准备面试、八股文等等。</p><p>  图书馆一楼，两边的是研修室，备考考研、考公、考证、以及期末复习的学生，一般会选择研修室来学习；二楼，借还书地方，以及两边比较少的座位；三楼，两边是电脑室，充电位还是有点少，希望仲恺图书馆以后能装多一些插座，不然很不方便；四楼，外面学习桌，以及两边的阅览位置，没充电位位置还是挺多的。</p><p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202409132345324.png" alt="" /></p><p>  课最多的学期是大二上，每天不是在上课，就是在上课的路上。</p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202409132345015.png" alt="image-20240912144705169" style="zoom:25%;" /><blockquote><p>同时挂三门课的网络课</p></blockquote><p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202409132345585.png" alt="" /></p><blockquote><p>教学楼</p></blockquote><p><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202409132345197.jpeg" alt="" /></p><h1 id="结束语"><a class="markdownIt-Anchor" href="#结束语"></a> 结束语</h1><p>​大学四年历程文章，提笔于2024年9月12日，首次完成初遇、开篇、学习、美食合集、天空合集</p><p>​后面再续！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="【随笔】" scheme="https://www.haipeng-lin.cn/categories/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91/"/>
    
    
    <category term="大学" scheme="https://www.haipeng-lin.cn/tags/%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>MiniDB——索引管理器</title>
    <link href="https://www.haipeng-lin.cn/posts/3e11dfdd.html"/>
    <id>https://www.haipeng-lin.cn/posts/3e11dfdd.html</id>
    <published>2024-09-09T09:18:34.000Z</published>
    <updated>2024-09-19T08:57:15.705Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="10索引管理器"><a class="markdownIt-Anchor" href="#10索引管理器"></a> 10.索引管理器</h1><blockquote><p>涉及代码：com.peng.minidb.backend.im包下</p></blockquote><h2 id="101前言"><a class="markdownIt-Anchor" href="#101前言"></a> 10.1前言</h2><p>​索引管理器是 MiniDB 中用于管理B+树索引的模块，为MiniDB提供了基于B+树的聚簇索引功能</p><p>​索引管理器基于数据管理器，即索引数据直接存储在数据库文件中</p><h2 id="102b树节点"><a class="markdownIt-Anchor" href="#102b树节点"></a> 10.2B+树节点</h2><h3 id="1021节点定义"><a class="markdownIt-Anchor" href="#1021节点定义"></a> 10.2.1节点定义</h3><p>​B+ 树由多个节点（Node）组成，<mark>每个节点都存储在一条 DataItem 中</mark>。其数据结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[LeafFlag]</span><br><span class="line">[KeyNumber]</span><br><span class="line">[SiblingUid]</span><br><span class="line">[Son0][Key0][Son1][Key1]...[SonN][KeyN]</span><br></pre></td></tr></table></figure><ul><li><strong>LeafFlag</strong>：标记该节点是否为叶子节点</li><li><strong>KeyNumber</strong>：该节点中键的数量</li><li><strong>SiblingUid</strong>：指向兄弟节点在 DM 中的 UID</li><li><strong>SonN 和 KeyN</strong>：交替存储子节点和键值对。最后一个键值始终为 <code>MAX_VALUE</code>，以便于查找</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/22115500/1723887530560-08c5efc8-f75c-468d-b22e-3b40e38dc892.png#averageHue=%23ececec&amp;clientId=u2839daa5-186c-4&amp;from=paste&amp;height=271&amp;id=u30a7cafb&amp;originHeight=542&amp;originWidth=2178&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=126303&amp;status=done&amp;style=none&amp;taskId=ua691b3ee-6cdb-4b9c-b755-4881aa26d0f&amp;title=&amp;width=1089" alt="image.png" /></p><h3 id="1022相关函数"><a class="markdownIt-Anchor" href="#1022相关函数"></a> 10.2.2相关函数</h3><h4 id="1基础函数"><a class="markdownIt-Anchor" href="#1基础函数"></a> （1）基础函数</h4><blockquote><p>setRawIsLeaf 设置是否为叶子节点，1表示是叶子节点，0表示非叶子节点</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setRawIsLeaf</span><span class="params">(SubArray raw, <span class="type">boolean</span> isLeaf)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(isLeaf) &#123;</span><br><span class="line">        raw.raw[raw.start + IS_LEAF_OFFSET] = (<span class="type">byte</span>)<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        raw.raw[raw.start + IS_LEAF_OFFSET] = (<span class="type">byte</span>)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2生成一个根节点"><a class="markdownIt-Anchor" href="#2生成一个根节点"></a> （2）生成一个根节点</h4><blockquote><p>根节点包含两个初始子节点 <code>left</code> 和 <code>right</code>，以及一个初始键值 <code>key</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] newRootRaw(<span class="type">long</span> left, <span class="type">long</span> right, <span class="type">long</span> key)  &#123;</span><br><span class="line">    <span class="type">SubArray</span> <span class="variable">raw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubArray</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[NODE_SIZE], <span class="number">0</span>, NODE_SIZE);</span><br><span class="line">    setRawIsLeaf(raw, <span class="literal">false</span>);</span><br><span class="line">    setRawNoKeys(raw, <span class="number">2</span>);</span><br><span class="line">    setRawSibling(raw, <span class="number">0</span>);</span><br><span class="line">    setRawKthSon(raw, left, <span class="number">0</span>);</span><br><span class="line">    setRawKthKey(raw, key, <span class="number">0</span>);</span><br><span class="line">    setRawKthSon(raw, right, <span class="number">1</span>);</span><br><span class="line">    setRawKthKey(raw, Long.MAX_VALUE, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> raw.raw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3生成一个空的根节点"><a class="markdownIt-Anchor" href="#3生成一个空的根节点"></a> （3）生成一个空的根节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] newNilRootRaw()  &#123;</span><br><span class="line">    <span class="type">SubArray</span> <span class="variable">raw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubArray</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[NODE_SIZE], <span class="number">0</span>, NODE_SIZE);</span><br><span class="line"></span><br><span class="line">    setRawIsLeaf(raw, <span class="literal">true</span>);</span><br><span class="line">    setRawNoKeys(raw, <span class="number">0</span>);</span><br><span class="line">    setRawSibling(raw, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> raw.raw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4搜索插入节点位置"><a class="markdownIt-Anchor" href="#4搜索插入节点位置"></a> （4）搜索插入节点位置</h4><blockquote><p>根据给定的键值，查找对应的 UID。如果未找到，则返回兄弟节点的 UID</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SearchNextRes <span class="title function_">searchNext</span><span class="params">(<span class="type">long</span> key)</span> &#123;</span><br><span class="line">    dataItem.rLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SearchNextRes</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchNextRes</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">noKeys</span> <span class="operator">=</span> getRawNoKeys(raw);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; noKeys; i ++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ik</span> <span class="operator">=</span> getRawKthKey(raw, i);</span><br><span class="line">            <span class="keyword">if</span>(key &lt; ik) &#123;</span><br><span class="line">                res.uid = getRawKthSon(raw, i);</span><br><span class="line">                res.siblingUid = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.uid = <span class="number">0</span>;</span><br><span class="line">        res.siblingUid = getRawSibling(raw);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        dataItem.rUnLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5搜索节点"><a class="markdownIt-Anchor" href="#5搜索节点"></a> （5）搜索节点</h4><blockquote><p><code>leafSearchRange</code><strong>方法</strong>：在当前节点内进行范围查找，范围为 <code>[leftKey, rightKey]</code>。如果 <code>rightKey</code> 大于等于该节点的最大键值，则返回兄弟节点的 UID，方便继续搜索下一个节点</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LeafSearchRangeRes</span> &#123;</span><br><span class="line">    List&lt;Long&gt; uids;</span><br><span class="line">    <span class="type">long</span> siblingUid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> LeafSearchRangeRes <span class="title function_">leafSearchRange</span><span class="params">(<span class="type">long</span> leftKey, <span class="type">long</span> rightKey)</span> &#123;</span><br><span class="line">    dataItem.rLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">noKeys</span> <span class="operator">=</span> getRawNoKeys(raw);</span><br><span class="line">        <span class="type">int</span> <span class="variable">kth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(kth &lt; noKeys) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ik</span> <span class="operator">=</span> getRawKthKey(raw, kth);</span><br><span class="line">            <span class="keyword">if</span>(ik &gt;= leftKey) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            kth ++;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Long&gt; uids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(kth &lt; noKeys) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ik</span> <span class="operator">=</span> getRawKthKey(raw, kth);</span><br><span class="line">            <span class="keyword">if</span>(ik &lt;= rightKey) &#123;</span><br><span class="line">                uids.add(getRawKthSon(raw, kth));</span><br><span class="line">                kth ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">siblingUid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(kth == noKeys) &#123;</span><br><span class="line">            siblingUid = getRawSibling(raw);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LeafSearchRangeRes</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeafSearchRangeRes</span>();</span><br><span class="line">        res.uids = uids;</span><br><span class="line">        res.siblingUid = siblingUid;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        dataItem.rUnLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6插入节点"><a class="markdownIt-Anchor" href="#6插入节点"></a> （6）插入节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> InsertAndSplitRes <span class="title function_">insertAndSplit</span><span class="params">(<span class="type">long</span> uid, <span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Exception</span> <span class="variable">err</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InsertAndSplitRes</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InsertAndSplitRes</span>();</span><br><span class="line"></span><br><span class="line">    dataItem.before();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        success = insert(uid, key);</span><br><span class="line">        <span class="keyword">if</span>(!success) &#123;</span><br><span class="line">            res.siblingUid = getRawSibling(raw);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(needSplit()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">SplitRes</span> <span class="variable">r</span> <span class="operator">=</span> split();</span><br><span class="line">                res.newSon = r.newSon;</span><br><span class="line">                res.newKey = r.newKey;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                err = e;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(err == <span class="literal">null</span> &amp;&amp; success) &#123;</span><br><span class="line">            dataItem.after(TransactionManagerImpl.SUPER_XID);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dataItem.unBefore();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="103b树"><a class="markdownIt-Anchor" href="#103b树"></a> 10.3B+树</h2><h3 id="1031b树定义"><a class="markdownIt-Anchor" href="#1031b树定义"></a> 10.3.1B+树定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DataManager dm;<span class="comment">// 数据管理器</span></span><br><span class="line"><span class="type">long</span> bootUid;<span class="comment">// 根节点uid</span></span><br><span class="line">DataItem bootDataItem;<span class="comment">// 根节点数据项</span></span><br><span class="line">Lock bootLock</span><br></pre></td></tr></table></figure><p>这里的<code>BootUid</code>和<code>BootDataItem</code>对应的是B+树的根节点uid和根节点uid对应的<code>DataItem</code></p><h3 id="1032相关函数"><a class="markdownIt-Anchor" href="#1032相关函数"></a> 10.3.2相关函数</h3><h4 id="1创建b树"><a class="markdownIt-Anchor" href="#1创建b树"></a> （1）创建B+树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">create</span><span class="params">(DataManager dm)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 生成一个空的根节点</span></span><br><span class="line">    <span class="type">byte</span>[] rawRoot = Node.newNilRootRaw();</span><br><span class="line">    <span class="comment">// 往数据文件插入根节点数据</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">rootUid</span> <span class="operator">=</span> dm.insert(TransactionManagerImpl.SUPER_XID, rawRoot);</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">return</span> dm.insert(TransactionManagerImpl.SUPER_XID, Parser.long2Byte(rootUid));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2加载b树"><a class="markdownIt-Anchor" href="#2加载b树"></a> （2）加载B+树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BPlusTree <span class="title function_">load</span><span class="params">(<span class="type">long</span> bootUid, DataManager dm)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">DataItem</span> <span class="variable">bootDataItem</span> <span class="operator">=</span> dm.read(bootUid);</span><br><span class="line">    <span class="keyword">assert</span> bootDataItem != <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BPlusTree</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BPlusTree</span>();</span><br><span class="line">    t.bootUid = bootUid;</span><br><span class="line">    t.dm = dm;</span><br><span class="line">    t.bootDataItem = bootDataItem;</span><br><span class="line">    t.bootLock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3获取根节点的uid"><a class="markdownIt-Anchor" href="#3获取根节点的uid"></a> （3）获取根节点的uid</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">rootUid</span><span class="params">()</span> &#123;</span><br><span class="line">    bootLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SubArray</span> <span class="variable">sa</span> <span class="operator">=</span> bootDataItem.data();</span><br><span class="line">        <span class="keyword">return</span> Parser.parseLong(Arrays.copyOfRange(sa.raw, sa.start, sa.start+<span class="number">8</span>));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        bootLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4更新根节点的uid"><a class="markdownIt-Anchor" href="#4更新根节点的uid"></a> （4）更新根节点的uid</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateRootUid</span><span class="params">(<span class="type">long</span> left, <span class="type">long</span> right, <span class="type">long</span> rightKey)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    bootLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] rootRaw = Node.newRootRaw(left, right, rightKey);</span><br><span class="line">        <span class="type">long</span> <span class="variable">newRootUid</span> <span class="operator">=</span> dm.insert(TransactionManagerImpl.SUPER_XID, rootRaw);</span><br><span class="line">        bootDataItem.before();</span><br><span class="line">        <span class="type">SubArray</span> <span class="variable">diRaw</span> <span class="operator">=</span> bootDataItem.data();</span><br><span class="line">        System.arraycopy(Parser.long2Byte(newRootUid), <span class="number">0</span>, diRaw.raw, diRaw.start, <span class="number">8</span>);</span><br><span class="line">        bootDataItem.after(TransactionManagerImpl.SUPER_XID);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        bootLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5从一个节点开始搜索下一个节点"><a class="markdownIt-Anchor" href="#5从一个节点开始搜索下一个节点"></a> （5）从一个节点开始搜索下一个节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">searchNext</span><span class="params">(<span class="type">long</span> nodeUid, <span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> Node.loadNode(<span class="built_in">this</span>, nodeUid);</span><br><span class="line">        <span class="type">SearchNextRes</span> <span class="variable">res</span> <span class="operator">=</span> node.searchNext(key);</span><br><span class="line">        node.release();</span><br><span class="line">        <span class="keyword">if</span>(res.uid != <span class="number">0</span>) <span class="keyword">return</span> res.uid;</span><br><span class="line">        nodeUid = res.siblingUid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6搜索节点"><a class="markdownIt-Anchor" href="#6搜索节点"></a> （6）搜索节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">searchLeaf</span><span class="params">(<span class="type">long</span> nodeUid, <span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> Node.loadNode(<span class="built_in">this</span>, nodeUid);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLeaf</span> <span class="operator">=</span> node.isLeaf();</span><br><span class="line">    node.release();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isLeaf) &#123;</span><br><span class="line">        <span class="keyword">return</span> nodeUid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">next</span> <span class="operator">=</span> searchNext(nodeUid, key);</span><br><span class="line">        <span class="keyword">return</span> searchLeaf(next, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7插入数据"><a class="markdownIt-Anchor" href="#7插入数据"></a> （7）插入数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">long</span> key, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">rootUid</span> <span class="operator">=</span> rootUid();</span><br><span class="line">    <span class="type">InsertRes</span> <span class="variable">res</span> <span class="operator">=</span> insert(rootUid, uid, key);</span><br><span class="line">    <span class="keyword">assert</span> res != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(res.newNode != <span class="number">0</span>) &#123;</span><br><span class="line">        updateRootUid(rootUid, res.newNode, res.newKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> InsertRes <span class="title function_">insert</span><span class="params">(<span class="type">long</span> nodeUid, <span class="type">long</span> uid, <span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> Node.loadNode(<span class="built_in">this</span>, nodeUid);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLeaf</span> <span class="operator">=</span> node.isLeaf();</span><br><span class="line">    node.release();</span><br><span class="line"></span><br><span class="line">    <span class="type">InsertRes</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(isLeaf) &#123;</span><br><span class="line">        res = insertAndSplit(nodeUid, uid, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">next</span> <span class="operator">=</span> searchNext(nodeUid, key);</span><br><span class="line">        <span class="type">InsertRes</span> <span class="variable">ir</span> <span class="operator">=</span> insert(next, uid, key);</span><br><span class="line">        <span class="keyword">if</span>(ir.newNode != <span class="number">0</span>) &#123;</span><br><span class="line">            res = insertAndSplit(nodeUid, ir.newNode, ir.newKey);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = <span class="keyword">new</span> <span class="title class_">InsertRes</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8关闭b树"><a class="markdownIt-Anchor" href="#8关闭b树"></a> （8）关闭B+树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">    bootDataItem.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="【MiniDB】" scheme="https://www.haipeng-lin.cn/categories/%E3%80%90MiniDB%E3%80%91/"/>
    
    
  </entry>
  
  <entry>
    <title>MiniDB——版本管理器</title>
    <link href="https://www.haipeng-lin.cn/posts/cef83234.html"/>
    <id>https://www.haipeng-lin.cn/posts/cef83234.html</id>
    <published>2024-09-09T05:15:53.000Z</published>
    <updated>2024-09-19T08:57:07.984Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="9minidb版本管理器"><a class="markdownIt-Anchor" href="#9minidb版本管理器"></a> 9.MiniDB——版本管理器</h1><h2 id="91-2plmvcc"><a class="markdownIt-Anchor" href="#91-2plmvcc"></a> 9.1 2PL/MVCC</h2><h3 id="911冲突操作"><a class="markdownIt-Anchor" href="#911冲突操作"></a> 9.1.1冲突操作</h3><p>​在数据库中，多个事务可能会同时操作同一个数据项，这就可能导致冲突。</p><blockquote><p>两个事务对同一数据的update操作</p><p>两个事务对同一数据的update、read操作</p></blockquote><h3 id="912-2pl"><a class="markdownIt-Anchor" href="#912-2pl"></a> 9.1.2 2PL</h3><ol><li>定义：两阶段锁在事务执行过程中分为两个阶段：增长阶段和收缩阶段。在增长阶段，事务可以获取任意数量的锁，但不能释放任何锁；在收缩阶段，事务只能释放锁而不能再获取新的锁</li></ol><blockquote><ol start="2"><li>两阶段锁怎么解决数据库的冲突操作？</li></ol><p>要求事务在增长阶段获取所需的锁，并保证在释放锁前，其他事务无法访问已被锁定的资源，从而避免了操作冲突</p></blockquote><ol start="3"><li>问题：导致了事务的相互阻塞，性能差</li></ol><h3 id="913mvcc"><a class="markdownIt-Anchor" href="#913mvcc"></a> 9.1.3MVCC</h3><ol><li>定义：多版本并发控制，用于解决数据库中多个事务并发执行时的读写冲突问题。MVCC通过维护数据的多个版本，允许并发的读操作和写操作更有效地进行</li><li>核心概念：<ol><li>版本控制：每个数据项都有多个版本，当事务对数据进行修改时，系统不会直接覆盖旧版本的数据，而是创建一个新版本</li><li>事务标识：每个事务在开始时都会获得一个唯一的事务ID，这个事务ID用于决定事务可以访问哪些数据版本，从而确保数据的一致性和隔离性</li></ol></li><li>优点：<ol><li>并发性高：MVCC允许多个事务同时读取数据，而不需要加锁</li><li>避免读写冲突：通过维护数据的多个版本，读操作不会被写操作阻塞</li></ol></li><li>缺点：存储开销大、版本管理复杂性高</li><li>MiniDB中的MVCC：<ol><li>给VM之上的模块提供抽象数据：<mark>记录(Entry)</mark></li><li>版本管理器在内部，为每个记录维护了多个版本。当上层模块对某个记录修改时，<mark>版本管理器就创建一个新的版本</mark></li></ol></li></ol><h2 id="92entry"><a class="markdownIt-Anchor" href="#92entry"></a> 9.2Entry</h2><ol><li>Entry定义：<ol><li>XMIN：创建该记录的事务ID</li><li>XMAX：删除该记录的事务ID</li><li>data：该条记录持有的数据</li><li>创建一个新的记录对象、加载一个记录</li></ol></li></ol><h2 id="93事务隔离级别"><a class="markdownIt-Anchor" href="#93事务隔离级别"></a> 9.3事务隔离级别</h2><blockquote><p>MiniDB实现了两种事务隔离级别：读已提交、可重复读</p></blockquote><h3 id="931读已提交"><a class="markdownIt-Anchor" href="#931读已提交"></a> 9.3.1读已提交</h3><h4 id="1定义"><a class="markdownIt-Anchor" href="#1定义"></a> （1）定义</h4><blockquote><p>一个事务只能读取其他事务已经提交的数据，可能导致不可重复读问题</p></blockquote><h4 id="2实现逻辑"><a class="markdownIt-Anchor" href="#2实现逻辑"></a> （2）实现逻辑</h4><ul><li>如果版本的创建事务ID等于当前事务ID，并且版本的标志删除为空（表示未被删除）（<mark>即该版本由当前事务创建并且还没被删除，可见</mark>）</li><li>如果版本的创建事务ID对应的事务已经提交，并且版本的标志删除为空（未被删除）；<br />或者标志删除的事务ID不是当前事务ID，并该事务ID还没提交<br />即由<mark>一个已提交的事务创建且尚未被删除</mark>；或者由<mark>一个已提交的事务创建且只是未被提交的事务删除</mark></li></ul><h3 id="932可重复读"><a class="markdownIt-Anchor" href="#932可重复读"></a> 9.3.2可重复读</h3><h4 id="1定义-2"><a class="markdownIt-Anchor" href="#1定义-2"></a> （1）定义</h4><blockquote><p>定义：事务只能读取，事务开始时已经提交了的事务产生的数据的版本，确保事务在执行期间读取到的数据是一致的</p></blockquote><h4 id="2实现逻辑-2"><a class="markdownIt-Anchor" href="#2实现逻辑-2"></a> （2）实现逻辑</h4><ul><li>如果版本的创建事务ID等于当前事务ID，并且版本的标志删除为空（表示未被删除）（即该版本由当前事务创建并且还没被删除，可见）</li><li>如果版本的创建事务ID已经提交，并创建事务ID小于当前事务ID，并创建事务ID不在当前事务开始前火活跃的事务集合中，且<ul><li>删除版本的事务ID为空，表示该版本尚未被删除</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="【MiniDB】" scheme="https://www.haipeng-lin.cn/categories/%E3%80%90MiniDB%E3%80%91/"/>
    
    
  </entry>
  
  <entry>
    <title>项目部署</title>
    <link href="https://www.haipeng-lin.cn/posts/40aba349.html"/>
    <id>https://www.haipeng-lin.cn/posts/40aba349.html</id>
    <published>2024-09-09T02:13:35.000Z</published>
    <updated>2024-09-09T02:15:16.596Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1docker方式部署"><a class="markdownIt-Anchor" href="#1docker方式部署"></a> 1.Docker方式部署</h1><h2 id="11部署vue"><a class="markdownIt-Anchor" href="#11部署vue"></a> 1.1部署Vue</h2><h3 id="111修改服务器地址"><a class="markdownIt-Anchor" href="#111修改服务器地址"></a> 1.1.1修改服务器地址</h3><blockquote><p>全局修改访问路径中localhost为服务器地址</p></blockquote><h3 id="112打包"><a class="markdownIt-Anchor" href="#112打包"></a> 1.1.2打包</h3><blockquote><p>打包vue项目，生成dist文件夹</p><p>使用xftp工具将dist文件夹上传到服务器/home/前端项目名 文件夹下</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><h3 id="113dockerfile文件"><a class="markdownIt-Anchor" href="#113dockerfile文件"></a> 1.1.3Dockerfile文件</h3><blockquote><p>在同级目录编写Dockerfile文件，内容如下</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:latest</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./dist /usr/share/nginx/html/</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><h3 id="114生成镜像"><a class="markdownIt-Anchor" href="#114生成镜像"></a> 1.1.4生成镜像</h3><blockquote><p>生成名为shuzhi_vue的镜像</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t shuzhi_vue .</span><br></pre></td></tr></table></figure><blockquote><p>查看镜像</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images | grep shuzhi_vue</span><br></pre></td></tr></table></figure><h3 id="115运行容器"><a class="markdownIt-Anchor" href="#115运行容器"></a> 1.1.5运行容器</h3><blockquote><p>基于shuzhi_vue镜像运行一个shuzhi_vue-80容器</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 --name shuzhi_vue-80 shuzhi_vue</span><br></pre></td></tr></table></figure><blockquote><p>查看正在运行的容器</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><h3 id="116测试"><a class="markdownIt-Anchor" href="#116测试"></a> 1.1.6测试</h3><p>访问地址：<a href="http://xn--ip-fr5c86lw2a0cw16k:80/">http://服务器ip地址:80/</a></p><h2 id="12部署springboot"><a class="markdownIt-Anchor" href="#12部署springboot"></a> 1.2部署SpringBoot</h2><h3 id="121修改数据库信息"><a class="markdownIt-Anchor" href="#121修改数据库信息"></a> 1.2.1修改数据库信息</h3><blockquote><p>修改mysql、redis等数据库的 远程地址、用户名、密码</p></blockquote><h3 id="122打包"><a class="markdownIt-Anchor" href="#122打包"></a> 1.2.2打包</h3><blockquote><p>maven执行clean、install命令，生成jar包</p><p>使用xftp工具将jar包上传到服务器/home/后端项目名 文件夹下</p></blockquote><h3 id="123dockerfile文件"><a class="markdownIt-Anchor" href="#123dockerfile文件"></a> 1.2.3Dockerfile文件</h3><blockquote><p>在后端项目同级目录下，编写Dockerfile文件</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /tmp</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> shuzhi_boot.jar shuzhi_boot.jar</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8081</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/shuzhi_boot.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><h3 id="124生成镜像"><a class="markdownIt-Anchor" href="#124生成镜像"></a> 1.2.4生成镜像</h3><blockquote><p>生成镜像</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t shuzhi_boot .</span><br></pre></td></tr></table></figure><blockquote><p>查看镜像</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images | grep shuzhi_boot</span><br></pre></td></tr></table></figure><h3 id="125运行容器"><a class="markdownIt-Anchor" href="#125运行容器"></a> 1.2.5运行容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8081:8081 --name shuzhi_boot-8081 shuzhi_boot</span><br></pre></td></tr></table></figure><h2 id="13补充"><a class="markdownIt-Anchor" href="#13补充"></a> 1.3补充</h2><blockquote><p>-v参数：宿机地址映射到主机地址</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 --name nginx-easypan -v /mydata/nginx/dist:/usr/share/nginx/html --restart=always nginx</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="部署" scheme="https://www.haipeng-lin.cn/categories/%E9%83%A8%E7%BD%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>MiniDB——数据管理器</title>
    <link href="https://www.haipeng-lin.cn/posts/c9808524.html"/>
    <id>https://www.haipeng-lin.cn/posts/c9808524.html</id>
    <published>2024-09-05T00:28:24.000Z</published>
    <updated>2024-09-19T08:57:13.491Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3数据管理器引用计数缓存框架"><a class="markdownIt-Anchor" href="#3数据管理器引用计数缓存框架"></a> 3.数据管理器——引用计数缓存框架</h1><h2 id="31设计思路"><a class="markdownIt-Anchor" href="#31设计思路"></a> 3.1设计思路</h2><p>​当某个资源被使用到时，就加入到缓存，如果有其他的模块也在访问这个缓存，那么计数就加1，只有当所有的模块都释放了该资源时，将其从缓存中释放</p><blockquote><p>问题：为什么不使用LRU？</p><ul><li>因为MiniDB涉及到了回源操作<ul><li><strong>回源操作</strong> 指的是将资源刷回数据源，举例：某个时刻缓存满了，缓存驱逐了一个资源，这时上层模块想要将某个资源强制刷回数据源，<mark>这个资源恰好是刚刚被驱逐的资源</mark>。那么上层模块就发现，这个数据在缓存里消失了</li><li>LRU 策略中，资源驱逐不可控，上层模块无法感知。而引用计数策略正好解决了这个问题，只有上层模块主动释放引用，缓存在确保没有模块在使用这个资源了，才会去驱逐资源</li></ul></li></ul></blockquote><h2 id="32abstractcache抽象缓存接口"><a class="markdownIt-Anchor" href="#32abstractcache抽象缓存接口"></a> 3.2AbstractCache抽象缓存接口</h2><blockquote><p>com.peng.minidb.backend.common.AbstractCache类</p></blockquote><h3 id="321缓存结构"><a class="markdownIt-Anchor" href="#321缓存结构"></a> 3.2.1缓存结构</h3><ul><li>cacheMap&lt;key,value&gt;：缓存实际存储的数据</li><li>referecesMap&lt;key,count&gt;：存储每个资源的引用计数</li><li>getting&lt;key,value&gt;：记录哪些资源当前正在从数据源中获取，key是资源的唯一标识符，value是布尔值，表示该资源是否正在被获取中（多线程环境下可能一个资源被同时获取，而获取的过程较长（如从文件中读取），防止多线程并发问题而引入该map）</li><li>maxResources：缓存的最大资源数，防止内存溢出</li><li>count：当前缓存的资源数</li><li>lock：锁（整个数据缓存的锁）</li></ul><h3 id="322抽象方法"><a class="markdownIt-Anchor" href="#322抽象方法"></a> 3.2.2抽象方法</h3><blockquote><p>两个方法均由PageCacheImpl（页面缓存）、DataManagerImpl（数据管理）、VersionManagerImpl（版本管理）实现类实现，具体逻辑具体实现</p></blockquote><ul><li>getForCache(key)：当资源不在缓存时的获取行为</li><li>releaseForCache(key)：当资源被驱逐时的写回行为</li></ul><h3 id="323重要方法"><a class="markdownIt-Anchor" href="#323重要方法"></a> 3.2.3重要方法</h3><ul><li>get(key)：<ul><li>作用：从缓存获取指定key的资源过程：</li><li>首先，先获取抽象缓存结构的锁，再判断<mark>是否有其他线程正在从数据源中获取该资源</mark><ul><li>有，解锁，睡眠一秒并continue</li><li>没有，<mark>判断资源是否存在于缓存中</mark><ul><li>存在，将资源的引用数+1，解锁，直接获取资源并返回</li><li>不存在，判断资源总数是否超过最大值，没超过，则在<code>getting</code>中标记true，然后该线程从数据源中获取资源，获取到之后标记false，解锁</li></ul></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> T <span class="title function_">get</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">// 1、请求的资源正在被其他线程获取</span></span><br><span class="line">        <span class="keyword">if</span>(getting.containsKey(key)) &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 2、判断资源是否存在于缓存中</span></span><br><span class="line">        <span class="keyword">if</span>(cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 2.1、资源在缓存中，直接返回</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">            references.put(key, references.get(key) + <span class="number">1</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、尝试获取该资源</span></span><br><span class="line">        <span class="keyword">if</span>(maxResource &gt; <span class="number">0</span> &amp;&amp; count == maxResource) &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">throw</span> Error.CacheFullException;</span><br><span class="line">        &#125;</span><br><span class="line">        count ++;</span><br><span class="line">        getting.put(key, <span class="literal">true</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        obj = getForCache(key);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        count --;</span><br><span class="line">        getting.remove(key);</span><br><span class="line">        lock.unlock();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock.lock();</span><br><span class="line">    getting.remove(key);</span><br><span class="line">    cache.put(key, obj);</span><br><span class="line">    references.put(key, <span class="number">1</span>);</span><br><span class="line">    lock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>release(key)：<ul><li>作用：释放缓存</li><li>释放缓存时，将对应的引用计数-1，如果已经减到0了就回源，然后删除缓存中相关的各种数据</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 强行释放一个缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(<span class="type">long</span> key)</span> &#123;</span><br><span class="line">    lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ref</span> <span class="operator">=</span> references.get(key) - <span class="number">1</span>; <span class="comment">// 获取资源的引用计数并减一</span></span><br><span class="line">        <span class="keyword">if</span> (ref == <span class="number">0</span>) &#123; <span class="comment">// 如果引用计数为0</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> cache.get(key); <span class="comment">// 从缓存中获取资源</span></span><br><span class="line">            releaseForCache(obj); <span class="comment">// 处理资源的释放</span></span><br><span class="line">            references.remove(key); <span class="comment">// 从引用计数的映射中移除资源</span></span><br><span class="line">            cache.remove(key); <span class="comment">// 从缓存中移除资源</span></span><br><span class="line">            count--; <span class="comment">// 将缓存中的资源计数减一</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果引用计数不为0</span></span><br><span class="line">            references.put(key, ref); <span class="comment">// 更新资源的引用计数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>close()：<ul><li>作用：关闭缓存</li><li>注意，在关闭缓存结构时，所有的缓存资源要强行回源</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭缓存，写回所有资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取所有资源key</span></span><br><span class="line">        Set&lt;Long&gt; keys = cache.keySet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> key : keys) &#123;</span><br><span class="line">            <span class="comment">//获取缓存</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">            <span class="comment">//释放缓存</span></span><br><span class="line">            releaseForCache(obj);</span><br><span class="line">            <span class="comment">//引用计数移除缓存</span></span><br><span class="line">            references.remove(key);</span><br><span class="line">            <span class="comment">//实际缓存移除缓存</span></span><br><span class="line">            cache.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4数据管理器数据页缓存"><a class="markdownIt-Anchor" href="#4数据管理器数据页缓存"></a> 4.数据管理器——数据页缓存</h1><h2 id="41设计思路"><a class="markdownIt-Anchor" href="#41设计思路"></a> 4.1设计思路</h2><p>​数据页缓存：将页面数据保存在内存中，减小频繁的磁盘I/O操作，将默认数据页的大小定为8KB</p><h2 id="42page类"><a class="markdownIt-Anchor" href="#42page类"></a> 4.2Page类</h2><blockquote><p>com.peng.minidb.backend.dm.page.Page类</p><p>com.peng.minidb.backend.dm.page.PageImpl类</p></blockquote><ul><li>定义：页面(Page)是数据库中存储数据的基本单元</li><li>结构：<ul><li>pageNumber：页号</li><li>data：字节数据</li><li>dirty：是否脏页面数据；脏页面在释放页面缓存时需要被写回到磁盘</li><li>lock：锁，用于保证页面操作的线程安全</li><li>PageCache：引用页面缓存</li></ul></li></ul><h2 id="43pagecache页面缓存接口"><a class="markdownIt-Anchor" href="#43pagecache页面缓存接口"></a> 4.3PageCache页面缓存接口</h2><blockquote><p>com.peng.minidb.backend.dm.pageCache.PageCache</p></blockquote><p>​ 定义了页面缓存的接口，包括新建页面、获取页面、释放页面、关闭缓存、根据最大页号截断缓存、获取当前页面数量以及刷新页面等方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PageCache</span> &#123;</span><br><span class="line">    <span class="comment">// 新建页面</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">newPage</span><span class="params">(<span class="type">byte</span>[] initData)</span>;</span><br><span class="line">    Page <span class="title function_">getPage</span><span class="params">(<span class="type">int</span> pgno)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(Page page)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">truncateByBgno</span><span class="params">(<span class="type">int</span> maxPgno)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getPageNumber</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">flushPage</span><span class="params">(Page pg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="44pagecacheimpl页面缓存实现类"><a class="markdownIt-Anchor" href="#44pagecacheimpl页面缓存实现类"></a> 4.4PageCacheImpl页面缓存实现类</h2><h3 id="441继承抽象缓存框架"><a class="markdownIt-Anchor" href="#441继承抽象缓存框架"></a> 4.4.1继承抽象缓存框架</h3><p>实现以下两个方法</p><ul><li><code>getForCache()</code>：用于从文件中读取页面数据，并将其包装成 <code>Page</code> 对象。</li><li><code>releaseForCache()</code>：用于在驱逐页面时根据页面是否为脏页面，决定是否将其写回文件系统。</li></ul><h4 id="1getforcache"><a class="markdownIt-Anchor" href="#1getforcache"></a> （1）getForCache()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据pageNumber从数据库文件中读取页数据，并包裹成Page</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Page <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 将key转换为页码</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> (<span class="type">int</span>) key;</span><br><span class="line">    <span class="comment">// 计算页码对应的偏移量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> PageCacheImpl.pageOffset(pgno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个大小为PAGE_SIZE的ByteBuffer</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(PAGE_SIZE);</span><br><span class="line">    <span class="comment">// 锁定文件，确保线程安全</span></span><br><span class="line">    fileLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 设置文件通道的位置为计算出的偏移量</span></span><br><span class="line">        fc.position(offset);</span><br><span class="line">        <span class="comment">// 从文件通道读取数据到ByteBuffer</span></span><br><span class="line">        fc.read(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 如果发生异常，调用Panic.panic方法处理</span></span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无论是否发生异常，都要解锁</span></span><br><span class="line">    fileLock.unlock();</span><br><span class="line">    <span class="comment">// 使用读取到的数据、页码和当前对象创建一个新的PageImpl对象并返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageImpl</span>(pgno, buf.array(), <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PageImpl</span><span class="params">(<span class="type">int</span> pageNumber, <span class="type">byte</span>[] data, PageCache pc)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.pageNumber = pageNumber; <span class="comment">// 设置页面的页号</span></span><br><span class="line">    <span class="built_in">this</span>.data = data; <span class="comment">// 设置页面实际包含的字节数据</span></span><br><span class="line">    <span class="built_in">this</span>.pc = pc; <span class="comment">// 设置页面缓存</span></span><br><span class="line">    lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">// 初始化一个新的可重入锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2releaseforcache"><a class="markdownIt-Anchor" href="#2releaseforcache"></a> （2）releaseForCache</h4><p>​当页面不再需要时，<code>releaseForCache()</code> 方法会<mark>检查页面是否是脏页面</mark>，如果页面被标记为脏页面（即其数据已被修改但尚未写回磁盘），则需要通过 <code>flush()</code> 方法将其内容写入磁盘。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pg.isDirty()) &#123;</span><br><span class="line">        flush(pg);</span><br><span class="line">        pg.setDirty(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> pg.getPageNumber(); <span class="comment">// 获取Page的页码</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> pageOffset(pgno); <span class="comment">// 计算Page在文件中的偏移量</span></span><br><span class="line"></span><br><span class="line">    fileLock.lock(); <span class="comment">// 加锁，确保线程安全</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(pg.getData()); <span class="comment">// 将Page的数据包装成ByteBuffer</span></span><br><span class="line">        fc.position(offset); <span class="comment">// 设置文件通道的位置</span></span><br><span class="line">        fc.write(buf); <span class="comment">// 将数据写入到文件中</span></span><br><span class="line">        fc.force(<span class="literal">false</span>); <span class="comment">// 强制将数据从操作系统的缓存刷新到磁盘</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e); <span class="comment">// 如果发生异常，调用Panic.panic方法处理</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fileLock.unlock(); <span class="comment">// 最后，无论是否发生异常，都要解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="442新建页面"><a class="markdownIt-Anchor" href="#442新建页面"></a> 4.4.2新建页面</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">newPage</span><span class="params">(<span class="type">byte</span>[] initData)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> pageNumbers.incrementAndGet();</span><br><span class="line">    <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageImpl</span>(pgno, initData, <span class="literal">null</span>);</span><br><span class="line">    flush(pg);  <span class="comment">// 新建的页面需要立刻写回</span></span><br><span class="line">    <span class="keyword">return</span> pgno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="443数据恢复操作"><a class="markdownIt-Anchor" href="#443数据恢复操作"></a> 4.4.3数据恢复操作</h3><p>​数据恢复操作是为了确保在系统崩溃后，能够从日志或其他持久化存储中恢复数据。<code>recoverInsert()</code> 和 <code>recoverUpdate()</code> 方法用于在数据库崩溃后重新插入数据和恢复修改</p><blockquote><p><code>recoverInsert()</code>：将数据插入到指定的偏移位置，并更新空闲空间的偏移量</p><p><code>recoverUpdate()</code>：在指定的偏移位置直接更新数据，而不更新空闲空间的偏移量</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将raw插入pg中的offset位置，并将pg的offset设置为较大的offset</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recoverInsert</span><span class="params">(Page pg, <span class="type">byte</span>[] raw, <span class="type">short</span> offset)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>); <span class="comment">// 将pg的dirty标志设置为true，表示pg的数据已经被修改</span></span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length); <span class="comment">// 将raw的数据复制到pg的数据中的offset位置</span></span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> <span class="variable">rawFSO</span> <span class="operator">=</span> getFSO(pg.getData()); <span class="comment">// 获取pg的当前空闲空间偏移量</span></span><br><span class="line">    <span class="keyword">if</span> (rawFSO &lt; offset + raw.length) &#123; <span class="comment">// 如果当前的空闲空间偏移量小于offset + raw.length</span></span><br><span class="line">        setFSO(pg.getData(), (<span class="type">short</span>) (offset + raw.length)); <span class="comment">// 将pg的空闲空间偏移量设置为offset + raw.length</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将raw插入pg中的offset位置，不更新update</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recoverUpdate</span><span class="params">(Page pg, <span class="type">byte</span>[] raw, <span class="type">short</span> offset)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>); <span class="comment">// 将pg的dirty标志设置为true，表示pg的数据已经被修改</span></span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length); <span class="comment">// 将raw的数据复制到pg的数据中的offset位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5数据管理器数据页管理"><a class="markdownIt-Anchor" href="#5数据管理器数据页管理"></a> 5.数据管理器——数据页管理</h1><h2 id="51设计思路"><a class="markdownIt-Anchor" href="#51设计思路"></a> 5.1设计思路</h2><p>在MiniDB中，页面管理的设计目标之一是确保系统在启动时能够正确恢复，并且在运行过程中有效管理页面的空闲空间</p><h2 id="52第一页"><a class="markdownIt-Anchor" href="#52第一页"></a> 5.2第一页</h2><h3 id="521定义"><a class="markdownIt-Anchor" href="#521定义"></a> 5.2.1定义</h3><p>​数据文件的第一页<mark>用于数据库启动检查</mark>，是否需要执行数据恢复流程</p><p>​在每次==<strong>启动数据库</strong><mark>的时候，生成一段8字节的随机字节，<mark>存储在100-107字节处</mark>，</mark><strong>正常关闭时</strong>==，这串字节会被复制到第一页的 <mark>108~115</mark> 字节。每次数据库启动时，系统会比较这两处的字节，如果相同，则表明上次关闭是正常的；如果不同，则意味着需要执行数据恢复流程</p><h3 id="522相关函数"><a class="markdownIt-Anchor" href="#522相关函数"></a> 5.2.2相关函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置启动时的校验字节</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcOpen</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    setVcOpen(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcOpen</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="comment">// 生成并设置随机校验字节</span></span><br><span class="line">    System.arraycopy(RandomUtil.randomBytes(LEN_VC), <span class="number">0</span>, raw, OF_VC, LEN_VC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置关闭时的校验字节</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcClose</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    setVcClose(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcClose</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="comment">// 将启动时的校验字节复制到关闭时的存储位置</span></span><br><span class="line">    System.arraycopy(raw, OF_VC, raw, OF_VC + LEN_VC, LEN_VC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验字节是否一致</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkVc</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> checkVc(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkVc</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="comment">// 比较启动和关闭时的校验字节</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.equals(Arrays.copyOfRange(raw, OF_VC, OF_VC + LEN_VC),</span><br><span class="line">                         Arrays.copyOfRange(raw, OF_VC + LEN_VC, OF_VC + <span class="number">2</span> * LEN_VC));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="53普通页"><a class="markdownIt-Anchor" href="#53普通页"></a> 5.3普通页</h2><p>​普通页是用于<mark>实际存储数据的页面</mark>。在MiniDB中，每个普通页以一个2字节的无符号数开头，表示<mark>该页的空闲位置的偏移量</mark>。</p><p>​由于页面的最大容量为8K，因此2字节的偏移量足以表达这一页的所有可能偏移</p><h3 id="531空闲空间偏移量fso的管理"><a class="markdownIt-Anchor" href="#531空闲空间偏移量fso的管理"></a> 5.3.1空闲空间偏移量（FSO）的管理</h3><p>​普通页的管理核心在于管理空闲空间偏移量（FSO）。FSO指示了页面中第一个可用的空闲字节的位置。每次插入数据时，FSO会更新为新插入数据的末尾位置，以便后续插入操作可以准确地找到空闲位置。 以下是FSO管理的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置空闲空间偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFSO</span><span class="params">(<span class="type">byte</span>[] raw, <span class="type">short</span> ofData)</span> &#123;</span><br><span class="line">    System.arraycopy(Parser.short2Byte(ofData), <span class="number">0</span>, raw, OF_FREE, OF_DATA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取页面的空闲空间偏移量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">getFSO</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getFSO(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">getFSO</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Parser.parseShort(Arrays.copyOfRange(raw, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取页面的空闲空间大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getFreeSpace</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PageCache.PAGE_SIZE - (<span class="type">int</span>) getFSO(pg.getData());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="532数据插入"><a class="markdownIt-Anchor" href="#532数据插入"></a> 5.3.2数据插入</h3><p>​在普通页中插入数据时，系统首先<mark>根据当前的FSO确定插入位置</mark>，然后将数据写入该位置，最后更新FSO。插入完成后，页面被标记为脏页面，以便在需要时将其写回磁盘。 以下是插入操作的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数据插入页面，返回插入位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">insert</span><span class="params">(Page pg, <span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>); <span class="comment">// 标记页面为脏页面</span></span><br><span class="line">    <span class="type">short</span> <span class="variable">offset</span> <span class="operator">=</span> getFSO(pg.getData()); <span class="comment">// 获取当前空闲空间偏移量</span></span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length); <span class="comment">// 将数据写入页面</span></span><br><span class="line">    setFSO(pg.getData(), (<span class="type">short</span>) (offset + raw.length)); <span class="comment">// 更新空闲空间偏移量</span></span><br><span class="line">    <span class="keyword">return</span> offset; <span class="comment">// 返回数据插入位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="54总结"><a class="markdownIt-Anchor" href="#54总结"></a> 5.4总结</h2><p>​MiniDB可以有效地管理页面的空闲空间，并确保数据的一致性与完整性。第一页的校验机制确保了数据库在启动时能够检测并处理未正常关闭的情况，而普通页的FSO管理则确保了数据插入和存储的高效与准确</p><h1 id="6数据管理器日志管理"><a class="markdownIt-Anchor" href="#6数据管理器日志管理"></a> 6.数据管理器——日志管理</h1><h2 id="61设计思路"><a class="markdownIt-Anchor" href="#61设计思路"></a> 6.1设计思路</h2><p>​DM 层对底层数据进行操作时，都会<mark>将一条日志记录到磁盘上</mark>。在数据库崩溃后，再次启动时，系统可以根据这些日志内容恢复数据文件，从而确保数据的完整性</p><h2 id="62日志格式"><a class="markdownIt-Anchor" href="#62日志格式"></a> 6.2日志格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[XChecksum][log1][log2][BadTail]</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>XChecksum</code>：四字节的整数，是对后续所有日志计算的校验和</li><li><code>Log1 ~ LogN</code>：常规的日志数据</li><li><code>BadTail</code>：数据库崩溃时尚未写完的日志数据（可能不存在）</li></ul></blockquote><p>每条日志结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Size][Checksum][Data]</span><br></pre></td></tr></table></figure><h2 id="63日志文件的校验和"><a class="markdownIt-Anchor" href="#63日志文件的校验和"></a> 6.3日志文件的校验和</h2><h2 id="64日志文件的创建与初始化"><a class="markdownIt-Anchor" href="#64日志文件的创建与初始化"></a> 6.4日志文件的创建与初始化</h2><h2 id="65minidb恢复策略详解"><a class="markdownIt-Anchor" href="#65minidb恢复策略详解"></a> 6.5MiniDB恢复策略详解</h2><h1 id="7数据管理器页面索引"><a class="markdownIt-Anchor" href="#7数据管理器页面索引"></a> 7.数据管理器——页面索引</h1><h1 id="8数据管理器dm实现"><a class="markdownIt-Anchor" href="#8数据管理器dm实现"></a> 8.数据管理器——DM实现</h1><p>​数据管理器是MiniDB中的数据抽象层，负责存储和管理具体的数据内容，并为上层模块提供访问接口：</p><ul><li><strong><mark>数据存储和访问</mark></strong>：<code>DataItem</code> 存储了数据的具体内容，以及相关的元数据信息如数据大小和有效标志等</li><li><strong><mark>数据修改与事务管理</mark></strong>：<code>DataItem</code> 支持数据的修改操作，并在修改操作前后执行保存原始数据、记录日志等流程，以确保数据修改的原子性和一致性</li><li><strong><mark>缓存管理</mark></strong>：<code>DataItem</code> 对象由底层 <code>DataManager</code> 缓存管理，使用 <code>release()</code> 方法可以释放缓存中的 <code>DataItem</code> 对象，以便回收内存资源</li></ul><h2 id="81dataitem数据结构"><a class="markdownIt-Anchor" href="#81dataitem数据结构"></a> 8.1DataItem数据结构</h2><h3 id="811数据结构"><a class="markdownIt-Anchor" href="#811数据结构"></a> 8.1.1数据结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ValidFlag] [DataSize] [Data]</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>ValidFlag</strong>：1 字节，表示该 <code>DataItem</code> 是否有效。删除 <code>DataItem</code> 只需将其有效位设置为 0</li><li><strong>DataSize</strong>：2 字节，表示 <code>Data</code> 部分的长度</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataItemImpl</span> <span class="keyword">implements</span> <span class="title class_">DataItem</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SubArray raw; <span class="comment">// 原始数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] oldRaw; <span class="comment">// 旧的原始数据</span></span><br><span class="line">    <span class="keyword">private</span> DataManagerImpl dm; <span class="comment">// 数据管理器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> uid; <span class="comment">// 唯一标识符</span></span><br><span class="line">    <span class="keyword">private</span> Page pg; <span class="comment">// 页面对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="812uid的生成与解析"><a class="markdownIt-Anchor" href="#812uid的生成与解析"></a> 8.1.2uid的生成与解析</h3><p><code>DataItem</code> 在 <code>DataManager</code> 中的存储和管理是通过一个唯一标识符 <code>Uid</code> 来实现的。这个 <code>Uid</code> 是由页面编号 (<code>pgno</code>) 和页面内偏移量 (<code>offset</code>) 组成的一个 8 字节无符号整数，其中页号和偏移量各占 4 字节。这里以<code>pgno = 2 和 offset = 0</code>来演示生成和解析 <code>Uid</code> 的详细过程。</p><h2 id="82dm关键方法"><a class="markdownIt-Anchor" href="#82dm关键方法"></a> 8.2DM关键方法</h2><p>**数据访问：**data()：返回 <code>DataItem</code> 中的数据部分，不进行数据拷贝，直接返回原始数据的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SubArray <span class="title function_">data</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SubArray</span>(raw.raw, raw.start + OF_DATA, raw.end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数据修改前准备</strong>：before()：在修改数据项之前调用，锁定数据项并保存原始数据，以支持事务回滚</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">    wLock.lock();</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    System.arraycopy(raw.raw, raw.start, oldRaw, <span class="number">0</span>, oldRaw.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回滚修改：在需要撤销修改时调用，恢复原始数据并解锁数据项</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unBefore</span><span class="params">()</span> &#123;</span><br><span class="line">    System.arraycopy(oldRaw, <span class="number">0</span>, raw.raw, raw.start, oldRaw.length);</span><br><span class="line">    wLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="83dm核心方法"><a class="markdownIt-Anchor" href="#83dm核心方法"></a> 8.3DM核心方法</h2><h3 id="831读取数据"><a class="markdownIt-Anchor" href="#831读取数据"></a> 8.3.1读取数据</h3><p>​read()：根据 <code>Uid</code> 从缓存中获取 <code>DataItem</code>，并校验其有效性</p><p>​<code>DataItem</code> 的 <code>Uid</code> 是由页号和页内偏移组成的一个 8 字节无符号整数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> DataItem <span class="title function_">read</span><span class="params">(<span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//从缓存页面中读取到DataItemImpl</span></span><br><span class="line">    <span class="type">DataItemImpl</span> <span class="variable">di</span> <span class="operator">=</span> (DataItemImpl) <span class="built_in">super</span>.get(uid); <span class="comment">// 若缓存中不存在则调用 getForCache() 方法</span></span><br><span class="line">    <span class="comment">//校验di是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (!di.isValid()) &#123;</span><br><span class="line">        <span class="comment">// 无效释放缓存</span></span><br><span class="line">        di.release();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> di;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="832插入数据"><a class="markdownIt-Anchor" href="#832插入数据"></a> 8.3.2插入数据</h3><p>​insert()：在 <code>PageIndex</code> 中选择一个合适的页面进行插入操作，记录插入日志，并返回插入位置的偏移。</p><p>​插入的位置和页面信息都是通过页号和偏移量进行管理的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">insert</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 将输入的数据包装成DataItem的原始格式</span></span><br><span class="line">    <span class="type">byte</span>[] raw = DataItem.wrapDataItemRaw(data);</span><br><span class="line">    <span class="comment">// 如果数据项的大小超过了页面的最大空闲空间，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (raw.length &gt; PageX.MAX_FREE_SPACE) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Error.DataTooLargeException;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个页面信息对象</span></span><br><span class="line">    <span class="type">PageInfo</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 尝试5次找到一个可以容纳新数据项的页面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 从页面索引中选择一个可以容纳新数据项的页面</span></span><br><span class="line">        pi = pIndex.select(raw.length);</span><br><span class="line">        <span class="comment">// 如果找到了合适的页面，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (pi != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有找到合适的页面，创建一个新的页面，并将其添加到页面索引中</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">newPgno</span> <span class="operator">=</span> pc.newPage(PageX.initRaw());</span><br><span class="line">            pIndex.add(newPgno, PageX.MAX_FREE_SPACE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果还是没有找到合适的页面，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (pi == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Error.DatabaseBusyException;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个页面对象</span></span><br><span class="line">    <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 初始化空闲空间大小为0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">freeSpace</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取页面信息对象中的页面</span></span><br><span class="line">        pg = pc.getPage(pi.pgno);</span><br><span class="line">        <span class="comment">// 生成插入日志</span></span><br><span class="line">        <span class="type">byte</span>[] log = Recover.insertLog(xid, pg, raw);</span><br><span class="line">        <span class="comment">// 将日志写入日志文件</span></span><br><span class="line">        logger.log(log);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在页面中插入新的数据项，并获取其在页面中的偏移量</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">offset</span> <span class="operator">=</span> PageX.insert(pg, raw);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放页面</span></span><br><span class="line">        pg.release();</span><br><span class="line">        <span class="comment">// 返回新插入的数据项的唯一标识符</span></span><br><span class="line">        <span class="keyword">return</span> Types.addressToUid(pi.pgno, offset);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 将页面重新添加到页面索引中</span></span><br><span class="line">        <span class="keyword">if</span> (pg != <span class="literal">null</span>) &#123;</span><br><span class="line">            pIndex.add(pi.pgno, PageX.getFreeSpace(pg));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pIndex.add(pi.pgno, freeSpace);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  返回一个完整的 DataItem 结构数据</span></span><br><span class="line"><span class="comment"> *  dataItem 结构如下：</span></span><br><span class="line"><span class="comment"> *  [ValidFlag] [DataSize] [Data]</span></span><br><span class="line"><span class="comment"> *  ValidFlag 1字节，0为合法，1为非法</span></span><br><span class="line"><span class="comment"> *  DataSize  2字节，标识Data的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> raw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] wrapDataItemRaw(<span class="type">byte</span>[] raw) &#123;</span><br><span class="line">    <span class="type">byte</span>[] valid = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span>]; <span class="comment">//证明此时为非法数据</span></span><br><span class="line">    <span class="type">byte</span>[] size = Parser.short2Byte((<span class="type">short</span>)raw.length); <span class="comment">//计算数据字节大小</span></span><br><span class="line">    <span class="keyword">return</span> Bytes.concat(valid, size, raw); <span class="comment">//拼接DataItem 结构数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据给定的空间大小选择一个 PageInfo 对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> spaceSize 需要的空间大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 一个 PageInfo 对象，其空闲空间大于或等于给定的空间大小。如果没有找到合适的 PageInfo，返回 null。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> PageInfo <span class="title function_">select</span><span class="params">(<span class="type">int</span> spaceSize)</span> &#123;</span><br><span class="line">lock.lock(); <span class="comment">// 获取锁，确保线程安全</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> spaceSize / THRESHOLD; <span class="comment">// 计算需要的空间大小对应的区间编号</span></span><br><span class="line">    <span class="comment">// 此处+1主要为了向上取整</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1、假需要存储的字节大小为5168，此时计算出来的区间号是25，但是25*204=5100显然是不满足条件的</span></span><br><span class="line"><span class="comment">            2、此时向上取整找到 26，而26*204=5304，是满足插入条件的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">if</span> (number &lt; INTERVALS_NO) number++; <span class="comment">// 如果计算出的区间编号小于总的区间数，编号加一</span></span><br><span class="line">    <span class="keyword">while</span> (number &lt;= INTERVALS_NO) &#123; <span class="comment">// 从计算出的区间编号开始，向上寻找合适的 PageInfo</span></span><br><span class="line">        <span class="keyword">if</span> (lists[number].size() == <span class="number">0</span>) &#123; <span class="comment">// 如果当前区间没有 PageInfo，继续查找下一个区间</span></span><br><span class="line">            number++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[number].remove(<span class="number">0</span>); <span class="comment">// 如果当前区间有 PageInfo，返回第一个 PageInfo，并从列表中移除</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果没有找到合适的 PageInfo，返回 null</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个静态方法，用于创建插入日志</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] insertLog(<span class="type">long</span> xid, Page pg, <span class="type">byte</span>[] raw) &#123;</span><br><span class="line">    <span class="comment">// 创建一个表示日志类型的字节数组，并设置其值为LOG_TYPE_INSERT</span></span><br><span class="line">    <span class="type">byte</span>[] logTypeRaw = &#123;LOG_TYPE_INSERT&#125;;</span><br><span class="line">    <span class="comment">// 将事务ID转换为字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] xidRaw = Parser.long2Byte(xid);</span><br><span class="line">    <span class="comment">// 将页面编号转换为字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] pgnoRaw = Parser.int2Byte(pg.getPageNumber());</span><br><span class="line">    <span class="comment">// 获取页面的第一个空闲空间的偏移量，并将其转换为字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] offsetRaw = Parser.short2Byte(PageX.getFSO(pg));</span><br><span class="line">    <span class="comment">// 将所有字节数组连接在一起，形成一个完整的插入日志，并返回这个日志</span></span><br><span class="line">    <span class="keyword">return</span> Bytes.concat(logTypeRaw, xidRaw, pgnoRaw, offsetRaw, raw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将raw插入pg中，返回插入位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">insert</span><span class="params">(Page pg, <span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>); <span class="comment">// 将pg的dirty标志设置为true，表示pg的数据已经被修改</span></span><br><span class="line">    <span class="type">short</span> <span class="variable">offset</span> <span class="operator">=</span> getFSO(pg.getData()); <span class="comment">// 获取pg的空闲空间偏移量</span></span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length); <span class="comment">// 将raw的数据复制到pg的数据中的offset位置</span></span><br><span class="line">    setFSO(pg.getData(), (<span class="type">short</span>) (offset + raw.length)); <span class="comment">// 更新pg的空闲空间偏移量</span></span><br><span class="line">    <span class="keyword">return</span> offset; <span class="comment">// 返回插入位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="833关闭dm"><a class="markdownIt-Anchor" href="#833关闭dm"></a> 8.3.3关闭DM</h3><p>​正常关闭时，执行缓存和日志的关闭流程，并设置第一页的字节校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.close();</span><br><span class="line">    logger.close();</span><br><span class="line"></span><br><span class="line">    PageOne.setVcClose(pageOne);</span><br><span class="line">    pageOne.release();</span><br><span class="line">    pc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="【MiniDB】" scheme="https://www.haipeng-lin.cn/categories/%E3%80%90MiniDB%E3%80%91/"/>
    
    
  </entry>
  
  <entry>
    <title>MiniDB——事务管理器</title>
    <link href="https://www.haipeng-lin.cn/posts/2a5b6ce0.html"/>
    <id>https://www.haipeng-lin.cn/posts/2a5b6ce0.html</id>
    <published>2024-09-05T00:27:51.000Z</published>
    <updated>2024-09-19T08:57:11.071Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="2事务管理器"><a class="markdownIt-Anchor" href="#2事务管理器"></a> 2.事务管理器</h1><h2 id="21设计思路"><a class="markdownIt-Anchor" href="#21设计思路"></a> 2.1设计思路</h2><p>事务管理器通过维护 .xid 文件来维护事务的状态的，并提供接口供其他模块来查询某个事务的状态</p><p>.xid文件包含了所有事务，每个事务都有唯一的事务ID，即XID</p><h2 id="22xid文件"><a class="markdownIt-Anchor" href="#22xid文件"></a> 2.2xid文件</h2><h3 id="221xid定义"><a class="markdownIt-Anchor" href="#221xid定义"></a> 2.2.1XID定义</h3><ul><li>每个事务都有一个唯一的事务标识符 XID，从 1 开始递增</li><li><code>XID 0</code>被特殊定义为超级事务（Super Transaction），用于表示在没有申请事务的情况下进行的操作，其状态永远是<code>committed</code></li></ul><h3 id="222事务状态"><a class="markdownIt-Anchor" href="#222事务状态"></a> 2.2.2事务状态</h3><ul><li><code>active</code>：正在进行，尚未结束。</li><li><code>committed</code>：已提交。</li><li><code>aborted</code>：已撤销或回滚</li></ul><h3 id="223文件结构"><a class="markdownIt-Anchor" href="#223文件结构"></a> 2.2.3文件结构</h3><ol><li>每个事务在 .xid文件中分配一个字节的空间，用于保存其状态</li><li>.xid文件的头部保存一个 8 字节的数字，用于记录这个 .xid文件管理的事务的个数</li><li>事务 XID 在文件中的状态存储在 <code>(XID-1) + 8</code> 字节的位置处。例如，事务2在文件中的状态存储在（2-1）+8=9字节的位置</li></ol><h2 id="23transactionmanager接口定义"><a class="markdownIt-Anchor" href="#23transactionmanager接口定义"></a> 2.3TransactionManager接口定义</h2><blockquote><p>TM提供接口，供上层模块调用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">begin</span><span class="params">()</span>;                       <span class="comment">// 开启一个新事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span>;              <span class="comment">// 提交一个事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">long</span> xid)</span>;               <span class="comment">// 取消一个事务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">(<span class="type">long</span> xid)</span>;         <span class="comment">// 查询一个事务的状态是否是正在进行的状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCommitted</span><span class="params">(<span class="type">long</span> xid)</span>;      <span class="comment">// 查询一个事务的状态是否是已提交</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAborted</span><span class="params">(<span class="type">long</span> xid)</span>;        <span class="comment">// 查询一个事务的状态是否是已取消</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;                       <span class="comment">// 关闭TM</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="24tm模块的实现"><a class="markdownIt-Anchor" href="#24tm模块的实现"></a> 2.4TM模块的实现</h2><h3 id="241常量定义"><a class="markdownIt-Anchor" href="#241常量定义"></a> 2.4.1常量定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionManagerImpl</span> <span class="keyword">implements</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line">    <span class="comment">// XID文件头长度</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LEN_XID_HEADER_LENGTH</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 每个事务的占用长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">XID_FIELD_SIZE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务的三种状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_ACTIVE</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_COMMITTED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_ABORTED</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超级事务，永远为commited状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SUPER_XID</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// XID文件后缀</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">XID_SUFFIX</span> <span class="operator">=</span> <span class="string">&quot;.xid&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="242xid文件的校验与读取"><a class="markdownIt-Anchor" href="#242xid文件的校验与读取"></a> 2.4.2xid文件的校验与读取</h3><h4 id="1校验xid文件"><a class="markdownIt-Anchor" href="#1校验xid文件"></a> （1）校验xid文件</h4><ol><li>在创建 <code>TransactionManager</code>的构造函数后，首先需要对 XID 文件进行校验，以确保其合法性。</li><li>校验过程相对简单，通过读取文件头的 8 字节数字推算出文件的理论长度，并将其与实际长度进行对比。</li><li>如果两者不一致，则认为该 XID 文件存在问题，不符合规范。对于校验未通过的情况，系统会立即触发 panic 方法，强制终止运行。</li><li>在一些关键基础模块中，一旦发生无法恢复的错误，系统会直接停机，以确保整体系统的安全性和稳定性。</li></ol><h4 id="2开始一个事务"><a class="markdownIt-Anchor" href="#2开始一个事务"></a> （2）开始一个事务</h4><blockquote><p>开始一个事务：为事务分配一个编号，并标记为“进行中”，保存到.xid文件</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">begin</span><span class="params">()</span> &#123;</span><br><span class="line">    counterLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 为事务分配一个编号</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> xidCounter + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 标记为“进行中”</span></span><br><span class="line">        updateXID(xid, FIELD_TRAN_ACTIVE);</span><br><span class="line">        <span class="comment">// 将事务信息 保存到.xid文件</span></span><br><span class="line">        incrXIDCounter();</span><br><span class="line">        <span class="keyword">return</span> xid;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        counterLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3更新事务状态"><a class="markdownIt-Anchor" href="#3更新事务状态"></a> （3）更新事务状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新xid事务的状态为status</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateXID</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span> status)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取事务xid在xid文件中对应的位置</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> getXidPosition(xid);</span><br><span class="line">    <span class="comment">// 创建一个长度为XID_FIELD_SIZE的字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] tmp = <span class="keyword">new</span> <span class="title class_">byte</span>[XID_FIELD_SIZE];</span><br><span class="line">    <span class="comment">// 将事务状态设置为status</span></span><br><span class="line">    tmp[<span class="number">0</span>] = status;</span><br><span class="line">    <span class="comment">// 使用字节数组创建一个ByteBuffer</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(tmp);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将文件通道的位置设置为offset</span></span><br><span class="line">        fc.position(offset);</span><br><span class="line">        <span class="comment">// 将ByteBuffer中的数据写入到文件通道</span></span><br><span class="line">        fc.write(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 如果出现异常，调用Panic.panic方法处理</span></span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 强制将文件通道中的所有未写入的数据写入到磁盘</span></span><br><span class="line">        fc.force(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 如果出现异常，调用Panic.panic方法处理</span></span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4增加事务计数"><a class="markdownIt-Anchor" href="#4增加事务计数"></a> （4）增加事务计数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将XID加一，并更新XID Header</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">incrXIDCounter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 事务总数加一</span></span><br><span class="line">    xidCounter++;</span><br><span class="line">    <span class="comment">// 将新的事务总数转换为字节数组，并用ByteBuffer包装</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(Parser.long2Byte(xidCounter));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将文件通道的位置设置为0，即文件的开始位置</span></span><br><span class="line">        fc.position(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 将ByteBuffer中的数据写入到文件通道，即更新了XID文件的头部信息</span></span><br><span class="line">        fc.write(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 如果出现异常，调用Panic.panic方法处理</span></span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 强制将文件通道中的所有未写入的数据写入到磁盘</span></span><br><span class="line">        fc.force(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 如果出现异常，调用Panic.panic方法处理</span></span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5事务状态检查"><a class="markdownIt-Anchor" href="#5事务状态检查"></a> （5）事务状态检查</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个方法，接收一个事务ID（xid）和一个状态（status）作为参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkXID</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span> status)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算事务ID在XID文件中的位置</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> getXidPosition(xid);</span><br><span class="line">    <span class="comment">// 创建一个新的字节缓冲区（ByteBuffer），长度为XID_FIELD_SIZE</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="keyword">new</span> <span class="title class_">byte</span>[XID_FIELD_SIZE]);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将文件通道的位置设置为offset</span></span><br><span class="line">        fc.position(offset);</span><br><span class="line">        <span class="comment">// 从文件通道读取数据到字节缓冲区</span></span><br><span class="line">        fc.read(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 如果出现异常，调用Panic.panic方法处理</span></span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查字节缓冲区的第一个字节是否等于给定的状态</span></span><br><span class="line">    <span class="comment">// 如果等于，返回true，否则返回false</span></span><br><span class="line">    <span class="keyword">return</span> buf.array()[<span class="number">0</span>] == status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6关闭事务管理器"><a class="markdownIt-Anchor" href="#6关闭事务管理器"></a> （6）关闭事务管理器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.close();</span><br><span class="line">        file.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="25总结"><a class="markdownIt-Anchor" href="#25总结"></a> 2.5总结</h2><ol><li>TM 模块的主要功能是 <strong>管理事务</strong>，包括事务的开始、提交、回滚以及状态检查。</li><li>为实现这些功能，模块中定义了一系列关键常量，如 <code>LEN_XID_HEADER_LENGTH</code>、<code>XID_FIELD_SIZE</code>、<code>FIELD_TRAN_ACTIVE</code>、<code>FIELD_TRAN_COMMITTED</code>、<code>FIELD_TRAN_ABORTED</code>、<code>SUPER_XID</code> 和 <code>XID_SUFFIX</code>，分别表示 XID 文件头长度、每个事务的占用长度、事务的三种状态、超级事务标识以及 XID 文件的后缀。</li><li>在实现上，TM 模块通过 <code>RandomAccessFile</code> 类型的 <code>file</code> 和 <code>FileChannel</code> 类型的 <code>fc</code> 操作 XID 文件，并使用 <code>xidCounter</code> 来记录事务的数量，同时通过 <code>Lock</code> 类确保线程安全。</li><li>构造函数中，首先对 <code>file</code> 和 <code>fc</code> 进行初始化，并调用 <code>checkXIDCounter</code> 方法校验 XID 文件的合法性，确保文件的正确性。</li><li>在事务管理方面，<code>begin()</code> 方法用于开始一个新事务，通过调用 <code>updateXID()</code> 方法将事务 ID 和状态写入 XID 文件，并通过 <code>incrXIDCounter()</code> 方法更新 XID 计数器。<code>commit()</code> 和 <code>abort()</code> 方法分别用于提交和回滚事务，依赖 <code>updateXID()</code> 方法来更新事务状态。<code>isActive()</code>、<code>isCommitted()</code> 和 <code>isAborted()</code> 方法用于检查事务状态，通过 <code>checkXID()</code> 方法确认事务的当前状态。<code>close()</code> 方法则负责关闭文件通道和文件，确保资源的正确释放。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="【MiniDB】" scheme="https://www.haipeng-lin.cn/categories/%E3%80%90MiniDB%E3%80%91/"/>
    
    
  </entry>
  
  <entry>
    <title>MiniDB——事务管理器</title>
    <link href="https://www.haipeng-lin.cn/posts/2a5b6ce0.html"/>
    <id>https://www.haipeng-lin.cn/posts/2a5b6ce0.html</id>
    <published>2024-09-04T23:27:51.000Z</published>
    <updated>2024-09-20T01:49:22.128Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1项目简介"><a class="markdownIt-Anchor" href="#1项目简介"></a> 1.项目简介</h1><ul><li><p>代码仓库：<a href="https://github.com/haipeng-lin/MiniDB">https://github.com/haipeng-lin/MiniDB</a></p></li><li><p>使用文档：暂无</p></li><li><p>文章链接：</p><ul><li>MiniDB简介：<a href="https://www.haipeng-lin.cn/posts/45929ae6.html">https://www.haipeng-lin.cn/posts/45929ae6.html</a></li><li>事务管理器：<a href="https://www.haipeng-lin.cn/posts/2a5b6ce0.html">https://www.haipeng-lin.cn/posts/2a5b6ce0.html</a></li><li><mark><strong>数据管理器</strong></mark>（引用计数缓存、数据页缓存、数据页管理、日志管理、页面索引、DM实现）：<a href="https://www.haipeng-lin.cn/posts/c9808524.html">https://www.haipeng-lin.cn/posts/c9808524.html</a></li><li>版本管理器：<a href="https://www.haipeng-lin.cn/posts/cef83234.html">https://www.haipeng-lin.cn/posts/cef83234.html</a></li><li>索引管理器：<a href="https://www.haipeng-lin.cn/posts/3e11dfdd.html">https://www.haipeng-lin.cn/posts/3e11dfdd.html</a></li><li>表管理器：暂无</li></ul></li></ul><h2 id="11项目介绍"><a class="markdownIt-Anchor" href="#11项目介绍"></a> 1.1项目介绍</h2><p>本项目是使用Java实现的一个简易数据库，实现了事务管理、数据管理、MVCC、日志管理、索引管理以及表管理，支持简单的DML语句</p><blockquote><p><strong>为什么想做MiniDB项目？</strong></p><p>之前在看一本关于MySQL的书，《MySQL是怎样运行的》，<br />最吸引我的地方是MVCC多版本并发控制的实现，所以我也想从头实现一次，加深自己对数据库的理解</p></blockquote><h2 id="12整体结构"><a class="markdownIt-Anchor" href="#12整体结构"></a> 1.2整体结构</h2><p>分为前端和后端，前后端通过socket交互。前端接受用户输入，并将命令传给后端，后端则解析命令并进行数据库操作</p><p>五大模块：</p><ol><li>事务管理器（TM）：管理事务文件，并提供接口供其他模块查询事务状态</li><li>数据管理器（DM）：<ol><li>分页管理数据文件，进行缓存</li><li>管理日志文件，保障数据库崩溃时的数据一致性</li><li>抽象出更加模块化的数据操作函数和格式，供上层调用</li></ol></li><li>版本管理器（VM）：基于2PL实现了调度序列的可串行化，并实现MVCC消除读写冲突，实现了读已提交和可重复读隔离级别</li><li>索引管理器（IM）：实现了基于B+树的索引，目前<code>where</code>子句仅支持已索引的字段</li><li>表管理器（TBM）：实现对字段和表的管理</li></ol><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/mydb0.jpg" alt="image.png" /></p><h2 id="13涉及的文件"><a class="markdownIt-Anchor" href="#13涉及的文件"></a> 1.3涉及的文件</h2><ol><li>.xid：TM来操作，用于管理事务id及对应状态</li><li>.db：DM来操作，用于存储数据库文件</li><li>.log：DM来操作，用户存储日志</li><li>.bt：booter文件，用户与存储数据库中的第一个表的id（目前的项目只支持一个数据库，不支持多数据库）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="【MiniDB】" scheme="https://www.haipeng-lin.cn/categories/%E3%80%90MiniDB%E3%80%91/"/>
    
    
  </entry>
  
  <entry>
    <title>开发环境部署</title>
    <link href="https://www.haipeng-lin.cn/posts/58d09dd7.html"/>
    <id>https://www.haipeng-lin.cn/posts/58d09dd7.html</id>
    <published>2024-09-02T07:40:06.000Z</published>
    <updated>2024-09-09T02:14:12.478Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1docker安装"><a class="markdownIt-Anchor" href="#1docker安装"></a> 1.Docker安装</h1><blockquote><p>分为linux安装和windows安装</p></blockquote><h2 id="11linux安装docker"><a class="markdownIt-Anchor" href="#11linux安装docker"></a> 1.1Linux安装docker</h2><p>官方帮助文档：<a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p><h3 id="111安装命令"><a class="markdownIt-Anchor" href="#111安装命令"></a> 1.1.1安装命令</h3><ol><li><p>卸载之前的docker</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">sudo</span> <span class="string">yum</span> <span class="string">remove</span> <span class="string">docker</span> <span class="string">\</span></span><br><span class="line">                  <span class="string">docker-client</span> <span class="string">\</span></span><br><span class="line">                  <span class="string">docker-client-latest</span> <span class="string">\</span></span><br><span class="line">                  <span class="string">docker-common</span> <span class="string">\</span></span><br><span class="line">                  <span class="string">docker-latest</span> <span class="string">\</span></span><br><span class="line">                  <span class="string">docker-latest-logrotate</span> <span class="string">\</span></span><br><span class="line">                  <span class="string">docker-logrotate</span> <span class="string">\</span></span><br><span class="line">                  <span class="string">docker-engine</span></span><br></pre></td></tr></table></figure></li><li><p>需要的安装包</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">yum</span> <span class="string">install</span> <span class="string">-y</span> <span class="string">yum-utils</span></span><br></pre></td></tr></table></figure></li><li><p>设置镜像的仓库</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 国外的，不推荐，linux命令直接报错：连接docker官网超时</span></span><br><span class="line"><span class="string">yum-config-manager</span> <span class="string">\</span></span><br><span class="line">    <span class="string">--add-repo</span> <span class="string">\</span></span><br><span class="line">    <span class="string">https://download.docker.com/linux/centos/docker-ce.repo</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 国内阿里云</span></span><br><span class="line"><span class="string">yum-config-manager</span> <span class="string">\</span></span><br><span class="line">    <span class="string">--add-repo</span> <span class="string">\</span></span><br><span class="line">    <span class="string">https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure></li><li><p>更新yum软件包索引</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">yum</span> <span class="string">makecache</span> </span><br></pre></td></tr></table></figure></li><li><p>安装docker相关的 docker-ce 社区版 而ee是企业版</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">yum</span> <span class="string">install</span> <span class="string">docker-ce</span> <span class="string">docker-ce-cli</span> <span class="string">containerd.io</span></span><br></pre></td></tr></table></figure></li><li><p>启动docker</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">service</span> <span class="string">docker</span> <span class="string">start</span></span><br></pre></td></tr></table></figure></li><li><p>查看docker状态</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">service</span> <span class="string">docker</span> <span class="string">status</span></span><br></pre></td></tr></table></figure></li><li><p>使用docker version查看是否安装成功</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">version</span></span><br></pre></td></tr></table></figure></li><li><p>设置docker开机自启动</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">systemctl</span> <span class="string">enable</span> <span class="string">docker.service</span></span><br></pre></td></tr></table></figure></li><li><p>查看docker是否开机自启动成功</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">systemctl</span> <span class="string">is-enabled</span> <span class="string">docker</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="112配置阿里云镜像加速"><a class="markdownIt-Anchor" href="#112配置阿里云镜像加速"></a> 1.1.2配置阿里云镜像加速</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">sudo</span> <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">/etc/docker</span></span><br><span class="line"><span class="string">sudo</span> <span class="string">tee</span> <span class="string">/etc/docker/daemon.json</span> <span class="string">&lt;&lt;-&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;:</span> [<span class="string">&quot;https://svctvo40.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string">sudo</span> <span class="string">systemctl</span> <span class="string">daemon-reload</span></span><br><span class="line"><span class="string">sudo</span> <span class="string">systemctl</span> <span class="string">restart</span> <span class="string">docker</span></span><br></pre></td></tr></table></figure><h3 id="113docker-镜像容器相关命令"><a class="markdownIt-Anchor" href="#113docker-镜像容器相关命令"></a> 1.1.3docker 镜像/容器相关命令</h3><h4 id="1镜像"><a class="markdownIt-Anchor" href="#1镜像"></a> （1）镜像</h4><ul><li><p>查看安装的镜像</p>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">images</span></span><br></pre></td></tr></table></figure></li><li><p>安装镜像</p>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">pull</span> <span class="string">镜像名</span></span><br></pre></td></tr></table></figure></li><li><p>删除单个/全部镜像</p>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">doker</span> <span class="string">rmi</span> <span class="string">镜像id/$(docker</span> <span class="string">images</span> <span class="string">-q)</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2容器"><a class="markdownIt-Anchor" href="#2容器"></a> （2）容器</h4><ul><li><p>查看所有容器</p>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">ps</span> <span class="string">-a</span></span><br></pre></td></tr></table></figure></li><li><p>查看所有正在运行的容器</p>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">ps</span></span><br></pre></td></tr></table></figure></li><li><p>新建容器</p>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">镜像名</span></span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line"><span class="string">--name=&quot;Name&quot;</span> <span class="comment"># 容器名字</span></span><br><span class="line"><span class="string">-d</span> <span class="comment"># 后台运行</span></span><br><span class="line"><span class="string">-it</span> <span class="comment"># 使用交互方式进行,进入容器</span></span><br><span class="line"><span class="string">-p</span> <span class="comment"># 指定容器的端口  </span></span><br><span class="line"><span class="string">-p</span> <span class="string">ip:主机端口:容器端口</span></span><br><span class="line"><span class="string">-p</span> <span class="string">主机端口:容器端口(常用)</span></span><br><span class="line"><span class="string">-p</span> <span class="string">容器端口</span></span><br><span class="line"><span class="string">容器端口</span></span><br><span class="line"><span class="string">-P</span> <span class="comment"># 随机指定端口</span></span><br></pre></td></tr></table></figure></li><li><p>启动单个容器</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id/容器名</span><br></pre></td></tr></table></figure></li><li><p>启动所有容器</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start $(docker ps -aq)</span><br></pre></td></tr></table></figure></li><li><p>停止单个容器</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器id</span><br></pre></td></tr></table></figure></li><li><p>删除单个/所有容器：remove</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id/$(docker ps -a -q)</span><br></pre></td></tr></table></figure></li></ul><h2 id="12windows安装docker"><a class="markdownIt-Anchor" href="#12windows安装docker"></a> 1.2Windows安装docker</h2><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240902094532034.png" alt="image-20240902094532034" /></p><h1 id="2nacos安装"><a class="markdownIt-Anchor" href="#2nacos安装"></a> 2.Nacos安装</h1><h2 id="21windows安装nacos"><a class="markdownIt-Anchor" href="#21windows安装nacos"></a> 2.1Windows安装nacos</h2><h3 id="211nacos"><a class="markdownIt-Anchor" href="#211nacos"></a> 2.1.1nacos</h3><blockquote><p>发布历史版本（需开梯子）：<a href="https://nacos.io/download/release-history/">https://nacos.io/download/release-history/</a></p><p>我下载的是2.2.3版本，解压缩后目录如下：</p><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240902095913909.png" alt="image-20240902095913909" /></p></blockquote><h3 id="212持久化配置"><a class="markdownIt-Anchor" href="#212持久化配置"></a> 2.1.2持久化配置</h3><ol><li><p><mark>运行数据库文件</mark></p><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240902100249297.png" alt="image-20240902100249297" /></p></li><li><p><mark>修改数据库连接信息，conf下的application.properties</mark></p><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240902100356126.png" alt="image-20240902100356126" /></p></li></ol><h2 id="22linux安装nacos"><a class="markdownIt-Anchor" href="#22linux安装nacos"></a> 2.2Linux安装nacos</h2><blockquote><p>暂无笔记</p></blockquote><h1 id="3rocketmq安装"><a class="markdownIt-Anchor" href="#3rocketmq安装"></a> 3.RocketMQ安装</h1><h2 id="31windows使用docker-compose方式安装"><a class="markdownIt-Anchor" href="#31windows使用docker-compose方式安装"></a> 3.1Windows使用docker-compose方式安装</h2><blockquote><p>安装本质：基于windows的docker的docker</p></blockquote><h3 id="311文件夹及配置文件"><a class="markdownIt-Anchor" href="#311文件夹及配置文件"></a> 3.1.1文件夹及配置文件</h3><ol><li><p>新建相应目录rocketmq-docker-compose，然后在里面新建broker文件夹，放broker.conf</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">brokerClusterName</span> <span class="string">=</span> <span class="string">DefaultCluster</span></span><br><span class="line"><span class="string">brokerName</span> <span class="string">=</span> <span class="string">broker</span></span><br><span class="line"><span class="string">brokerId</span> <span class="string">=</span> <span class="number">0</span></span><br><span class="line"><span class="string">deleteWhen</span> <span class="string">=</span> <span class="number">04</span></span><br><span class="line"><span class="string">fileReservedTime</span> <span class="string">=</span> <span class="number">48</span></span><br><span class="line"><span class="string">brokerRole</span> <span class="string">=</span> <span class="string">ASYNC_MASTER</span></span><br><span class="line"><span class="string">flushDiskType</span> <span class="string">=</span> <span class="string">ASYNC_FLUSH</span></span><br><span class="line"><span class="comment"># 你的本机ip, 注意不要写localhost,127.0.0.1等，因为这是放到docker容器中的，我们需要指向本机</span></span><br><span class="line"><span class="string">brokerIP1</span> <span class="string">=</span> <span class="number">169.254</span><span class="number">.7</span><span class="number">.200</span></span><br><span class="line"><span class="comment"># 禁用 tsl</span></span><br><span class="line"><span class="string">tlsTestModeEnable</span> <span class="string">=</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li><li><p>在目录rocketmq-docker-compose新建data文件夹，用于存放持久化数据，防止容器重启数据丢失</p></li><li><p>新建docker-compose文件夹，里面新建文件docker-compose.yml</p><blockquote><p>注意，<mark>文件挂载的路径换成自己的</mark></p><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240902085027015.png" alt="image-20240902085027015" /></p></blockquote> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">namesrv:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/rocketmq:5.1.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rocketmq-pmnamesrv</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">mqnamesrv</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rocketmq</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9876:9876&quot;</span></span><br><span class="line">  <span class="attr">broker:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/rocketmq:5.1.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rocketmq-pmbroker</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">mqbroker</span> <span class="string">-n</span> <span class="string">namesrv:9876</span> <span class="string">-c</span> <span class="string">/home/rocketmq/rocketmq-5.1.0/conf/broker.conf</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;10911:10911&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;10909:10909&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;10912:10912&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">namesrv</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rocketmq</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">D:/peng/environment/RocketMQ/rocketmq-docker-compose/broker/broker.conf:/home/rocketmq/rocketmq-5.1.0/conf/broker.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">D:/peng/environment/RocketMQ/rocketmq-docker-compose/data:/home/rocketmq/store</span></span><br><span class="line">  <span class="attr">proxy:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/rocketmq:5.1.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rocketmq-pmproxy</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rocketmq</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">broker</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">namesrv</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8081</span><span class="string">:8081</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">on-failure</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NAMESRV_ADDR=rocketmq-pmnamesrv:9876</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">mqproxy</span></span><br><span class="line">  <span class="attr">dashboard:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apacherocketmq/rocketmq-dashboard:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rocketmq-dashboard</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JAVA_OPTS=-Drocketmq.namesrv.addr=rocketmq-pmnamesrv:9876</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8082:8080&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rocketmq</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">namesrv</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">broker</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">proxy</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">rocketmq:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure></li><li><p>最终文件夹目录如下：</p><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240902085225415.png" alt="image-20240902085225415" /></p></li></ol><h3 id="312docker-compose相关命令"><a class="markdownIt-Anchor" href="#312docker-compose相关命令"></a> 3.1.2docker-compose相关命令</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一键启动</span></span><br><span class="line"><span class="string">docker-compose</span> <span class="string">up</span> <span class="string">-d</span></span><br><span class="line"><span class="comment">#一键停止所有容器</span></span><br><span class="line"><span class="string">docker-compose</span> <span class="string">stop</span></span><br><span class="line"><span class="comment">#一键删除所有容器</span></span><br><span class="line"><span class="string">docker-compose</span> <span class="string">rm</span></span><br><span class="line"><span class="comment">#一键查看所有启动的容器</span></span><br><span class="line"><span class="string">docker-compose</span> <span class="string">ps</span></span><br></pre></td></tr></table></figure><h3 id="313一键启动"><a class="markdownIt-Anchor" href="#313一键启动"></a> 3.1.3一键启动</h3><ol><li><p>在docker-compose目录下执行cmd命令，然后再执行docker-compose up -d 命令</p><blockquote><p>rocketmq-pnamesrv：</p><p>rocketmq-pmbroker：</p><p>rocketmq-pmproxy：</p><p>rockeqmq-dashbard：控制台</p></blockquote><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240902085459724.png" alt="image-20240902085459724" /></p></li><li><p>浏览器输入：loaclhost:8082</p><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240902090125901.png" alt="image-20240902090125901" /></p></li></ol><h1 id="4seata安装"><a class="markdownIt-Anchor" href="#4seata安装"></a> 4.Seata安装</h1><h2 id="41windows安装seata"><a class="markdownIt-Anchor" href="#41windows安装seata"></a> 4.1Windows安装Seata</h2><h3 id="411下载"><a class="markdownIt-Anchor" href="#411下载"></a> 4.1.1下载</h3><blockquote><p>下载地址：https:/seata.apache.org/zh-<br />cn/unversioned/download/seata-server/</p><p>安装最新的稳定版本：2.0.0</p></blockquote><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240902101357833.png" alt="image-20240902101357833" /></p><h3 id="412启动"><a class="markdownIt-Anchor" href="#412启动"></a> 4.1.2启动</h3><p>进入seata的bin目录，输入启动命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seata-server.bat</span><br></pre></td></tr></table></figure><p>访问：localhost:7091</p><p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240902103158000.png" alt="image-20240902103158000" /></p><h2 id="42linux安装seata"><a class="markdownIt-Anchor" href="#42linux安装seata"></a> 4.2Linux安装Seata</h2><blockquote><p>暂无笔记</p></blockquote><h1 id="5redis安装"><a class="markdownIt-Anchor" href="#5redis安装"></a> 5.Redis安装</h1><h2 id="51windows安装redis"><a class="markdownIt-Anchor" href="#51windows安装redis"></a> 5.1Windows安装Redis</h2><h3 id="511下载"><a class="markdownIt-Anchor" href="#511下载"></a> 5.1.1下载</h3><h3 id="512启动"><a class="markdownIt-Anchor" href="#512启动"></a> 5.1.2启动</h3><h2 id="52linux安装redis"><a class="markdownIt-Anchor" href="#52linux安装redis"></a> 5.2Linux安装Redis</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="部署" scheme="https://www.haipeng-lin.cn/categories/%E9%83%A8%E7%BD%B2/"/>
    
    
  </entry>
  
</feed>
