<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Spring框架上篇 | 拾忆鱼's Blog</title><meta name="author" content="拾忆鱼"><meta name="copyright" content="拾忆鱼"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer" /><meta name="description" content="1.Spring简述  1.1什么是Spring框架？ Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。  1.2Spring的核心功能 Spring提供的核心功能为 IOC控制反转（Inversion of Control）和 AOP面向切面编程 （Aspect-Oriented Programming）  1.2.1 IOC  （1）IOC">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring框架上篇">
<meta property="og:url" content="https://www.haipeng-lin.cn/posts/b0e0901d.html">
<meta property="og:site_name" content="拾忆鱼&#39;s Blog">
<meta property="og:description" content="1.Spring简述  1.1什么是Spring框架？ Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。  1.2Spring的核心功能 Spring提供的核心功能为 IOC控制反转（Inversion of Control）和 AOP面向切面编程 （Aspect-Oriented Programming）  1.2.1 IOC  （1）IOC">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/57e8a40e4a1ba3c2c85557044ffe1fe8.jpeg#pic_center">
<meta property="article:published_time" content="2024-08-28T04:36:11.000Z">
<meta property="article:modified_time" content="2024-09-01T01:40:11.233Z">
<meta property="article:author" content="拾忆鱼">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i-blog.csdnimg.cn/blog_migrate/57e8a40e4a1ba3c2c85557044ffe1fe8.jpeg#pic_center"><link rel="shortcut icon" href="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410101530409.png"><link rel="canonical" href="https://www.haipeng-lin.cn/posts/b0e0901d"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="msvalidate.01" content="7A691DA1ABC779E7F680EF66E1D934AA"/><meta name="google-site-verification"/><meta name="baidu-site-verification" content="XXXXX"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":250},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 拾忆鱼","link":"链接: ","source":"来源: 拾忆鱼's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring框架上篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-01 09:40:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/gitcalendar/css/gitcalendar.css"/><link rel="stylesheet" href="/css/tag_plugins.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/swiper.min.css"><script src="https://libs.baidu.com/jquery/2.1.4/jquery.min.js"></script><link rel="stylesheet" href="/css/tags.css"><link rel="stylesheet" href="/css/double_article.css"><link rel="stylesheet" href="/css/nav.css"><link rel="stylesheet" href="/css/essay_page.css"><script type="text/javascript" src="/js/echarts.min.js"></script><script type="text/javascript" src="/js/copy.js"></script><script src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><link rel="stylesheet" href="/css/copyright.css"><link rel="stylesheet" href="/css/progress_bar.css"><link rel="stylesheet" href="/css/footer.css"><link rel="stylesheet" href="/css/page.css"><link rel="stylesheet" href="/css/layout.css"><link rel="stylesheet" href="/css/color.css"><link rel="stylesheet" href="/css/cursors/cursors.css"><link rel="stylesheet" href="/css/fonts/font.css"><link rel="stylesheet" href="/css/about/about.css"><link rel="stylesheet" href="/css/about/careers.css"><link rel="stylesheet" href="/css/about/genshinimpact.css"><link rel="stylesheet" href="/css/about/hello-about.css"><link rel="stylesheet" href="/css/about/site.css"><link rel="stylesheet" href="/css/about/skills.css"><link rel="stylesheet" href="/css/photo.css"><link rel="stylesheet" href="/css/icat.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="拾忆鱼's Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410101530409.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">60</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives"><i class="fa-fw fas fa-archive"></i><span> 全部</span></a></li><li><a class="site-page child" href="/categories"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heart"></i><span> 空间</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/essay"><i class="fa-fw fas fa-comments"></i><span> 碎碎念</span></a></li><li><a class="site-page child" href="/collect"><i class="fa-fw fas fa-walking"></i><span> 足迹阁</span></a></li><li><a class="site-page child" href="/photo"><i class="fa-fw fas fa-images"></i><span> 照片墙</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about"><i class="fa-fw fas fa-address-card"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">拾忆鱼's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives"><i class="fa-fw fas fa-archive"></i><span> 全部</span></a></li><li><a class="site-page child" href="/categories"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heart"></i><span> 空间</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/essay"><i class="fa-fw fas fa-comments"></i><span> 碎碎念</span></a></li><li><a class="site-page child" href="/collect"><i class="fa-fw fas fa-walking"></i><span> 足迹阁</span></a></li><li><a class="site-page child" href="/photo"><i class="fa-fw fas fa-images"></i><span> 照片墙</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about"><i class="fa-fw fas fa-address-card"></i><span> 关于</span></a></div></div><center id="name-container"><a id="page-name" href="javascript:btf.scrollToDest(0, 500)">PAGE_NAME</a></center></div><div id="toggleButtons"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Spring框架上篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-28T04:36:11.000Z" title="发表于 2024-08-28 12:36:11">2024-08-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-01T01:40:11.233Z" title="更新于 2024-09-01 09:40:11">2024-09-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E3%80%90%E6%A1%86%E6%9E%B6%E3%80%91/">【框架】</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring框架上篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="1spring简述"><a class="markdownIt-Anchor" href="#1spring简述"></a> 1.Spring简述</h1>
<h2 id="11什么是spring框架"><a class="markdownIt-Anchor" href="#11什么是spring框架"></a> 1.1什么是Spring框架？</h2>
<p>Spring 是一款开源的<mark>轻量级 Java 开发框架</mark>，旨在提高开发人员的开发效率以及系统的可维护性。</p>
<h2 id="12spring的核心功能"><a class="markdownIt-Anchor" href="#12spring的核心功能"></a> 1.2Spring的核心功能</h2>
<p>Spring提供的核心功能为 <mark><strong>IOC控制反转</strong></mark>（Inversion of Control）和 <mark><strong>AOP面向切面编程</strong></mark> （Aspect-Oriented Programming）</p>
<h3 id="121-ioc"><a class="markdownIt-Anchor" href="#121-ioc"></a> 1.2.1 IOC</h3>
<h4 id="1ioc介绍"><a class="markdownIt-Anchor" href="#1ioc介绍"></a> （1）IOC介绍</h4>
<ol>
<li><strong>IoC（Inversion of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。</li>
<li>IoC 的思想就是将<mark>原本在程序中手动创建对象的控制权，交由 Spring 框架来管理</mark>。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</li>
</ol>
<h4 id="2控制反转"><a class="markdownIt-Anchor" href="#2控制反转"></a> （2）控制？反转？</h4>
<ul>
<li><strong>控制</strong>：指的是<mark>对象创建（实例化、管理）的权力</mark></li>
<li><strong>反转</strong>：<mark>控制权交给外部环境</mark>（Spring 框架、IoC 容器）</li>
</ul>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2cbfe7f98236f2ea4669fb1e8c3913b7.png" alt="IoC 图解" /></p>
<p>将对象之间的<mark>相互依赖关系</mark>交给 <mark>IoC 容器</mark>来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</p>
<p>在 Spring 中， <mark>IoC 容器是 Spring 用来实现 IoC 的载体</mark>， IoC 容器实际上就是个 <mark>Map（key，value）</mark>，Map 中存放的是各种对象。</p>
<p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p>
<h3 id="122-aop"><a class="markdownIt-Anchor" href="#122-aop"></a> 1.2.2 AOP</h3>
<h4 id="1aop介绍"><a class="markdownIt-Anchor" href="#1aop介绍"></a> （1）AOP介绍</h4>
<ol>
<li>AOP(Aspect-Oriented Programming:<mark>面向切面编程</mark>)：能够<mark>将那些与业务无关</mark>，却为业务模块所 <mark><strong>共同调用的逻辑或责任</strong></mark>（例如<mark>事务处理、日志管理、权限控制</mark>等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</li>
<li><mark>Spring AOP 就是基于动态代理</mark>的
<ol>
<li>如果要代理的对象，<mark>实现了某个接口</mark>，那么 Spring AOP 会使用 <mark><strong>JDK Proxy</strong></mark>，去创建代理对象，</li>
<li>对于<mark>没有实现接口的对象</mark>，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <mark>Cglib</mark> 生成一个被代理对象的子类来作为代理，如下图所示：</li>
</ol>
</li>
</ol>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4cb8541e33c919f738cf0562694c7b12.jpeg" alt="SpringAOPProcess" /></p>
<h4 id="2专业术语"><a class="markdownIt-Anchor" href="#2专业术语"></a> （2）专业术语</h4>
<table>
<thead>
<tr>
<th style="text-align:center">术语</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">目标(Target)</td>
<td style="text-align:center">被通知的对象</td>
</tr>
<tr>
<td style="text-align:center">代理(Proxy)</td>
<td style="text-align:center">向目标对象应用通知之后创建的代理对象</td>
</tr>
<tr>
<td style="text-align:center">连接点(JoinPoint)</td>
<td style="text-align:center">目标对象的所属类中，定义的所有方法均为连接点</td>
</tr>
<tr>
<td style="text-align:center">切入点(Pointcut)</td>
<td style="text-align:center">被切面拦截 / 增强的连接点（切入点一定是连接点，连接点不一定是切入点）</td>
</tr>
<tr>
<td style="text-align:center">通知(Advice)</td>
<td style="text-align:center">增强的逻辑 / 代码，也即拦截到目标对象的连接点之后要做的事情</td>
</tr>
<tr>
<td style="text-align:center">切面(Aspect)</td>
<td style="text-align:center">切入点(Pointcut)+通知(Advice)</td>
</tr>
<tr>
<td style="text-align:center">Weaving(织入)</td>
<td style="text-align:center">将通知应用到目标对象，进而生成代理对象的过程动作</td>
</tr>
</tbody>
</table>
<h4 id="3spring-aop和aspectj-aop有什么区别"><a class="markdownIt-Anchor" href="#3spring-aop和aspectj-aop有什么区别"></a> （3）Spring AOP和AspectJ AOP有什么区别？</h4>
<ol>
<li>
<p><strong>Spring AOP 属于<mark>运行时增强</mark>，而 AspectJ 是<mark>编译时增强</mark>。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
</li>
<li>
<p><mark>Spring AOP 已经集成了 AspectJ</mark> ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
</li>
<li>
<p>AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
</li>
<li>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多</p>
</li>
</ol>
<h4 id="4多个切面的执行顺序如何控制"><a class="markdownIt-Anchor" href="#4多个切面的执行顺序如何控制"></a> （4）多个切面的执行顺序如何控制？</h4>
<ol>
<li>通常使用 <mark>@Order</mark> 注解直接定义切面顺序</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值越小优先级越高</span></span><br><span class="line"><span class="meta">@Order(3)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>实现<code>Ordered</code> 接口重写 <code>getOrder</code> 方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 返回值越小优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13spring的架构"><a class="markdownIt-Anchor" href="#13spring的架构"></a> 1.3Spring的架构</h2>
<p>Spring 框架提供了大约 20 个模块，可以根据应用程序需求使用它们。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/8801946b5a561135e8a6348a32397cb0.png" alt="Spring 框架架构" /></p>
<h3 id="131core容器"><a class="markdownIt-Anchor" href="#131core容器"></a> 1.3.1Core容器</h3>
<p>Core 容器由 Core、Beans、Context 和 Expression Language 模块组成，详细信息如下 −</p>
<ul>
<li><strong>Core</strong> 模块提供了框架的基本部分，包括 IoC 和依赖注入功能。</li>
<li><mark><strong>Bean</strong> 模块提供了 BeanFactory</mark>，它是工厂模式的一个复杂的实现。</li>
<li><strong>Context</strong> 模块建立在 Core 和 Beans 模块提供的坚实基础之上，它是访问任何已定义和配置的对象的媒介。 ApplicationContext 接口是上下文模块的焦点。</li>
<li><strong>SpEL</strong> 模块提供了一种强大的表达式语言，用于在运行时查询和操作对象图。</li>
</ul>
<h3 id="132数据访问集成"><a class="markdownIt-Anchor" href="#132数据访问集成"></a> 1.3.2数据访问/集成</h3>
<p>数据访问/集成层由 JDBC、ORM、OXM、JMS 和 Transaction 事务模块组成，详细信息如下 −</p>
<ul>
<li><strong>JDBC</strong> 模块提供了一个 JDBC 抽象层，它消除了繁琐的 JDBC 相关编码的需要。</li>
<li><strong>ORM</strong> 模块为流行的对象关系映射 API 提供集成层，包括 JPA、JDO、Hibernate 和 iBatis。</li>
<li><strong>OXM</strong> 模块提供了一个抽象层，它支持 JAXB、Castor、XMLBeans、JiBX 和 XStream 的 Object/XML 映射实现。</li>
<li>Java 消息传递服务 <strong>JMS</strong> 模块包含用于生成和使用消息的功能。</li>
<li><strong>Transaction</strong> 模块支持对实现特殊接口的类和所有 POJO 的编程和声明式事务管理。</li>
</ul>
<h3 id="133web"><a class="markdownIt-Anchor" href="#133web"></a> 1.3.3Web</h3>
<p>Web 层由 Web、Web-MVC、Web-Socket 和 Web-Portlet 模块组成，具体如下 −</p>
<ul>
<li><strong>Web</strong> 模块提供了基本的面向 Web 的集成功能，例如多部分文件上传功能以及使用 servlet 侦听器和面向 Web 的应用程序上下文初始化 IoC 容器。</li>
<li><strong>Web-MVC</strong> 模块包含 Spring 的 Web 应用程序的 Model-View-Controller(模型-视图-控制器) (MVC) 实现。</li>
<li><strong>Web-Socket</strong> 模块支持 Web 应用程序中客户端和服务器之间基于 WebSocket 的双向通信。</li>
<li><strong>Web-Portlet</strong> 模块提供了在portlet 环境中使用的MVC 实现，并反映了Web-Servlet 模块的功能</li>
</ul>
<h3 id="134杂项"><a class="markdownIt-Anchor" href="#134杂项"></a> 1.3.4杂项</h3>
<p>其他重要的模块很少，如 AOP、Aspects、Instrumentation、Web 和 Test 模块，具体如下 −</p>
<ul>
<li><strong>AOP</strong> 模块提供了一个面向方面的编程实现，允许您定义方法拦截器和切入点，以清晰地解耦实现应该分离的功能的代码。</li>
<li><strong>Aspects</strong> 模块提供与 AspectJ 的集成，AspectJ 又是一个强大且成熟的 AOP 框架。</li>
<li><strong>Instrumentation</strong> 模块提供类检测支持和类加载器实现以用于某些应用程序服务器。</li>
<li><strong>Messaging</strong> 模块支持将 STOMP 作为 WebSocket 子协议在应用程序中使用。 它还支持注解编程模型，用于路由和处理来自 WebSocket 客户端的 STOMP 消息。</li>
<li><strong>Test</strong> 模块支持使用 JUnit 或 TestNG 框架对 Spring 组件进行测试。</li>
</ul>
<h1 id="2搭建spring项目环境"><a class="markdownIt-Anchor" href="#2搭建spring项目环境"></a> 2.搭建Spring项目环境</h1>
<h2 id="21安装spring框架库"><a class="markdownIt-Anchor" href="#21安装spring框架库"></a> 2.1安装Spring框架库</h2>
<p>下载路径： <a target="_blank" rel="noopener" href="https://repo.spring.io/release/org/springframework/spring">https://repo.spring.io/release/org/springframework/spring</a></p>
<p>下载完成之后，<mark>在libs 目录中可以找到所有 Spring 库</mark></p>
<h2 id="22导入框架库"><a class="markdownIt-Anchor" href="#22导入框架库"></a> 2.2导入框架库</h2>
<p>IDEA导入Spring框架库</p>
<h2 id="23创建类"><a class="markdownIt-Anchor" href="#23创建类"></a> 2.3创建类</h2>
<ul>
<li>HelloWorld类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessage</span><span class="params">(String message)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.message  = message;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMessage</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Your Message : &quot;</span> + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>MainApp类——主应用程序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApp</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;Beans.xml&quot;</span>);</span><br><span class="line">      <span class="type">HelloWorld</span> <span class="variable">obj</span> <span class="operator">=</span> (HelloWorld) context.getBean(<span class="string">&quot;helloWorld&quot;</span>);</span><br><span class="line">      obj.getMessage();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一步是在我们使用框架 API <strong>ClassPathXmlApplicationContext()</strong> 的地方<mark>创建应用程序上下文</mark>。 此 API 加载 bean 配置文件，并最终基于提供的 API，它负责创建和初始化所有对象，即配置文件中提到的 bean。</li>
<li>第二步用于<mark>使用创建的上下文的 <strong>getBean()</strong> 方法获取所需的 bean</mark>。 该方法使用 bean ID 返回一个通用对象，最终可以转换为实际对象。 一旦有了对象，就可以使用该对象调用任何类方法。</li>
</ul>
<h2 id="24bean配置文件"><a class="markdownIt-Anchor" href="#24bean配置文件"></a> 2.4Bean配置文件</h2>
<ul>
<li>
<p>该配置文件<mark>放置在src目录下</mark>即可</p>
<p>通常开发人员将此文件命名为 <strong>Beans.xml</strong>，必须确保该文件在 CLASSPATH 中可用，并在<mark>主应用程序中使用相同的名称</mark></p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version = <span class="string">&quot;1.0&quot;</span> encoding = <span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span> = <span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span> = <span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span> = <span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;helloWorld&quot;</span> <span class="attr">class</span> = <span class="string">&quot;com.tutorialspoint.HelloWorld&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">&quot;message&quot;</span> <span class="attr">value</span> = <span class="string">&quot;Hello World!&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="25运行程序"><a class="markdownIt-Anchor" href="#25运行程序"></a> 2.5运行程序</h2>
<p>运行MainApp程序，输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your Message : Hello World!</span><br></pre></td></tr></table></figure>
<h1 id="3spring-bean"><a class="markdownIt-Anchor" href="#3spring-bean"></a> 3.Spring Bean</h1>
<h2 id="31bean定义"><a class="markdownIt-Anchor" href="#31bean定义"></a> 3.1Bean定义</h2>
<p>简单来说，Bean 代指的就是那些<mark>被 IoC 容器所管理的对象</mark>。</p>
<p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p>
<h3 id="311元数据bean标签的属性"><a class="markdownIt-Anchor" href="#311元数据bean标签的属性"></a> 3.1.1元数据—&gt;Bean标签的属性</h3>
<ol>
<li>在IOC容器创建Bean对象时候，需要知道这三个信息
<ul>
<li>如何创建一个bean（class）</li>
<li>bean的生命周期</li>
<li>bean的依赖关系</li>
</ul>
</li>
</ol>
<p>所有配置元数据都转换为一组构成<mark>每个 bean 标签定义的<strong>以下属性</strong></mark>：</p>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"><strong>class</strong></td>
<td style="text-align:center">指定了用于创建 bean 的 bean类型</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"><strong>id或者name</strong></td>
<td style="text-align:center">唯一地指定 bean 标识符</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><strong>scope</strong></td>
<td style="text-align:center">指定从特定 <mark>bean 定义创建的对象的范围</mark></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center"><strong>constructor-arg</strong></td>
<td style="text-align:center">用于注入依赖关系</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center"><strong>properties</strong></td>
<td style="text-align:center">用于注入依赖关系</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center"><strong>autowiring mode</strong></td>
<td style="text-align:center">用于注入依赖关系</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center"><strong>lazy-initialization mode</strong></td>
<td style="text-align:center">延迟初始化的 bean，即 告诉 IoC 容器在第一次被请求时创建一个 bean 实例，而不是在启动时</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center"><strong>initialization method</strong></td>
<td style="text-align:center">在容器设置了 bean 上的所有必要属性之后<mark>调用的回调</mark></td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center"><strong>destruction method</strong></td>
<td style="text-align:center">包含 bean 的容器被销毁时要使用的回调</td>
</tr>
</tbody>
</table>
<h3 id="312配置的方式"><a class="markdownIt-Anchor" href="#312配置的方式"></a> 3.1.2配置的方式</h3>
<p>Spring IoC 容器与实际写入此配置元数据的格式完全分离。 以下是向 Spring 容器提供配置元数据的三个重要方法 −</p>
<ul>
<li><mark>基于 XML 的配置文件</mark>。（Spring）</li>
<li><mark>基于注解的配置</mark>（SpringBoot）</li>
<li>基于 Java 的配置</li>
</ul>
<h4 id="1xml方式"><a class="markdownIt-Anchor" href="#1xml方式"></a> （1）XML方式</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="type">bean</span> <span class="variable">id</span> <span class="operator">=</span> <span class="string">&quot;helloWorld&quot;</span> class = <span class="string">&quot;com.tutorialspoint.HelloWorld&quot;</span>&gt;</span><br><span class="line">      &lt;<span class="type">property</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;message&quot;</span> value = <span class="string">&quot;Hello World!&quot;</span>/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2注解方式"><a class="markdownIt-Anchor" href="#2注解方式"></a> （2）注解方式</h4>
<ol>
<li><code>@Component</code>：<mark>通用的注解</mark>，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : <mark>对应持久层即 Dao 层</mark>，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应<mark>服务层</mark>，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li>
<li><code>@Controller</code> : 对应 <mark>Spring MVC 控制层</mark>，主要用于接受用户请求并调用 <code>Service</code> 层返回数据给前端页面。</li>
</ol>
<h3 id="313component和bean的区别"><a class="markdownIt-Anchor" href="#313component和bean的区别"></a> 3.1.3@Component和@Bean的区别？</h3>
<ul>
<li>
<p>相同：两者都是用来声明一个Bean类，交给IOC容器处理</p>
</li>
<li>
<p>不同：</p>
<ol>
<li><mark><strong>作用的地方不同</strong></mark>：<mark>@Component 注解作用于类</mark>，而==@Bean注解作用于方法==。</li>
<li><mark><strong>产生的作用不同</strong></mark>：
<ol>
<li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。</li>
<li><code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li>
</ol>
</li>
<li><mark><strong>自定义强度不同</strong></mark>：
<ol>
<li><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强</li>
<li>很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们<mark>引用第三方库中的类需要装配到 <code>Spring</code>容器</mark>时，则只能通过 <code>@Bean</code>来实现</li>
</ol>
</li>
</ol>
</li>
</ul>
<h4 id="1bean使用示例"><a class="markdownIt-Anchor" href="#1bean使用示例"></a> （1）@Bean使用示例</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransferService <span class="title function_">transferService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransferServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码相当于下面的 xml 配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transferService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="32bean作用域"><a class="markdownIt-Anchor" href="#32bean作用域"></a> 3.2Bean作用域</h2>
<h3 id="321作用域分类"><a class="markdownIt-Anchor" href="#321作用域分类"></a> 3.2.1作用域分类</h3>
<ol>
<li><strong><mark>singleton</mark></strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是<mark>单例</mark>的，是对单例设计模式的应用。</li>
<li><strong><mark>prototype</mark></strong> : 每次获取都会<mark>创建一个新的 bean 实例</mark>。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li>
<li><strong><mark>request</mark></strong> （仅 Web 应用可用）: <mark>每一次 HTTP 请求都会产生一个新的 bean</mark>（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li>
<li><strong>session</strong> （仅 Web 应用可用） : <mark>每一次来自新 session 的 HTTP 请求都会产生一个新的 bean</mark>（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li>
<li><strong>application/global-session</strong> （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li>
<li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li>
</ol>
<h3 id="322配置作用域的方式"><a class="markdownIt-Anchor" href="#322配置作用域的方式"></a> 3.2.2配置作用域的方式</h3>
<h4 id="1xml方式-2"><a class="markdownIt-Anchor" href="#1xml方式-2"></a> （1）xml方式</h4>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2注解方式-2"><a class="markdownIt-Anchor" href="#2注解方式-2"></a> （2）注解方式</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">personPrototype</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="33bean生命周期"><a class="markdownIt-Anchor" href="#33bean生命周期"></a> 3.3Bean生命周期</h2>
<p>对于普通的 <mark>Java 对象</mark>来说，它们的生命周期就是：</p>
<ul>
<li>实例化</li>
<li>该对象不再被使用时通过垃圾回收机制进行回收</li>
</ul>
<p>对于 <mark>Spring Bean 的生命周期</mark>来说：</p>
<ol>
<li><mark>实例化bean</mark></li>
<li><mark>bean属性赋值</mark></li>
<li><mark>初始化bean</mark>
<ol>
<li>执行处理aware接口，分别调用 setBeanName()、setBeanFactory()、 setApplicationContext()方法</li>
<li>调用BeanPostProcessor的预初始化方法</li>
<li>调用<mark>InitializingBean的afterPropertiesSet()方法</mark></li>
<li>调用<mark>init-method属性指定初始化方法</mark></li>
<li>调用BeanPostProcessor的初始化后方法</li>
</ol>
</li>
<li><mark>使用bean</mark></li>
<li><mark>销毁bean</mark>
<ol>
<li>调用DisposableBean的destroy方法</li>
<li>调用destroy-method属性指定的方法</li>
</ol>
</li>
</ol>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b417365a73555679d3184200d05b607b.jpeg" alt="Spring Bean 生命周期" /></p>
<h3 id="331初始化回调"><a class="markdownIt-Anchor" href="#331初始化回调"></a> 3.3.1初始化回调</h3>
<h4 id="1initializingbean的afterpropertiesset方法"><a class="markdownIt-Anchor" href="#1initializingbean的afterpropertiesset方法"></a> （1）InitializingBean的afterPropertiesSet()方法</h4>
<p>org.springframework.beans.factory.InitializingBean 接口指定单个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure>
<p>可以简单地实现上述接口，并且可以在 afterPropertiesSet() 方法中完成初始化工作，如下所示 −</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// do some initialization work</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// do some initialization work</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2init-method属性指定初始化方法"><a class="markdownIt-Anchor" href="#2init-method属性指定初始化方法"></a> （2）init-method属性指定初始化方法</h4>
<p>基于 XML 的配置元数据的情况下，您可以使用 <strong>init-method</strong> 属性来指定具有 void 无参数签名的方法的名称。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span> = <span class="string">&quot;examples.ExampleBean&quot;</span> <span class="attr">init-method</span> = <span class="string">&quot;init&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>下面是类的定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// do some initialization work</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="332销毁回调"><a class="markdownIt-Anchor" href="#332销毁回调"></a> 3.3.2销毁回调</h3>
<h4 id="1disposablebean的destroy方法"><a class="markdownIt-Anchor" href="#1disposablebean的destroy方法"></a> （1）DisposableBean的destroy方法</h4>
<p><em>org.springframework.beans.factory.DisposableBean</em> 接口指定一个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure>
<p>因此，您可以简单地实现上述接口，并且可以在destroy() 方法中完成如下工作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> <span class="keyword">implements</span> <span class="title class_">DisposableBean</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// do some destruction work</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2destroy-method属性指定销毁方法"><a class="markdownIt-Anchor" href="#2destroy-method属性指定销毁方法"></a> （2）<strong>destroy-method</strong>属性指定销毁方法</h4>
<ul>
<li>xml配置文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span> = <span class="string">&quot;examples.ExampleBean&quot;</span> <span class="attr">destroy-method</span> = <span class="string">&quot;destroy&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>类的定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// do some destruction work</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="34bean依赖注入"><a class="markdownIt-Anchor" href="#34bean依赖注入"></a> 3.4Bean依赖注入</h2>
<h3 id="341定义"><a class="markdownIt-Anchor" href="#341定义"></a> 3.4.1定义</h3>
<ul>
<li><strong><mark>依赖</mark></strong>：<mark>bean对象的依赖于容器</mark></li>
<li><mark><strong>注入</strong></mark>：<mark>bean对象中的所有属性，由容器来注入</mark></li>
</ul>
<p>依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说<mark>你不用创建对</mark>象，而<mark>只需要描述它如何被创建</mark>。你不在代码里直接组装你的组件和服务，但是要<mark>在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来</mark>。</p>
<h3 id="342依赖注入的作用"><a class="markdownIt-Anchor" href="#342依赖注入的作用"></a> 3.4.2依赖注入的作用</h3>
<ol>
<li>
<p>作用：<mark>降低程序间的耦合</mark></p>
<p>依赖关系的管理，以后都交给spring来维护</p>
<p>在当前类需要用到其他类的对象，由spring为我们提供，我们<mark>只需要在配置文件中说明依赖关系的维护</mark>,就称之为依赖注入。</p>
</li>
</ol>
<h3 id="343依赖注入的方式"><a class="markdownIt-Anchor" href="#343依赖注入的方式"></a> 3.4.3依赖注入的方式</h3>
<ul>
<li>
<p>可以注入的数据（三类）：</p>
<ul>
<li>基本类型和String</li>
<li>其他bean类型（在配置文件中或者注解配置过的bean）</li>
<li>复杂类型/集合类型：（不演示）</li>
</ul>
</li>
<li>
<p><mark><strong>注入的方式（三种）</strong></mark>：十分重要</p>
<ul>
<li><mark>构造函数注入</mark></li>
<li><mark>set方法注入</mark></li>
<li><mark>基于xml的自动装配（bean标签的autowire属性（byName—&gt;根据bean标签的id属性查找、byType——&gt;根据bean标签的Class属性查找））</mark></li>
<li><mark>注解注入（）</mark></li>
</ul>
</li>
</ul>
<h4 id="1构造函数注入"><a class="markdownIt-Anchor" href="#1构造函数注入"></a> （1）构造函数注入</h4>
<ul>
<li>
<p>定义：用类中的构造函数，给成员变量赋值。注意，赋值的操作不是我们自己做的，而是通过配置的方式，让 spring 框架来为我们注入。</p>
</li>
<li>
<p>说明：</p>
<ul>
<li>使用的标签:<mark>constructor-arg</mark></li>
<li>标签出现的位置：bean标签的内部</li>
<li>标签中的属性：
<ul>
<li><mark>type</mark>：用于<mark>指定要注入的数据的数据类型</mark>，该数据类型也是构造函数中某个或某些参数的类型。</li>
<li><mark>index</mark>：用于<mark>指定要注入的数据给构造函数中指定索引位置的参数赋值</mark>。索引的位置是从0开始。</li>
<li><mark>name</mark>：用于指定给构造函数中指定名称的参数赋值。</li>
<li>ref：<mark>用于指定其他的bean类型数据</mark>。它指的就是在spring的Ioc核心容器中出现过的bean对象</li>
<li>value：要注入的数据</li>
</ul>
</li>
<li>优点：在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。</li>
<li>缺点：改变了bean对象的实例化方式，使得<mark>我们在创建对象时，如果用不到这些数据，也必须提供</mark>。</li>
</ul>
</li>
<li>
<p>举例</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--默认构造器方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--通过有参构造创建对象。方式一：下标赋值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jerry&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--通过有参构造创建对象。方式二：类型创建，不建议使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jarry&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--通过有参构造创建对象。方式三：通过参数名，推荐使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jarry&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;now&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置一个日期对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;now&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.util.Date&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2set方式注入常用"><a class="markdownIt-Anchor" href="#2set方式注入常用"></a> （2）Set方式注入（常用）</h4>
<ul>
<li>定义：在类中提供需要注入成员的 set 方法</li>
<li>说明：
<ul>
<li>涉及的标签：<mark>property</mark></li>
<li>出现的位置：bean标签的内部</li>
<li>标签的属性
<ul>
<li>name：用于指定注入时注入的对象的名称（IOC容器会调用该对象的set方法）</li>
<li>value：用于提供基本类型和String类型的数据</li>
<li><mark>ref：用于指定其他的bean类型数据</mark>。</li>
</ul>
</li>
<li>优势：创建对象时没有明确的限制，可以直接使用默认构造函数。</li>
<li>弊端：如果有某个成员必须有值，则获取对象是有可能set方法没有执行。</li>
</ul>
</li>
</ul>
<h4 id="3基于xml的自动装配"><a class="markdownIt-Anchor" href="#3基于xml的自动装配"></a> （3）基于xml的自动装配</h4>
<ul>
<li>定义：
<ul>
<li>自动装配是spring满足bean依赖注解一种方式</li>
<li>Spring会<mark>在上下文中自动寻找，并自动给bean装配属性</mark></li>
</ul>
</li>
<li>三种自动装配方式：
<ul>
<li><mark>在xmI中显示的配置</mark>（ByName、ByType）</li>
<li><mark>注解显示配置</mark></li>
<li><mark>隐式的自动装配bean 【重要】</mark></li>
</ul>
</li>
</ul>
<h5 id="1搭建环境"><a class="markdownIt-Anchor" href="#1搭建环境"></a> ①搭建环境</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;喵喵&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;旺旺&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;cat=&quot;</span> + cat +</span><br><span class="line">                <span class="string">&quot;, dog=&quot;</span> + dog +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//getting、setting</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2byname自动装配"><a class="markdownIt-Anchor" href="#2byname自动装配"></a> ②ByName自动装配</h5>
<ul>
<li>byName：会自动在容器上下文中查找，和<mark>自己对象set方法后面的值<strong>对应的beanId</strong></mark></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Person&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小海子&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="3bytype自动装配"><a class="markdownIt-Anchor" href="#3bytype自动装配"></a> ③ByType自动装配</h5>
<ul>
<li>byType：会自动在容器上下文中查找，<mark>和自己对象属性类型相同的bean</mark></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Person&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小海子&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="4小结"><a class="markdownIt-Anchor" href="#4小结"></a> ④小结</h5>
<ul>
<li>byname的时候，需要保证<mark>所有bean的id唯一</mark> ，并且这个bean需要和自动注入的属性的set方法的值一致。</li>
<li>bytype的时候， 需要保证<mark>所有bean的class唯一</mark> ，并且这个bean需要和自动注入的属性的类型一致；全局唯一，id属性可以省略。</li>
</ul>
<h4 id="4基于注解的自动装配"><a class="markdownIt-Anchor" href="#4基于注解的自动装配"></a> （4）基于注解的自动装配</h4>
<ul>
<li>
<p>jdk1.5支持的注解，Spring2.5支持注解</p>
</li>
<li>
<p>作用：和在xml配置文件中的bean标签中写一个标签的作用是一样</p>
</li>
<li>
<p>注解：</p>
<table>
<thead>
<tr>
<th style="text-align:center">注解</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">使用前提</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">@Autowired</td>
<td style="text-align:center">根据<mark>属性类型</mark>进行自动装配 <br/> 即通过<mark>byType——&gt;bean标签的class属性</mark>方式实现</td>
<td style="text-align:center">/</td>
</tr>
<tr>
<td style="text-align:center">@Qualifer</td>
<td style="text-align:center">根据<mark>属性名称</mark>（由@Component的value值指定）进行注入<br/>即通过<mark>byName——&gt;bean标签的id属性</mark>实现</td>
<td style="text-align:center">在该属性注入的基础上</td>
</tr>
<tr>
<td style="text-align:center">@Resource</td>
<td style="text-align:center">根据类型注入，可以根据名称注入（默认根据类型注入）</td>
<td style="text-align:center">/</td>
</tr>
<tr>
<td style="text-align:center">@Value</td>
<td style="text-align:center">注入普通类型属性</td>
<td style="text-align:center">/</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="344详讲autowired-qualifer-resource-value"><a class="markdownIt-Anchor" href="#344详讲autowired-qualifer-resource-value"></a> 3.4.4详讲@Autowired、@Qualifer、@Resource、@Value</h3>
<ul>
<li>spring的IOC底层实际上就是一个<strong>Map</strong>结构容器，所谓**<mark>key 就是 bean标签 中的 id</mark>，<mark>value 则是对应 bean标签 中的 class</mark>**</li>
</ul>
<h4 id="1autowired"><a class="markdownIt-Anchor" href="#1autowired"></a> （1）@Autowired</h4>
<h5 id="1用在何处"><a class="markdownIt-Anchor" href="#1用在何处"></a> ①用在何处？</h5>
<ol>
<li>Spring 2.5 引入了 @Autowired 注释，可以<mark>对类成员变量</mark>、<mark>方法</mark>及<mark>构造函数</mark>、参数等进行标注【<mark>主要还是用在<strong>变量</strong>和<strong>方法</strong>上</mark>】，完成自动装配的工作。</li>
<li>使用@Autowired注解注入的属性，<mark>该属性不需要这个类提供set方法</mark>，方便快捷</li>
<li>@Autowired作用就和在xml配置文件中的bean标签中写一个<code>&lt; property &gt;</code>标签的作用是一样的。</li>
<li>@Autowired自动装配首先会在IOC容器中跳<mark>过key直接去容器中找到对应的属性（bean标签中的Class）</mark>！也就是说与key无关</li>
</ol>
<h5 id="2三种情况"><a class="markdownIt-Anchor" href="#2三种情况"></a> ②三种情况</h5>
<ol>
<li>容器中有==唯一的一个bean对象类型（Class类路径）==和被@Autowired修饰的变量类型匹配，就可以注入成功！</li>
<li>容器中<mark>没有</mark>一个bean对象类型和被@Autowired修饰的变量类型匹配，则注入失败运行报错。</li>
<li>容器中有==<strong>多个</strong><mark>bean对象类型和被@Autowired修饰的变量类型匹配，则</mark>根据被@Autowired修饰的变量名寻找==，找到则注入成功【重点】</li>
</ol>
<h4 id="2qualifer"><a class="markdownIt-Anchor" href="#2qualifer"></a> （2）@Qualifer</h4>
<h5 id="1用在何处-2"><a class="markdownIt-Anchor" href="#1用在何处-2"></a> ①用在何处</h5>
<ol>
<li>@Qualifier的作用是<mark>在按照<strong>类中注入的基础之上</strong><mark>再</mark><strong>按照名称注入</strong></mark>。</li>
<li>它在给类成员注入时不能单独使用（但是在给方法参数注入时可以单独使用）</li>
<li><mark>@Qualifier常常组合@Autowired一起使用</mark>，用来==<strong>指明具体名字的自动装配</strong>==</li>
</ol>
<h5 id="2使用情况"><a class="markdownIt-Anchor" href="#2使用情况"></a> ②使用情况</h5>
<ul>
<li>UserDaoImpl2类</li>
</ul>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/dea865c75ac341c951cf0ca2bd4fd65f.png" alt="image-20240309170911266" /></p>
<ul>
<li>UserService3类注入UserDaoImpl2类</li>
</ul>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/72d528bb6e7bda29c5feeede343b1284.png" alt="image-20240309170941360" /></p>
<h4 id="3resource"><a class="markdownIt-Anchor" href="#3resource"></a> （3）@Resource</h4>
<ol>
<li>
<p>@Resource由J2EE提供，<mark>默认是按照byName自动注入（<strong>通过名字自动注入</strong>）</mark>，</p>
</li>
<li>
<p>@Resource有两个重要的属性，name和type</p>
<p>当然<mark>默认是通过name属性</mark></p>
<p>type属性多此一举，还不如用@Autowired</p>
</li>
<li>
<p><strong>@Resource 相当于 @Autowired + @Qualifier</strong></p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value=&quot;userDaoImpl2&quot;)</span></span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="meta">@Resource(name=&quot;userDaoImpl2&quot;)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="4value"><a class="markdownIt-Anchor" href="#4value"></a> （4）@Value</h4>
<ol>
<li>@Value专门用来<mark>注入基本类型和String类型数据</mark></li>
<li>@Value注解有一个<mark>value 属性</mark>：用于指定数据的值。它可以使用spring中SpEL(也就是spring的EL表达式）。SpEL的写法：${表达式}，当然也可以类似<mark>mybatis中的 #{表达式} 的写法</mark></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;2*3&#125;&quot;)</span>  <span class="comment">//#写法 表示6</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;178&quot;)</span>    <span class="comment">//普遍写法 178</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;man.weight&#125;&quot;)</span>  <span class="comment">//SpEL的写法一般操作配置文件中数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> weight;</span><br></pre></td></tr></table></figure>
<h4 id="5辨别autowired和resource的异同"><a class="markdownIt-Anchor" href="#5辨别autowired和resource的异同"></a> （5）辨别@Autowired和@Resource的异同</h4>
<ul>
<li>相同：两者都是用来自动装配的，都可以放在属性字段上</li>
<li>不同：
<ul>
<li><mark><strong>实现方式不同：</strong></mark>
<ul>
<li>@ Autowired 通过byType的方式实现</li>
<li>@Resource 默认通过byname的方式实现</li>
</ul>
</li>
<li><mark><strong>找的过程不同：</strong></mark>
<ul>
<li>若@ Autowired 通过byType的方式找不到，则报错</li>
<li>若@Resource 默认通过byname的方式找不到，则通过byType实现。如果两个都找不到的情况下，就报错。</li>
</ul>
</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>Spring框架上篇</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://www.haipeng-lin.cn/posts/b0e0901d.html">https://www.haipeng-lin.cn/posts/b0e0901d.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a" style="display: inline-block;width: 120px"><h>作者</h><div class="post-copyright-cc-info"><h>拾忆鱼</h></div></div><div class="post-copyright-c" style="display: inline-block;width: 120px"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-08-28</h></div></div><div class="post-copyright-u" style="display: inline-block;width: 120px"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-09-01</h></div></div><div class="post-copyright-c" style="display: inline-block;width: 120px"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i-blog.csdnimg.cn/blog_migrate/57e8a40e4a1ba3c2c85557044ffe1fe8.jpeg#pic_center" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/85cf778.html"><img class="prev-cover" src="https://i-blog.csdnimg.cn/blog_migrate/5f38d5fd97ce1c51a30548222f8f9724.jpeg#pic_center" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring框架下篇</div></div></a></div><div class="next-post pull-right"><a href="/posts/10fd8da2.html"><img class="next-cover" src="https://i-blog.csdnimg.cn/blog_migrate/078243f70aa2d275b1a0ced2768c8d57.jpeg#pic_center" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MyBatis-Plus框架学习</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410101530409.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">拾忆鱼</div><div class="author-info__description">一条菜鱼的小破站</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">60</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">小菜鱼正在从CSDN博客搬家，尽请期待　　      地址：<a target="_blank" rel="noopener" href="https://haipeng-lin.blog.csdn.net/">haipeng-lin.blog.csdn.net</a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1spring%E7%AE%80%E8%BF%B0"><span class="toc-text"> 1.Spring简述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E4%BB%80%E4%B9%88%E6%98%AFspring%E6%A1%86%E6%9E%B6"><span class="toc-text"> 1.1什么是Spring框架？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12spring%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="toc-text"> 1.2Spring的核心功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#121-ioc"><span class="toc-text"> 1.2.1 IOC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1ioc%E4%BB%8B%E7%BB%8D"><span class="toc-text"> （1）IOC介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC"><span class="toc-text"> （2）控制？反转？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#122-aop"><span class="toc-text"> 1.2.2 AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1aop%E4%BB%8B%E7%BB%8D"><span class="toc-text"> （1）AOP介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD"><span class="toc-text"> （2）专业术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3spring-aop%E5%92%8Caspectj-aop%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text"> （3）Spring AOP和AspectJ AOP有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E5%A4%9A%E4%B8%AA%E5%88%87%E9%9D%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6"><span class="toc-text"> （4）多个切面的执行顺序如何控制？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13spring%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="toc-text"> 1.3Spring的架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#131core%E5%AE%B9%E5%99%A8"><span class="toc-text"> 1.3.1Core容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#132%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E9%9B%86%E6%88%90"><span class="toc-text"> 1.3.2数据访问&#x2F;集成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#133web"><span class="toc-text"> 1.3.3Web</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134%E6%9D%82%E9%A1%B9"><span class="toc-text"> 1.3.4杂项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E6%90%AD%E5%BB%BAspring%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83"><span class="toc-text"> 2.搭建Spring项目环境</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E5%AE%89%E8%A3%85spring%E6%A1%86%E6%9E%B6%E5%BA%93"><span class="toc-text"> 2.1安装Spring框架库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E5%AF%BC%E5%85%A5%E6%A1%86%E6%9E%B6%E5%BA%93"><span class="toc-text"> 2.2导入框架库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E5%88%9B%E5%BB%BA%E7%B1%BB"><span class="toc-text"> 2.3创建类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24bean%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text"> 2.4Bean配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="toc-text"> 2.5运行程序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3spring-bean"><span class="toc-text"> 3.Spring Bean</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31bean%E5%AE%9A%E4%B9%89"><span class="toc-text"> 3.1Bean定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#311%E5%85%83%E6%95%B0%E6%8D%AEbean%E6%A0%87%E7%AD%BE%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text"> 3.1.1元数据—&gt;Bean标签的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#312%E9%85%8D%E7%BD%AE%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text"> 3.1.2配置的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1xml%E6%96%B9%E5%BC%8F"><span class="toc-text"> （1）XML方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F"><span class="toc-text"> （2）注解方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#313component%E5%92%8Cbean%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text"> 3.1.3@Component和@Bean的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1bean%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text"> （1）@Bean使用示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32bean%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text"> 3.2Bean作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#321%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%88%86%E7%B1%BB"><span class="toc-text"> 3.2.1作用域分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#322%E9%85%8D%E7%BD%AE%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text"> 3.2.2配置作用域的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1xml%E6%96%B9%E5%BC%8F-2"><span class="toc-text"> （1）xml方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F-2"><span class="toc-text"> （2）注解方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text"> 3.3Bean生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#331%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9B%9E%E8%B0%83"><span class="toc-text"> 3.3.1初始化回调</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1initializingbean%E7%9A%84afterpropertiesset%E6%96%B9%E6%B3%95"><span class="toc-text"> （1）InitializingBean的afterPropertiesSet()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2init-method%E5%B1%9E%E6%80%A7%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-text"> （2）init-method属性指定初始化方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#332%E9%94%80%E6%AF%81%E5%9B%9E%E8%B0%83"><span class="toc-text"> 3.3.2销毁回调</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1disposablebean%E7%9A%84destroy%E6%96%B9%E6%B3%95"><span class="toc-text"> （1）DisposableBean的destroy方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2destroy-method%E5%B1%9E%E6%80%A7%E6%8C%87%E5%AE%9A%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95"><span class="toc-text"> （2）destroy-method属性指定销毁方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34bean%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-text"> 3.4Bean依赖注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#341%E5%AE%9A%E4%B9%89"><span class="toc-text"> 3.4.1定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#342%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text"> 3.4.2依赖注入的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#343%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text"> 3.4.3依赖注入的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%B3%A8%E5%85%A5"><span class="toc-text"> （1）构造函数注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2set%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%85%A5%E5%B8%B8%E7%94%A8"><span class="toc-text"> （2）Set方式注入（常用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%9F%BA%E4%BA%8Exml%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-text"> （3）基于xml的自动装配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83"><span class="toc-text"> ①搭建环境</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2byname%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-text"> ②ByName自动装配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3bytype%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-text"> ③ByType自动装配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E5%B0%8F%E7%BB%93"><span class="toc-text"> ④小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-text"> （4）基于注解的自动装配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#344%E8%AF%A6%E8%AE%B2autowired-qualifer-resource-value"><span class="toc-text"> 3.4.4详讲@Autowired、@Qualifer、@Resource、@Value</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1autowired"><span class="toc-text"> （1）@Autowired</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E7%94%A8%E5%9C%A8%E4%BD%95%E5%A4%84"><span class="toc-text"> ①用在何处？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-text"> ②三种情况</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2qualifer"><span class="toc-text"> （2）@Qualifer</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E7%94%A8%E5%9C%A8%E4%BD%95%E5%A4%84-2"><span class="toc-text"> ①用在何处</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-text"> ②使用情况</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3resource"><span class="toc-text"> （3）@Resource</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4value"><span class="toc-text"> （4）@Value</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E8%BE%A8%E5%88%ABautowired%E5%92%8Cresource%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-text"> （5）辨别@Autowired和@Resource的异同</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/46ceb5bd.html" title="基于Redis实现用户活跃月/日排行榜"><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410291146967.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于Redis实现用户活跃月/日排行榜"/></a><div class="content"><a class="title" href="/posts/46ceb5bd.html" title="基于Redis实现用户活跃月/日排行榜">基于Redis实现用户活跃月/日排行榜</a><time datetime="2024-10-29T03:44:41.000Z" title="发表于 2024-10-29 11:44:41">2024-10-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8239deef.html" title="基于微信公众号+验证码实现微信登录"><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410282106730.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于微信公众号+验证码实现微信登录"/></a><div class="content"><a class="title" href="/posts/8239deef.html" title="基于微信公众号+验证码实现微信登录">基于微信公众号+验证码实现微信登录</a><time datetime="2024-10-28T13:05:25.000Z" title="发表于 2024-10-28 21:05:25">2024-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/172c1a2d.html" title="ElasticSearch学习笔记"><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410161138400.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ElasticSearch学习笔记"/></a><div class="content"><a class="title" href="/posts/172c1a2d.html" title="ElasticSearch学习笔记">ElasticSearch学习笔记</a><time datetime="2024-10-16T03:36:17.000Z" title="发表于 2024-10-16 11:36:17">2024-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/6982816f.html" title="RocketMQ学习笔记"><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410131719724.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RocketMQ学习笔记"/></a><div class="content"><a class="title" href="/posts/6982816f.html" title="RocketMQ学习笔记">RocketMQ学习笔记</a><time datetime="2024-10-13T09:17:30.000Z" title="发表于 2024-10-13 17:17:30">2024-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d1f540b5.html" title="收集 | 有情怀的网站"><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410111137749.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="收集 | 有情怀的网站"/></a><div class="content"><a class="title" href="/posts/d1f540b5.html" title="收集 | 有情怀的网站">收集 | 有情怀的网站</a><time datetime="2024-10-10T12:21:25.000Z" title="发表于 2024-10-10 20:21:25">2024-10-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer-left"><div class="footer-title"><span>拾忆鱼's Blog | </span><span class="footer-copyright">&copy;2024 By 拾忆鱼</span></div><div class="wordcount"></div><span>拾忆鱼 已经写了 262.3k 字，</span><span>好像写完一本 钱钟书 的 《围城》 了啊</span></div><div id="footer-right"><div class="footer_custom_text"><div id="runtime"></div></div><div class="footer-totop"><i class="fas fa-chevron-up" onclick="rmf.scrollToTop()"></i></div><div class="footer-info"><p>使用Hexo框架 | 基于butterfly修改 | 萌ICP备20240730号</p><!--a(title='湘公网安备 2023003198号' href='http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=2023003198')= '湘公网安备 2023003198号'--><!--a(title='湘ICP备2023003198号' href='https://beian.miit.gov.cn/')= '湘ICP备2023003198号'--></div><div class="footer-service"><a title="51LA" target="_blank" rel="noopener" href="https://www.51.la"><img alt="51LA" src="https://gitee.com/linhaipengg/md_-picture/raw/master/51la.png"/></a><a title="CC BY-NC-SA 4.0" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><img alt="CC BY-NC-SA 4.0" src="https://img.june-pj.cn/img/2024/01/16/cc.webp"/></a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.haipeng-lin.cn',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.haipeng-lin.cn',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/twikoo/1.4.18/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script data-pjax src="/gitcalendar/js/gitcalendar.js"></script><script data-pjax src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/js/swiper.min.js"></script><script src="/js/footer.js"></script><script type="text/javascript" src="/js/main.js"></script><script data-pjax type="text/javascript" src="/js/essay/essay.js"></script><script data-pjax type="text/javascript" src="/js/essay/waterfall.js"></script><link rel="stylesheet" href="/css/swiper.css"><script data-pjax src="/js/categoryBar/categoryBar.js"></script><link data-pjax defer="" rel="stylesheet" href="/css/categoryBar/heoMainColor.css"><link data-pjax defer="" rel="stylesheet" href="/css/categoryBar/categoryBar.css"><script type="text/javascript" src="/js/nav.js"></script><script src="/js/countup.js"></script><script data-pjax type="text/javascript" src="/js/memos/waterfall.min.js"></script><script data-pjax type="text/javascript" src="/js/memos/imgStatus.min.js"></script><script data-pjax type="text/javascript" src="/js/memos/lately.min.js"></script><script type="text/javascript" src="/js/memos/photo.js"></script><script type="text/javascript" src="/js/icat.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>