<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>力扣刷题 | 拾忆鱼's Blog</title><meta name="author" content="拾忆鱼"><meta name="copyright" content="拾忆鱼"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer" /><meta name="description" content="子串  1.和为K的子数组  1.1题目 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。 子数组是数组中元素的连续非空序列。  示例一：  12输入：nums &#x3D; [1,1,1], k &#x3D; 2输出：2  示例二：  12输入：nums &#x3D; [1,2,3], k &#x3D; 3输出：2  1.2解法：前缀和+哈希  1.2.1解法思路  核心思想：  使">
<meta property="og:type" content="article">
<meta property="og:title" content="力扣刷题">
<meta property="og:url" content="https://www.haipeng-lin.cn/posts/f7912a82.html">
<meta property="og:site_name" content="拾忆鱼&#39;s Blog">
<meta property="og:description" content="子串  1.和为K的子数组  1.1题目 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。 子数组是数组中元素的连续非空序列。  示例一：  12输入：nums &#x3D; [1,1,1], k &#x3D; 2输出：2  示例二：  12输入：nums &#x3D; [1,2,3], k &#x3D; 3输出：2  1.2解法：前缀和+哈希  1.2.1解法思路  核心思想：  使">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/linhaipengg/md_-picture/raw/master/%E7%AE%97%E6%B3%95.png">
<meta property="article:published_time" content="2024-08-29T03:33:35.000Z">
<meta property="article:modified_time" content="2024-09-01T01:41:08.058Z">
<meta property="article:author" content="拾忆鱼">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/linhaipengg/md_-picture/raw/master/%E7%AE%97%E6%B3%95.png"><link rel="shortcut icon" href="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410101530409.png"><link rel="canonical" href="https://www.haipeng-lin.cn/posts/f7912a82"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="msvalidate.01" content="7A691DA1ABC779E7F680EF66E1D934AA"/><meta name="google-site-verification"/><meta name="baidu-site-verification" content="XXXXX"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":250},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 拾忆鱼","link":"链接: ","source":"来源: 拾忆鱼's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '力扣刷题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-01 09:41:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/gitcalendar/css/gitcalendar.css"/><link rel="stylesheet" href="/css/tag_plugins.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/swiper.min.css"><script src="https://libs.baidu.com/jquery/2.1.4/jquery.min.js"></script><link rel="stylesheet" href="/css/tags.css"><link rel="stylesheet" href="/css/double_article.css"><link rel="stylesheet" href="/css/nav.css"><link rel="stylesheet" href="/css/essay_page.css"><script type="text/javascript" src="/js/echarts.min.js"></script><script type="text/javascript" src="/js/copy.js"></script><script src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><link rel="stylesheet" href="/css/copyright.css"><link rel="stylesheet" href="/css/progress_bar.css"><link rel="stylesheet" href="/css/footer.css"><link rel="stylesheet" href="/css/page.css"><link rel="stylesheet" href="/css/layout.css"><link rel="stylesheet" href="/css/color.css"><link rel="stylesheet" href="/css/cursors/cursors.css"><link rel="stylesheet" href="/css/fonts/font.css"><link rel="stylesheet" href="/css/about/about.css"><link rel="stylesheet" href="/css/about/careers.css"><link rel="stylesheet" href="/css/about/genshinimpact.css"><link rel="stylesheet" href="/css/about/hello-about.css"><link rel="stylesheet" href="/css/about/site.css"><link rel="stylesheet" href="/css/about/skills.css"><link rel="stylesheet" href="/css/photo.css"><link rel="stylesheet" href="/css/icat.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="拾忆鱼's Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410101530409.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives"><i class="fa-fw fas fa-archive"></i><span> 全部</span></a></li><li><a class="site-page child" href="/categories"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heart"></i><span> 空间</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/essay"><i class="fa-fw fas fa-comments"></i><span> 碎碎念</span></a></li><li><a class="site-page child" href="/collect"><i class="fa-fw fas fa-walking"></i><span> 足迹阁</span></a></li><li><a class="site-page child" href="/photo"><i class="fa-fw fas fa-images"></i><span> 照片墙</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about"><i class="fa-fw fas fa-address-card"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">拾忆鱼's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives"><i class="fa-fw fas fa-archive"></i><span> 全部</span></a></li><li><a class="site-page child" href="/categories"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heart"></i><span> 空间</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/essay"><i class="fa-fw fas fa-comments"></i><span> 碎碎念</span></a></li><li><a class="site-page child" href="/collect"><i class="fa-fw fas fa-walking"></i><span> 足迹阁</span></a></li><li><a class="site-page child" href="/photo"><i class="fa-fw fas fa-images"></i><span> 照片墙</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about"><i class="fa-fw fas fa-address-card"></i><span> 关于</span></a></div></div><center id="name-container"><a id="page-name" href="javascript:btf.scrollToDest(0, 500)">PAGE_NAME</a></center></div><div id="toggleButtons"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">力扣刷题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-29T03:33:35.000Z" title="发表于 2024-08-29 11:33:35">2024-08-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-01T01:41:08.058Z" title="更新于 2024-09-01 09:41:08">2024-09-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91/">【算法】</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="力扣刷题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="子串"><a class="markdownIt-Anchor" href="#子串"></a> <mark>子串</mark></h1>
<h1 id="1和为k的子数组"><a class="markdownIt-Anchor" href="#1和为k的子数组"></a> 1.和为K的子数组</h1>
<h2 id="11题目"><a class="markdownIt-Anchor" href="#11题目"></a> 1.1题目</h2>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p>
<p>子数组是数组中元素的连续非空序列。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1], k = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3], k = 3</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<h2 id="12解法前缀和哈希"><a class="markdownIt-Anchor" href="#12解法前缀和哈希"></a> 1.2解法：前缀和+哈希</h2>
<h3 id="121解法思路"><a class="markdownIt-Anchor" href="#121解法思路"></a> 1.2.1解法思路</h3>
<ul>
<li>核心思想：
<ul>
<li>使用前缀和的概念：对于数组中的任意连续子数组，可以通过计算前缀和来快速得到该子数组的和。</li>
<li>维护一个HashMap，其中键表示前缀和，值表示该前缀和出现的次数。</li>
<li>在遍历数组过程中，不断更新前缀和，并计算当前前缀和与目标值k的差值，然后查看HashMap中是否存在该差值，若存在，则表示存在和为k的子数组。</li>
</ul>
</li>
<li>代码解释：
<ul>
<li><code>count</code>：用于记录和为k的子数组的数量。</li>
<li><code>pre</code>：用于记录当前的前缀和。</li>
<li><code>mp</code>：HashMap，用于存储前缀和及其出现的次数。</li>
<li>遍历数组nums，对于每个元素：
<ul>
<li>更新前缀和pre，并计算当前前缀和与目标值k的差值。</li>
<li>若HashMap中存在该差值，则将该差值对应的出现次数累加到count中。</li>
<li>更新HashMap中当前前缀和的出现次数。</li>
</ul>
</li>
<li>最终返回count，即和为k的子数组的数量。</li>
</ul>
</li>
<li>举例如下：</li>
</ul>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240423090057786.png" alt="image-20240423090057786" /></p>
<h3 id="122代码实现"><a class="markdownIt-Anchor" href="#122代码实现"></a> 1.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">       <span class="type">int</span> pre=<span class="number">0</span>;      <span class="comment">//前缀和</span></span><br><span class="line">       Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();   <span class="comment">//存放key为前缀和，value为该前缀和出现的情况</span></span><br><span class="line">       map.put(<span class="number">0</span>,<span class="number">1</span>);   <span class="comment">//前缀和为0的情况有1种，即空数组</span></span><br><span class="line">       <span class="type">int</span> count=<span class="number">0</span>;    <span class="comment">//和为k的子数组的总数量</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           pre+=nums[i];</span><br><span class="line">           <span class="keyword">if</span>(map.containsKey(pre-k))&#123;</span><br><span class="line">               <span class="comment">//count 加上 map包含pre与k的差值（）</span></span><br><span class="line">               count+=map.get(pre-k);</span><br><span class="line">           &#125;</span><br><span class="line">           map.put(pre,map.getOrDefault(pre,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="2滑动窗口最大值"><a class="markdownIt-Anchor" href="#2滑动窗口最大值"></a> 2.滑动窗口最大值</h1>
<h2 id="21题目"><a class="markdownIt-Anchor" href="#21题目"></a> 2.1题目</h2>
<p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 <em>滑动窗口中的最大值</em> 。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<h2 id="22解法一暴力"><a class="markdownIt-Anchor" href="#22解法一暴力"></a> 2.2解法一：暴力</h2>
<h3 id="221暴力思路"><a class="markdownIt-Anchor" href="#221暴力思路"></a> 2.2.1暴力思路</h3>
<ul>
<li>遍历求出每个滑动窗口</li>
<li>并在每个滑动窗口求出最大值，并记录下来</li>
</ul>
<h3 id="222代码实现"><a class="markdownIt-Anchor" href="#222代码实现"></a> 2.2.2代码实现</h3>
<ul>
<li>注意：此暴力解法只能解决40个测试用例</li>
</ul>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240423153221756.png" alt="image-20240423153221756" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span>[] res=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">if</span>(nums.length&lt;k)&#123;</span><br><span class="line">           <span class="keyword">return</span> nums;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="type">int</span> start=i;</span><br><span class="line">           <span class="type">int</span> end=i+k-<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span>(end&gt;=nums.length)&#123;</span><br><span class="line">               <span class="comment">//避免越界</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           res[i]=max(nums,start,end);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">       <span class="type">int</span> max=nums[start];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=start+<span class="number">1</span>;i&lt;=end;i++)&#123;</span><br><span class="line">           max=Math.max(max,nums[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="23解法二双向队列"><a class="markdownIt-Anchor" href="#23解法二双向队列"></a> 2.3解法二：双向队列</h2>
<h3 id="231思路"><a class="markdownIt-Anchor" href="#231思路"></a> 2.3.1思路</h3>
<ul>
<li>使用双向队列存放数组元素对应的下标</li>
<li>队头对应的元素比队尾的大，若前遍历的数比队尾的值大，则需要弹出队尾值，直到队列重新满足从大到小的要求</li>
<li>刚开始遍历时，L 和 R 都为 0，有一个形成窗口的过程，<mark>此过程没有最大值</mark>，L 不动，R 向右移。当窗口大小形成时，L 和 R 一起向右移，每次移动时，<mark>判断队首的值的数组下标是否在 [L,R] 中</mark>，如果不在则需要弹出队首的值，当前窗口的最大值即为队首的数。</li>
</ul>
<blockquote>
<ul>
<li>举例：
<ul>
<li>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</li>
<li>输出：[3,3,5,5,6,7]</li>
</ul>
</li>
</ul>
<p>初始状态：L=R=0,队列:{}<br />
i=0,nums[0]=1。队列为空,直接加入。队列：{1}<br />
i=1,nums[1]=3。队尾值为1，<mark>3&gt;1，弹出队尾值</mark>，加入3。队列：{3}<br />
i=2,nums[2]=-1。队尾值为3，-1&lt;3，直接加入。队列：{3,-1}。此时窗口已经形成，L=0,R=2，result=[3]（取队头）<br />
i=3,nums[3]=-3。队尾值为-1，-3&lt;-1，直接加入。队列：{3,-1,-3}。队首3对应的下标为1，L=1,R=3，有效。result=[3,3]（取队头）<br />
i=4,nums[4]=5。队尾值为-3，5&gt;-3，依次弹出后加入。队列：{5}。此时L=2,R=4，有效。result=[3,3,5]<br />
i=5,nums[5]=3。队尾值为5，3&lt;5，直接加入。队列：{5,3}。此时L=3,R=5，有效。result=[3,3,5,5]<br />
i=6,nums[6]=6。队尾值为3，6&gt;3，依次弹出后加入。队列：{6}。此时L=4,R=6，有效。result=[3,3,5,5,6]<br />
i=7,nums[7]=7。队尾值为6，7&gt;6，弹出队尾值后加入。队列：{7}。此时L=5,R=7，有效。result=[3,3,5,5,6,7]</p>
</blockquote>
<h3 id="232代码实现"><a class="markdownIt-Anchor" href="#232代码实现"></a> 2.3.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(nums==<span class="literal">null</span> || nums.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> nums;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span>[] res=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">       LinkedList&lt;Integer&gt; deque=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();   <span class="comment">//双向队列，存放元素对应的下标</span></span><br><span class="line">       <span class="comment">//1、遍历整个nums数组</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[i]&gt;nums[deque.peekLast()])&#123;</span><br><span class="line">               <span class="comment">//2、若当前元素大于队尾元素，则需要去掉队尾元素，保持队头到队尾（大到小）</span></span><br><span class="line">               deque.pollLast();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//3、加进队尾</span></span><br><span class="line">           deque.addLast(i);</span><br><span class="line">           <span class="comment">//4、判断当前队列中队首的值是否有效</span></span><br><span class="line">           <span class="keyword">if</span>(deque.peek()&lt;=i-k)&#123;</span><br><span class="line">               deque.poll();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//5、判断是否到达滑动窗口</span></span><br><span class="line">           <span class="keyword">if</span>(i+<span class="number">1</span>&gt;=k)&#123;</span><br><span class="line">               res[i+<span class="number">1</span>-k]=nums[deque.peek()];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="二分查找"><a class="markdownIt-Anchor" href="#二分查找"></a> <mark>二分查找</mark></h1>
<h1 id="3寻找两个正序数组的中位数"><a class="markdownIt-Anchor" href="#3寻找两个正序数组的中位数"></a> 3.寻找两个正序数组的中位数</h1>
<h2 id="31题目"><a class="markdownIt-Anchor" href="#31题目"></a> 3.1题目</h2>
<p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>
<p>算法的时间复杂度应该为 <mark><code>O(log (m+n))</code></mark> 。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure>
<h2 id="32解法暴力归并排序"><a class="markdownIt-Anchor" href="#32解法暴力归并排序"></a> 3.2解法：暴力（归并排序）</h2>
<ul>
<li>题目既然给出了两个正序数组，我们可以将这两个正序数组合成为一个正序的数组</li>
<li>判断合成后的数组的长度为奇数还是偶数，进而求出中位数</li>
<li>归并排序的<mark>时间复杂度为 O(m+n)、空间复杂度为 O(m+n)</mark></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="comment">// 合成的数组</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len1+len2];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 归并排序合成部分</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;len1&amp;&amp;right&lt;len2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[left]&lt;nums2[right]) &#123;</span><br><span class="line">                res[index++] = nums1[left++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[index++] = nums2[right++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断nums1剩余还是nums2剩余，并将剩余部分加入到合成的数组之后</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;len1) &#123;</span><br><span class="line">            res[index++] = nums1[left++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;len2) &#123;</span><br><span class="line">            res[index++] = nums2[right++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断合成后的数组的长度，求出中位数。返回的是double类型</span></span><br><span class="line">        <span class="keyword">if</span>((len1+len2)%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>) res[(len1+len2)/<span class="number">2</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>) (res[(len1+len2)/<span class="number">2</span>]+res[(len1+len2)/<span class="number">2</span>-<span class="number">1</span>])/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="33解法二分法"><a class="markdownIt-Anchor" href="#33解法二分法"></a> 3.3解法：二分法</h2>
<ol>
<li>
<p><mark>暴力解法对于本题来说不满足时间复杂度</mark>，要求时间复杂度为<code>O(log(m+n))</code>，所以自然想到了二分法。</p>
</li>
<li>
<p>理解：</p>
<ol>
<li>两个数组长度为奇数，则中位数即为第 (m+n)/2+1 小 元素；</li>
<li>两个数组长度为偶数，则中位数即为第 (m+n)/2 小元素 和 第 (m+n)/2+1 小元素；</li>
</ol>
</li>
<li>
<p>归纳：如何求出两个数组中第k小的元素？</p>
<ol>
<li>
<p>首先需要找到 第一个数组中的k/2位置、第二个数组的k/2位置；</p>
</li>
<li>
<p>如果 <mark><strong>nums1[k/2] &lt; nums2[k/2]</strong></mark> ，则 nums1[k/2]及其前面的元素均不是第k小，所以我们应该从 <mark>nums1[k/2+1] 到末尾，以及nums2中查找</mark></p>
<ol>
<li>
<p>why？</p>
</li>
<li>
<p>理由：比nums1[k/2]小的数字有 k/2-1个，比nums2[k/2]小的数字有 k/2-1个；</p>
<p>又又 nums1[k/2] &lt; nums2[k/2]</p>
<p>即 比nums2[k/2]小的数字最小有 （k/2-1）+（k/2-1）+1= k-1个</p>
<p>即nums1[k/2]最多是第k-1个数，它及其前面的肯定不是第k个数，所以需要去掉</p>
</li>
</ol>
</li>
<li>
<p>如果==<strong>nums1[k/2] &gt; nums2[k/2]</strong>==，则 nums2[k/2]及其后面的元素均不是第k小，所以我们应该从 <mark>nums1 以及 nums2[k/2+1]到末尾中查找</mark></p>
</li>
</ol>
</li>
<li>
<p>例子：</p>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240412170933717.png" alt="image-20240412170933717" /></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> (n + m + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> (n + m + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。</span></span><br><span class="line">    <span class="keyword">return</span> (getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, left) + getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, right)) * <span class="number">0.5</span>;  </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getKth</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> start1, <span class="type">int</span> end1, <span class="type">int</span>[] nums2, <span class="type">int</span> start2, <span class="type">int</span> end2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> end1 - start1 + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> end2 - start2 + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1 </span></span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len2) <span class="keyword">return</span> getKth(nums2, start2, end2, nums1, start1, end1, k);</span><br><span class="line">    <span class="keyword">if</span> (len1 == <span class="number">0</span>) <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> Math.min(nums1[start1], nums2[start2]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start1 + Math.min(len1, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> start2 + Math.min(len2, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">        <span class="keyword">return</span> getKth(nums1, start1, end1, nums2, j + <span class="number">1</span>, end2, k - (j - start2 + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getKth(nums1, i + <span class="number">1</span>, end1, nums2, start2, end2, k - (i - start1 + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> <mark>双指针</mark></h1>
<h1 id="1移动零"><a class="markdownIt-Anchor" href="#1移动零"></a> 1.移动零</h1>
<h2 id="11题目-2"><a class="markdownIt-Anchor" href="#11题目-2"></a> 1.1题目</h2>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure>
<h2 id="12解法双指针"><a class="markdownIt-Anchor" href="#12解法双指针"></a> 1.2解法：双指针</h2>
<h3 id="121双指针思路"><a class="markdownIt-Anchor" href="#121双指针思路"></a> 1.2.1双指针思路</h3>
<ul>
<li>使用快慢指针：
<ul>
<li>若快指针指向非0的数，则与慢指针交换数，快慢指针同时向前移动</li>
<li>若快指针指向0的数，则移动快指针即可，慢指针不能移动</li>
<li>确保0的数可以换到最后面</li>
</ul>
</li>
</ul>
<h3 id="122代码实现-2"><a class="markdownIt-Anchor" href="#122代码实现-2"></a> 1.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> len=nums.length;</span><br><span class="line">       <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(right&lt;len)&#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//1、若右指针指向的值不为空，则和左指针交换</span></span><br><span class="line">           <span class="keyword">if</span>(nums[right]!=<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="type">int</span> tmp=nums[left];</span><br><span class="line">               nums[left]=nums[right];</span><br><span class="line">               nums[right]=tmp;</span><br><span class="line">               left++;</span><br><span class="line">           &#125;</span><br><span class="line">           right++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="2盛最多水的容器"><a class="markdownIt-Anchor" href="#2盛最多水的容器"></a> 2.盛最多水的容器</h1>
<h2 id="21题目-2"><a class="markdownIt-Anchor" href="#21题目-2"></a> 2.1题目</h2>
<p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>
<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p>**说明：**你不能倾斜容器。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<h2 id="22解法双指针"><a class="markdownIt-Anchor" href="#22解法双指针"></a> 2.2解法：双指针</h2>
<h3 id="221双指针思路"><a class="markdownIt-Anchor" href="#221双指针思路"></a> 2.2.1双指针思路</h3>
<ul>
<li>使用左右指针，每次先取左右指针指向的元素的最小值，计算出面积值</li>
<li>再更新面积值（和之前的比较，取最大值）</li>
<li>哪个小，则移动哪个指针</li>
</ul>
<h3 id="222代码实现-2"><a class="markdownIt-Anchor" href="#222代码实现-2"></a> 2.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> len=height.length;</span><br><span class="line">       <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> right=len-<span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> max=Integer.MIN_VALUE;</span><br><span class="line">       <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">           <span class="type">int</span> area=Math.min(height[left],height[right])*(right-left);</span><br><span class="line">           max=Math.max(max,area);</span><br><span class="line">           <span class="keyword">if</span>(height[left]&lt;height[right])&#123;</span><br><span class="line">               <span class="comment">//每次移动较小的指针</span></span><br><span class="line">               left++;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               right--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> <mark>数组</mark></h1>
<h1 id="1二分查找"><a class="markdownIt-Anchor" href="#1二分查找"></a> 1.二分查找</h1>
<h2 id="11题目-3"><a class="markdownIt-Anchor" href="#11题目-3"></a> 1.1题目</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/description/">704.二分查找—力扣题目链接</a></p>
<ul>
<li>题目：给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</li>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure>
<h2 id="12思路核心区间的定义"><a class="markdownIt-Anchor" href="#12思路核心区间的定义"></a> 1.2思路（核心：区间的定义）</h2>
<ol>
<li><strong>题目的前提是数组为<mark>有序</mark>数组</strong>，同时题目还强调**<mark>数组中无重复元素</mark>**</li>
<li>因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。</li>
</ol>
<h2 id="13左闭右闭"><a class="markdownIt-Anchor" href="#13左闭右闭"></a> 1.3左闭右闭</h2>
<ul>
<li>定义target在==<strong>[left, right]</strong>==区间，所以有如下两点：</li>
</ul>
<ol>
<li>while (left &lt;= right) 要使用 &lt;= ，因为<mark>left == right是有意义</mark>的，所以使用 &lt;=</li>
<li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，<mark>因为当前这个nums[middle]一定不是target</mark>，那么接下来要查找的左区间结束下标位置就是 middle - 1</li>
<li>下面举例演示：在一组有序，不重复数组中分别查找数据2、数据6的过程</li>
</ol>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240310152650608.png" alt="image-20240310152650608" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 二分查找第一种写法：左闭右闭</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span> 下标值：int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch1</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *  写法一：可能出现溢出情况</span></span><br><span class="line"><span class="comment">             *      int mid=(left+right)/2;</span></span><br><span class="line"><span class="comment">             *  写法二：</span></span><br><span class="line"><span class="comment">             *      int mid=left+(right-left)/2;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//写法三：右移运算符 代替 除号</span></span><br><span class="line">            <span class="type">int</span> mid=left+((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(arr[mid]&gt;target)&#123;        <span class="comment">//在左区间，即[left,mid-1]</span></span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid]&lt;target)&#123;  <span class="comment">//在右区间，即[mid+1,right]</span></span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(log n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="14左闭右开"><a class="markdownIt-Anchor" href="#14左闭右开"></a> 1.4左闭右开</h2>
<p>如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p>
<ol>
<li><mark>while (left &lt; right)</mark>，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li>
<li><mark>if (nums[middle] &gt; target) right 更新为 middle</mark>，因为当前nums[middle]大于target，去<mark>左区间</mark>继续寻找，而<mark>寻找区间是左闭右开区间</mark>，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li>
</ol>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240310155356483.png" alt="image-20240310155356483" /></p>
<ul>
<li>代码示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 二分查找第一种写法：左闭右闭</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Return</span> 下标值：int</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch2</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">       <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> right=arr.length;</span><br><span class="line">       <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">           </span><br><span class="line">           <span class="type">int</span> mid=left+((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">           <span class="keyword">if</span>(arr[mid]&gt;target)&#123;        <span class="comment">//在左区间，即[left,mid-1)</span></span><br><span class="line">               right=mid;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid]&lt;target)&#123;  <span class="comment">//在右区间，即[mid+1,righ)</span></span><br><span class="line">               left=mid+<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> mid;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(log n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="15总结"><a class="markdownIt-Anchor" href="#15总结"></a> 1.5总结</h2>
<ul>
<li>使用二分查找的两个前提：
<ul>
<li>数组有序</li>
<li>数组元素唯一，不重复</li>
</ul>
</li>
<li>二分查找的两个写法区分：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">左闭右闭</th>
<th style="text-align:center">左闭右开</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">right初始取值</td>
<td style="text-align:center">right=arr.length-1</td>
<td style="text-align:center">right=arr.length</td>
</tr>
<tr>
<td style="text-align:center">循环条件</td>
<td style="text-align:center">while(left&lt;=right)</td>
<td style="text-align:center">while(left&lt;right)</td>
</tr>
<tr>
<td style="text-align:center">left更新值（到右区间查找）</td>
<td style="text-align:center">left=mid+1</td>
<td style="text-align:center">left=mid+1</td>
</tr>
<tr>
<td style="text-align:center">right更新值（到左区间查找）</td>
<td style="text-align:center">right=mid-1</td>
<td style="text-align:center">right=mid</td>
</tr>
</tbody>
</table>
<h1 id="2移除元素"><a class="markdownIt-Anchor" href="#2移除元素"></a> 2.移除元素</h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/description/">27.移除元素_力扣链接</a></p>
<h2 id="21题目-3"><a class="markdownIt-Anchor" href="#21题目-3"></a> 2.1题目</h2>
<p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<ul>
<li>示例1：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例2：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,3,0,4]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<h2 id="21思路"><a class="markdownIt-Anchor" href="#21思路"></a> 2.1思路</h2>
<h3 id="221暴力解法"><a class="markdownIt-Anchor" href="#221暴力解法"></a> 2.2.1暴力解法</h3>
<p>两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95.gif" alt="27.移除元素-暴力解法" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> total=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==val)&#123;</span><br><span class="line">                <span class="comment">//发现该val值，将该位置后面的数组都往前移动一位</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                    nums[j-<span class="number">1</span>]=nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                i--;<span class="comment">//结束内层循环后，执行i++命令，但是原来的nums[i+1]位置上的元素已经被覆盖为nums[i+2]</span></span><br><span class="line">                total++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length-total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="222双指针法"><a class="markdownIt-Anchor" href="#222双指针法"></a> 2.2.2双指针法</h3>
<ul>
<li>定义：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新 新数组下标的位置</li>
</ul>
</li>
<li>演示：</li>
</ul>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif" alt="27.移除元素-双指针法" /></p>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> total=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//快慢指针</span></span><br><span class="line">        <span class="type">int</span> slowIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> fastIndex=<span class="number">0</span>;fastIndex&lt;nums.length;fastIndex++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fastIndex]!=val)&#123;</span><br><span class="line">                <span class="comment">//将快指针的值赋予慢指针的值，并同时向前移动</span></span><br><span class="line">                nums[slowIndex]=nums[fastIndex];</span><br><span class="line">                slowIndex++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//找到该值，暂停慢指针</span></span><br><span class="line">                total++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length-total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意这些实现方法并没有改变元素的相对位置！
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
</li>
</ul>
<h2 id="23总结"><a class="markdownIt-Anchor" href="#23总结"></a> 23总结</h2>
<p><strong>双指针法（快慢指针法）在<mark>数组和链表</mark>的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</strong></p>
<h1 id="3有序数组的平方"><a class="markdownIt-Anchor" href="#3有序数组的平方"></a> 3.有序数组的平方</h1>
<h2 id="31题目-2"><a class="markdownIt-Anchor" href="#31题目-2"></a> 3.1题目</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">977.有序数组的平方——力扣题目链接</a></p>
<p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure>
<h2 id="32思路"><a class="markdownIt-Anchor" href="#32思路"></a> 3.2思路</h2>
<h3 id="321暴力解法"><a class="markdownIt-Anchor" href="#321暴力解法"></a> 3.2.1暴力解法</h3>
<ul>
<li>遍历数组，将数组的每个元素平方，接着排个序即可</li>
</ul>
<h3 id="322双指针法"><a class="markdownIt-Anchor" href="#322双指针法"></a> 3.2.2双指针法</h3>
<ul>
<li>
<p>原数组是==<strong>有序</strong>==的，就是说数字0的左区间（平方后的元素，越左边，越大）、右区间（平方后的元素，越右边，越大）</p>
</li>
<li>
<p>由此可以得出<mark>平方后的数组最大值不是在原数组最左边，就是最右边</mark></p>
</li>
<li>
<p>考虑双指针法了，i指向起始位置，j指向终止位置</p>
</li>
<li>
<p>示意图：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif" alt="img" /></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//思路：原数组有序，那最大值不是在最左边，就是在最右边</span></span><br><span class="line">        <span class="comment">//双指针：分别指向最左边和最右边，并新建一个数组，将最大值移向数组的最后面</span></span><br><span class="line">        <span class="type">int</span> len=nums.length;</span><br><span class="line">        <span class="type">int</span> j=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> k=nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=j;i++)&#123;      <span class="comment">//循环条件 i&lt;=j，最后要处理最后一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]*nums[i]&gt;nums[j]*nums[j])&#123;</span><br><span class="line">                <span class="comment">// i位置的元素的绝对值大</span></span><br><span class="line">                arr[k--]=nums[i]*nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// j位置的元素的绝对值大</span></span><br><span class="line">                arr[k--]=nums[j]*nums[j];</span><br><span class="line">                i--;    <span class="comment">//i保持不动</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4长度最小的子数组"><a class="markdownIt-Anchor" href="#4长度最小的子数组"></a> 4.长度最小的子数组</h1>
<h2 id="41题目"><a class="markdownIt-Anchor" href="#41题目"></a> 4.1题目</h2>
<p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p>
<p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度**。**如果不存在符合条件的子数组，返回 <code>0</code> 。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<ul>
<li>示例三：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<h2 id="42思路"><a class="markdownIt-Anchor" href="#42思路"></a> 4.2思路</h2>
<h3 id="421暴力解法"><a class="markdownIt-Anchor" href="#421暴力解法"></a> 4.2.1暴力解法</h3>
<ul>
<li>解法一：暴力解法，两层for循环，第一层为子序列的起始位置，第二层为子序列的终点位置</li>
<li>在第二层中，逐渐累加子序列的值，若发现&gt;=target，则与原来的子序列长度比较，是否需要替换</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> min=Integer.MAX_VALUE;  <span class="comment">//子序列的值</span></span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;     <span class="comment">//i为起始位置</span></span><br><span class="line">            sum=<span class="number">0</span>;                          <span class="comment">//重置sum=0</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;nums.length;j++)&#123; <span class="comment">//j为终点位置</span></span><br><span class="line">                sum+=nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;=target)&#123;</span><br><span class="line">                    min=min&gt;(j-i+<span class="number">1</span>)?(j-i+<span class="number">1</span>):min;    <span class="comment">//更新子序列的长度</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min==Integer.MAX_VALUE?<span class="number">0</span>:min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="422滑动窗口双指针升级"><a class="markdownIt-Anchor" href="#422滑动窗口双指针升级"></a> 4.2.2滑动窗口（双指针升级）</h3>
<ul>
<li>解法二：滑动窗口
<ul>
<li>问题：如何使用一个for循环，就能确定子序列的起始、终点位置</li>
<li>解决==：动态更改子序列的起始位置==，<mark>for循环确定子序列的终点位置</mark></li>
<li>只要当sum&gt;=target，第一更新子序列长度的值，第二滑动子序列的起始位置（先更新子序列总和，再滑动）</li>
<li><img src="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" alt="209.长度最小的子数组" /></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> min=Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;                                <span class="comment">//i为起始位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;         <span class="comment">//j为终点位置</span></span><br><span class="line">            sum+=nums[j];</span><br><span class="line">            <span class="keyword">while</span>(sum&gt;=target)&#123;</span><br><span class="line">                <span class="comment">//1、更新子序列的长度</span></span><br><span class="line">                min=min&gt;(j-i+<span class="number">1</span>)?(j-i+<span class="number">1</span>):min;</span><br><span class="line">                <span class="comment">//2、滑动起始位置：先减去初始位置的值，再滑动</span></span><br><span class="line">                sum-=nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min==Integer.MAX_VALUE?<span class="number">0</span>:min;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5螺旋矩阵2"><a class="markdownIt-Anchor" href="#5螺旋矩阵2"></a> 5.螺旋矩阵2</h1>
<h2 id="51题目"><a class="markdownIt-Anchor" href="#51题目"></a> 5.1题目</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></p>
<p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>
<ul>
<li>
<p>示例一：</p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img" /></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>
<h2 id="52思路"><a class="markdownIt-Anchor" href="#52思路"></a> 5.2思路</h2>
<ul>
<li>
<p>每次赋值可分为4次：上、右、下、左</p>
</li>
<li>
<p>首先明确每次赋值，确保都是==<strong>左闭右开</strong>==（即1 2；3 4；5 6；7 8）</p>
</li>
</ul>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220922102236.png" alt="img" /></p>
<ul>
<li><mark><strong>循环的圈数</strong></mark>：loop=n/2；n为3时循环一圈；n为4时循环两圈</li>
<li>若==<strong>n为奇数</strong>==，则最后中间还有个值，arr(n/2)(n/2)</li>
<li>每次循环过后，<mark>右边界都要缩小一格</mark></li>
<li>注意每次循环过后，<mark>起始点的位置！！！</mark></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> loop=n/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] arr=<span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;                <span class="comment">//每次循环的开始点（start,start）</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> offset=<span class="number">1</span>;               <span class="comment">//每次循环右边界收缩一位，控制每条边的遍历长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;loop;k++)&#123;    <span class="comment">//k表示正在循环的圈数</span></span><br><span class="line"></span><br><span class="line">            i=start;                <span class="comment">//更新起始点</span></span><br><span class="line">            j=start;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//上：从左到右</span></span><br><span class="line">            <span class="keyword">for</span>(j=start;j&lt;n-offset;j++)&#123;</span><br><span class="line">                arr[i][j]=count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//右：从上到下</span></span><br><span class="line">            <span class="keyword">for</span>(i=start;i&lt;n-offset;i++)&#123;</span><br><span class="line">                arr[i][j]=count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//下：从右到左</span></span><br><span class="line">            <span class="keyword">for</span>(;j&gt;start;j--)&#123;</span><br><span class="line">                arr[i][j]=count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//左：从下到上</span></span><br><span class="line">            <span class="keyword">for</span>(;i&gt;start;i--)&#123;</span><br><span class="line">                arr[i][j]=count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            start++;    <span class="comment">//循环起始点加一</span></span><br><span class="line">            offset++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            arr[n/<span class="number">2</span>][n/<span class="number">2</span>] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="链表"><a class="markdownIt-Anchor" href="#链表"></a> <mark>链表</mark></h1>
<h1 id="1移除元素"><a class="markdownIt-Anchor" href="#1移除元素"></a> 1.移除元素</h1>
<h2 id="11题目-4"><a class="markdownIt-Anchor" href="#11题目-4"></a> 1.1题目</h2>
<p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<ul>
<li>
<p>示例一：</p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img" /></p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>示例二：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [], val = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>示例三：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [7,7,7,7], val = 7</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="12思路"><a class="markdownIt-Anchor" href="#12思路"></a> 1.2思路</h2>
<ul>
<li>核心解法分为两种方式：
<ul>
<li>因为需要考虑头节点head需要删除时</li>
<li>所以一共有两种方法：<mark>删除头节点</mark>，或者<mark>添加虚拟头节点</mark></li>
</ul>
</li>
</ul>
<h3 id="121方法一删除头节点"><a class="markdownIt-Anchor" href="#121方法一删除头节点"></a> 1.2.1方法一：删除头节点</h3>
<h4 id="1使用pre-cur两个节点实现删除逻辑"><a class="markdownIt-Anchor" href="#1使用pre-cur两个节点实现删除逻辑"></a> （1）使用pre、cur两个节点实现删除逻辑</h4>
<ul>
<li>pre为当前安全的最后一个节点</li>
<li>cur为探测当前节点是否安全</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除头节点</span></span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">null</span> &amp;&amp; head.val==val)&#123;</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode pre=head;          <span class="comment">//pre为当前安全的最后一个节点</span></span><br><span class="line">        ListNode cur=head.next;     <span class="comment">//cur为探测当前节点是否安全</span></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val==val)&#123;</span><br><span class="line">                pre.next=cur.next;	<span class="comment">//跳过该节点</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre=cur;			<span class="comment">//该节点安全，pre往后移</span></span><br><span class="line">            &#125;</span><br><span class="line">            cur=cur.next;   		<span class="comment">//探测节点往后移动一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2使用curr一个节点实现删除逻辑"><a class="markdownIt-Anchor" href="#2使用curr一个节点实现删除逻辑"></a> （2）使用curr一个节点实现删除逻辑</h4>
<ul>
<li>curr为最后一个安全的节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">null</span> &amp;&amp; head.val==val)&#123;</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode curr=head; <span class="comment">//curr为当前最后一个安全的节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.next!=<span class="literal">null</span> &amp;&amp; curr.next.val==val)&#123;</span><br><span class="line">                curr.next=curr.next.next;   <span class="comment">//不安全，跳过下一个节点</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr=curr.next;             <span class="comment">//安全，跳到下一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="122方法二虚拟头节点"><a class="markdownIt-Anchor" href="#122方法二虚拟头节点"></a> 1.2.2方法二：虚拟头节点</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//分为两种方式：当头节点head的val需要删除时，两种方法：删除头节点，或者添加虚拟头节点</span></span><br><span class="line">        <span class="comment">//第二种：使用虚拟节点、删除逻辑使用pre、cur实现</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>,head);</span><br><span class="line">        </span><br><span class="line">        ListNode pre=dummy;     	<span class="comment">//pre为最后一个安全节点</span></span><br><span class="line">        ListNode cur=head;      	<span class="comment">//cur为探测节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val==val)&#123;</span><br><span class="line">                pre.next=cur.next;  <span class="comment">//跳过该节点</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre=cur;            <span class="comment">//pre跳到最后一个安全节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            cur=cur.next;           <span class="comment">//探测节点移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2反转链表"><a class="markdownIt-Anchor" href="#2反转链表"></a> 2.反转链表</h1>
<h2 id="21题目-4"><a class="markdownIt-Anchor" href="#21题目-4"></a> 2.1题目</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/description/">206.反转链表——力扣链接</a></p>
<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure>
<h2 id="22解法"><a class="markdownIt-Anchor" href="#22解法"></a> 2.2解法</h2>
<ul>
<li>一共有两种解法：双指针法、递归法</li>
</ul>
<h3 id="221双指针法"><a class="markdownIt-Anchor" href="#221双指针法"></a> 2.2.1双指针法</h3>
<ol>
<li>定义两个指针pre和cur
<ul>
<li>pre初始化为Null</li>
<li>cur初始化为head，cur为即将被反转的元素</li>
</ul>
</li>
<li>开始反转：
<ul>
<li>使用tmp保存 cur.next，即cur的下一个节点</li>
<li>反转：cur.next=pre，即指向上一个节点</li>
<li>往后移动pre指针：pre=cur</li>
<li>往后移动cur指针：cur=tmp</li>
</ul>
</li>
<li>最后返回pre，即原来的最后一个节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        ListNode tmp;</span><br><span class="line">        ListNode pre=<span class="literal">null</span>;</span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            tmp=cur.next;</span><br><span class="line">            cur.next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="222递归法"><a class="markdownIt-Anchor" href="#222递归法"></a> 2.2.2递归法</h3>
<p>递归法相对抽象一些，但是其实和双指针法是一样的逻辑，同样是当cur为空的时候循环结束，<mark>不断将cur指向pre</mark>的过程。</p>
<p>关键是初始化的地方，可以看<mark>到双指针法中初始化 cur = head，pre = NULL</mark>，在递归法中可以从如下代码看出初始化的逻辑也是一样的，只不过写法变了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法二：递归</span></span><br><span class="line">        <span class="keyword">return</span> reverse(<span class="literal">null</span>,head);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转：将cur指向pre</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode pre,ListNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pre;     <span class="comment">//最后一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tmp=cur.next;</span><br><span class="line">        cur.next=pre;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// pre=cur</span></span><br><span class="line">        <span class="comment">// cur=tmp</span></span><br><span class="line">        <span class="keyword">return</span> reverse(cur,tmp);   <span class="comment">//反转：将tmp执行cur</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3两两交换链表中的节点"><a class="markdownIt-Anchor" href="#3两两交换链表中的节点"></a> 3.两两交换链表中的节点</h1>
<h2 id="31题目-3"><a class="markdownIt-Anchor" href="#31题目-3"></a> 3.1题目</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24.两两交换链表中的节点——力扣链接</a></p>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img" /></p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<h2 id="32解法虚拟头节点"><a class="markdownIt-Anchor" href="#32解法虚拟头节点"></a> 3.2解法：虚拟头节点</h2>
<ul>
<li>核心：使用虚拟头节点</li>
<li>逻辑：每次循环分为三步（在此之前，需要保存第一个节点链接、以及链表后面节点的链接）
<ul>
<li><mark>头节点连接第二个节点</mark></li>
<li>第二个节点反转连接第一个节点</li>
<li><mark>第一个节点连接后面的链表节点</mark></li>
</ul>
</li>
<li>如图：初始化</li>
</ul>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B91.png" alt="24.两两交换链表中的节点1" /></p>
<ul>
<li>操作之后：</li>
</ul>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B92.png" alt="24.两两交换链表中的节点2" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">       <span class="comment">//使用虚拟头节点方法</span></span><br><span class="line">       </span><br><span class="line">       ListNode dummy=<span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>,head);</span><br><span class="line">       ListNode cur=dummy;</span><br><span class="line">       <span class="keyword">while</span>(cur.next!=<span class="literal">null</span> &amp;&amp; cur.next.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">           ListNode tmp1=cur.next;  <span class="comment">//保存第一个节点</span></span><br><span class="line">           ListNode tmp2=cur.next.next.next;</span><br><span class="line"></span><br><span class="line">           cur.next=cur.next.next; <span class="comment">//连接第二个节点</span></span><br><span class="line">           cur.next.next=tmp1;      <span class="comment">//反转，连接第一个节点</span></span><br><span class="line">           cur.next.next.next=tmp2;   <span class="comment">//连接后面的节点</span></span><br><span class="line"></span><br><span class="line">           cur=cur.next.next;     <span class="comment">//cur移动两位，下一个头节点</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dummy.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="4删除链表的倒数的第n个节点"><a class="markdownIt-Anchor" href="#4删除链表的倒数的第n个节点"></a> 4.删除链表的倒数的第N个节点</h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19.删除链表的倒数第N个节点</a></p>
<h2 id="41题目-2"><a class="markdownIt-Anchor" href="#41题目-2"></a> 4.1题目</h2>
<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例三：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<h2 id="42解法双指针"><a class="markdownIt-Anchor" href="#42解法双指针"></a> 4.2解法：双指针</h2>
<ul>
<li>该题为双指针的应用：<mark>如果要删除倒数第n个节点</mark>，则<mark>先让fast移动n+1步</mark>，然后<mark>让fast和slow同时移动</mark>，直到fast指向链表末尾。删掉slow所指向的节点就可以了</li>
</ul>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.png" alt="img" /></p>
<ul>
<li>问题：fast首先走n + 1步 ，为什么是n+1呢</li>
<li>因为只有这样<mark>同时移动的时候</mark>==<strong>slow才能指向删除节点的上一个节点</strong>==（方便做删除操作）</li>
</ul>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B91.png" alt="img" /></p>
<ul>
<li>fast和slow同时移动，直到fast指向末尾，如题：</li>
</ul>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B92.png" alt="img" /></p>
<ul>
<li>删除slow指向的下一个节点，如图： <img src="https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B93.png" alt="img" /></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">       </span><br><span class="line">       ListNode  dummy=<span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>,head);</span><br><span class="line">       ListNode  slow=dummy;</span><br><span class="line">       ListNode  fast=dummy;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//1、先让fast走 n+1 步</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           fast=fast.next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//2、让fast、slow同时移动，直到fast到末尾为空</span></span><br><span class="line">       <span class="keyword">while</span>(fast!=<span class="literal">null</span>)&#123;</span><br><span class="line">           slow=slow.next;</span><br><span class="line">           fast=fast.next;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//3、删除该元素</span></span><br><span class="line">       slow.next=slow.next.next;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> dummy.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="5链表相交"><a class="markdownIt-Anchor" href="#5链表相交"></a> 5.链表相交</h1>
<h2 id="51题目-2"><a class="markdownIt-Anchor" href="#51题目-2"></a> 5.1题目</h2>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回<mark>两个单链表相交的起始节点</mark>（注意：相交是指两个链表指向的节点是同一个，并不是指值相等）。如果两个链表没有交点，返回 <code>null</code> 。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>
<h2 id="52解法双指针"><a class="markdownIt-Anchor" href="#52解法双指针"></a> 5.2解法：双指针</h2>
<blockquote>
<ul>
<li>目的：找到<mark>相同的链表节点</mark>并<mark>返回该节点</mark></li>
<li>核心：
<ul>
<li>先找到两条链表中长的一条，并让这两条链表末尾对齐（让curA指针先移动 lenA-lenB个位置）</li>
<li>再同时移动curA、curB指针，若找到相同的节点，并返回该节点</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="type">int</span> lenA=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> lenB=<span class="number">0</span>;</span><br><span class="line">        ListNode curA=headA;</span><br><span class="line">        ListNode curB=headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curA!=<span class="literal">null</span>)&#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            curA=curA.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curB!=<span class="literal">null</span>)&#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            curB=curB.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//回归头节点</span></span><br><span class="line">        curA=headA;</span><br><span class="line">        curB=headB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//确保 lenA、curA指向的是较长的链表</span></span><br><span class="line">        <span class="keyword">if</span>(lenB&gt;lenA)&#123;</span><br><span class="line">            <span class="type">int</span> tmp=lenB;</span><br><span class="line">            lenB=lenA;</span><br><span class="line">            lenA=tmp;</span><br><span class="line"></span><br><span class="line">            ListNode curTmp=curB;</span><br><span class="line">            curB=curA;</span><br><span class="line">            curA=curTmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算需要移动的距离</span></span><br><span class="line">        <span class="type">int</span> gap=lenA-lenB;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;gap;i++)&#123;</span><br><span class="line">            curA=curA.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//curA curB同时移动</span></span><br><span class="line">        <span class="keyword">while</span>(curA!=<span class="literal">null</span> &amp;&amp; curB!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//注意：是指针相同</span></span><br><span class="line">            <span class="keyword">if</span>(curA==curB)&#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA=curA.next;</span><br><span class="line">            curB=curB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="6环形链表"><a class="markdownIt-Anchor" href="#6环形链表"></a> 6.环形链表 ||</h1>
<h2 id="61题目"><a class="markdownIt-Anchor" href="#61题目"></a> 6.1题目</h2>
<p>给定一个链表的头节点  <code>head</code> ，<mark>返回链表开始入环的第一个节点</mark>。 <em>如果链表无环，则返回 <code>null</code>。</em></p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p><strong>不允许修改</strong> 链表。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节</span><br></pre></td></tr></table></figure>
<h2 id="62解法数学公式化简"><a class="markdownIt-Anchor" href="#62解法数学公式化简"></a> 6.2解法：数学公式化简</h2>
<ul>
<li>该题两个核心问题：
<ul>
<li>判断链表是否有环</li>
<li>若有环，该如何找到这个环的入口</li>
</ul>
</li>
</ul>
<h3 id="621判断链表是否有环"><a class="markdownIt-Anchor" href="#621判断链表是否有环"></a> 6.2.1判断链表是否有环</h3>
<ul>
<li>核心：使用快慢指针法</li>
</ul>
<p>使用快慢指针法，分别定义 fast 和 slow 指针==，从头结点出发==，<mark>fast指针每次移动两个节点</mark>，<mark>slow指针每次移动一个节点</mark>，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环</p>
<p>这是因为fast是走两步，slow是走一步，<strong>其实相对于slow来说==，fast是一个节点一个节点的靠近slow的==</strong>，所以fast一定可以和slow重合。</p>
<p>如图动画：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.gif" alt="141.环形链表" /></p>
<h3 id="622怎么找到该环的入口"><a class="markdownIt-Anchor" href="#622怎么找到该环的入口"></a> 6.2.2怎么找到该环的入口</h3>
<ol>
<li>
<p>假设<mark>从头结点到环形入口节点 的节点数为x</mark>。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：</p>
</li>
<li>
<p>那么相遇时：</p>
<ul>
<li>slow指针走过的节点数为: <code>x + y</code></li>
<li>fast指针走过的节点数：<code>x + y + n (y + z)</code>，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。</li>
</ul>
</li>
<li>
<p>因为<mark>fast指针是一步走两个节点</mark>，<mark>slow指针一步走一个节点</mark>， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：(x + y) * 2 = x + y + n (y + z)</p>
</li>
<li>
<p>两边消掉一个（x+y）: <code>x + y = n (y + z)</code></p>
</li>
<li>
<p>因为要找环形的入口，<mark>那么要求的是x</mark>，因为x表示 头结点到 环形入口节点的的距离。所以要求x ，将x单独放在左面：<code>x = n (y + z) - y</code> ,</p>
</li>
<li>
<p>再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：<code>x = (n - 1) (y + z) + z</code> 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。</p>
</li>
<li>
<p>先拿n为1的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。当 n为1的时候，公式就化解为 <code>x = z</code>，</p>
</li>
<li>
<p>这就意味着，<strong><mark>从头结点出发一个指针</mark>，<mark>从相遇节点 也出发一个指针</mark>，这两个指针每次只走一个节点， 那么<mark>当这两个指针相遇的时候就是 环形入口的节点</mark></strong>。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II%EF%BC%88%E6%B1%82%E5%85%A5%E5%8F%A3%EF%BC%89.gif" alt="142.环形链表II（求入口）" /></p>
</li>
</ol>
<h3 id="623代码"><a class="markdownIt-Anchor" href="#623代码"></a> 6.2.3代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">       <span class="comment">//核心：判断是否存在环，以及找到环的入口</span></span><br><span class="line">       ListNode slow=head;</span><br><span class="line">       ListNode fast=head;</span><br><span class="line">       <span class="keyword">while</span>(fast!=<span class="literal">null</span> &amp;&amp; fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">           slow=slow.next;</span><br><span class="line">           fast=fast.next.next;</span><br><span class="line">           <span class="keyword">if</span>(slow==fast)&#123;</span><br><span class="line">               <span class="comment">//存在环，下一步找到环的入口</span></span><br><span class="line">               ListNode tmp=head;</span><br><span class="line">               <span class="keyword">while</span>(tmp!=fast)&#123;</span><br><span class="line">                   fast=fast.next;</span><br><span class="line">                   tmp=tmp.next;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> tmp;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="7排序链表"><a class="markdownIt-Anchor" href="#7排序链表"></a> 7.排序链表</h1>
<h2 id="71题目"><a class="markdownIt-Anchor" href="#71题目"></a> 7.1题目</h2>
<p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2b4520aa02963dd0feda2b17450b4aef.png" alt="image-20240420114427525" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [4,2,1,3]</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/dc6e40d8f762c7b160493f0f6ff3211d.jpeg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [-1,5,3,4,0]</span><br><span class="line">输出：[-1,0,3,4,5]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 5 * 104]</code> 内</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
</ul>
<p>**进阶：**你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p>
<h2 id="72解法归并排序"><a class="markdownIt-Anchor" href="#72解法归并排序"></a> 7.2解法：归并排序</h2>
<h3 id="721排序思路"><a class="markdownIt-Anchor" href="#721排序思路"></a> 7.2.1排序思路</h3>
<ul>
<li>使用归并排序的思路，对排序的链表分而治之，递归将链表减半，直到链表的长度为1，再合并两个（长度为1、2、4…）的链表</li>
</ul>
<h4 id="1递归函数返回值以及参数"><a class="markdownIt-Anchor" href="#1递归函数返回值以及参数"></a> （1）递归函数返回值以及参数</h4>
<ul>
<li>将以head为头节点的链表排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span></span><br></pre></td></tr></table></figure>
<h4 id="2终止条件"><a class="markdownIt-Anchor" href="#2终止条件"></a> （2）终止条件</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3遍历过程"><a class="markdownIt-Anchor" href="#3遍历过程"></a> （3）遍历过程</h4>
<ul>
<li>求出该链表的中间节点（快慢指针）</li>
<li>切断链表的前半段和后半段联系</li>
<li>递归调用函数，切链表，直到链表的长度为1，再进行合并</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用快慢指针找到链表的中点</span></span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head, cur = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">          cur = slow;</span><br><span class="line">          slow = slow.next;</span><br><span class="line">          fast = fast.next.next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 断开链表，将链表分为两部分</span></span><br><span class="line">      cur.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 递归地对左右两部分进行排序</span></span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">l</span> <span class="operator">=</span> sortList(head);</span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">r</span> <span class="operator">=</span> sortList(slow);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 合并两个有序链表</span></span><br><span class="line">      <span class="keyword">return</span> merge(l, r);</span><br></pre></td></tr></table></figure>
<ul>
<li>合并两个有序链表</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">       <span class="comment">// 虚拟头节点</span></span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 循环比较两个链表的节点，并将较小的节点连接到新链表中</span></span><br><span class="line">       <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (l1.val &gt; l2.val) &#123;</span><br><span class="line">               cur.next = l2;</span><br><span class="line">               l2 = l2.next;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               cur.next = l1;</span><br><span class="line">               l1 = l1.next;</span><br><span class="line">           &#125;</span><br><span class="line">           cur = cur.next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将剩余的节点连接到新链表的末尾</span></span><br><span class="line">       <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">           cur.next = l1;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           cur.next = l2;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 返回合并后的链表</span></span><br><span class="line">       <span class="keyword">return</span> dummy.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="722代码实现"><a class="markdownIt-Anchor" href="#722代码实现"></a> 7.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">       <span class="comment">// 边界情况：链表为空或只有一个节点时，直接返回</span></span><br><span class="line">       <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 使用快慢指针找到链表的中点</span></span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head, cur = <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">           cur = slow;</span><br><span class="line">           slow = slow.next;</span><br><span class="line">           fast = fast.next.next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 断开链表，将链表分为两部分</span></span><br><span class="line">       cur.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 递归地对左右两部分进行排序</span></span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">l</span> <span class="operator">=</span> sortList(head);</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">r</span> <span class="operator">=</span> sortList(slow);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 合并两个有序链表</span></span><br><span class="line">       <span class="keyword">return</span> merge(l, r);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">       <span class="comment">// 虚拟头节点</span></span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 循环比较两个链表的节点，并将较小的节点连接到新链表中</span></span><br><span class="line">       <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (l1.val &gt; l2.val) &#123;</span><br><span class="line">               cur.next = l2;</span><br><span class="line">               l2 = l2.next;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               cur.next = l1;</span><br><span class="line">               l1 = l1.next;</span><br><span class="line">           &#125;</span><br><span class="line">           cur = cur.next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将剩余的节点连接到新链表的末尾</span></span><br><span class="line">       <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">           cur.next = l1;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           cur.next = l2;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 返回合并后的链表</span></span><br><span class="line">       <span class="keyword">return</span> dummy.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="8回文链表"><a class="markdownIt-Anchor" href="#8回文链表"></a> 8.回文链表</h1>
<h2 id="81题目"><a class="markdownIt-Anchor" href="#81题目"></a> 8.1题目</h2>
<p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f84aeeb4b0a118d5533ea2b8082ed41a.jpeg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/498d75594eeb179ea3687c94050a63a6.jpeg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<h2 id="82解法双指针"><a class="markdownIt-Anchor" href="#82解法双指针"></a> 8.2解法：双指针</h2>
<h3 id="821解法思路"><a class="markdownIt-Anchor" href="#821解法思路"></a> 8.2.1解法思路</h3>
<ul>
<li>使用快慢指针遍历整个链表，以此找到链表的中间节点；</li>
<li>并在遍历过程中，反转slow遍历过的每个节点，用cur标记；</li>
<li>遍历的终止条件为 fast指向的节点为空 或者 fast指向的节点的下一个节点为空</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/468f138c754353702d4e0e002487be03.png" alt="image-20240420102624490" /></p>
<h3 id="822代码实现"><a class="markdownIt-Anchor" href="#822代码实现"></a> 8.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">       ListNode fast=head;</span><br><span class="line">       ListNode slow=head;</span><br><span class="line">       ListNode cur=<span class="literal">null</span>;  <span class="comment">//反转链表</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//1、找到中间节点</span></span><br><span class="line">       <span class="keyword">while</span>(fast!=<span class="literal">null</span> &amp;&amp; fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">           ListNode tmp=slow;      <span class="comment">//暂存slow节点</span></span><br><span class="line">           fast=fast.next.next;</span><br><span class="line">           slow=slow.next;</span><br><span class="line"></span><br><span class="line">           tmp.next=cur;   <span class="comment">//反转</span></span><br><span class="line">           cur=tmp;        <span class="comment">//更新cur节点</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//2、判断链表长度是否为奇数：若为奇数，则将slow移动到下一位</span></span><br><span class="line">       <span class="keyword">if</span>(fast!=<span class="literal">null</span>)&#123;</span><br><span class="line">           slow=slow.next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3、遍历后半段的回文串和前半段的回文串</span></span><br><span class="line">       <span class="keyword">while</span>(slow!=<span class="literal">null</span> &amp;&amp; cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(slow.val!=cur.val)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           slow=slow.next;</span><br><span class="line">           cur=cur.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="哈希"><a class="markdownIt-Anchor" href="#哈希"></a> <mark>哈希</mark></h1>
<h1 id="1有效的字母异位词"><a class="markdownIt-Anchor" href="#1有效的字母异位词"></a> 1.有效的字母异位词</h1>
<h2 id="11题目-5"><a class="markdownIt-Anchor" href="#11题目-5"></a> 1.1题目</h2>
<p>给定两个字符串 <code>*s*</code> 和 <code>*t*</code> ，编写一个函数来判断 <code>*t*</code> 是否是 <code>*s*</code> 的字母异位词。</p>
<p>**注意：**若 <code>*s*</code> 和 <code>*t*</code> 中每个字符出现的次数都相同，则称 <code>*s*</code> 和 <code>*t*</code> 互为字母异位词。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<h2 id="12解法哈希表思想"><a class="markdownIt-Anchor" href="#12解法哈希表思想"></a> 1.2解法：哈希表思想</h2>
<ol>
<li>由于题目中提示字符串中均为小写字母，可新建一个数组、利用哈希表思想，为26个字母记录出现的次数</li>
<li>Java获取字符串指定索引下的元素方法：charAt(i)，再减去 ‘a’，即为哈希表中的索引（例如 字母a的索引为0，b的索引为1）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">           arr[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t.length();i++)&#123;</span><br><span class="line">           arr[t.charAt(i)-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> count:arr)&#123;</span><br><span class="line">           <span class="keyword">if</span>(count!=<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="2两个数组的交集"><a class="markdownIt-Anchor" href="#2两个数组的交集"></a> 2.两个数组的交集</h1>
<h2 id="21题目-5"><a class="markdownIt-Anchor" href="#21题目-5"></a> 2.1题目</h2>
<p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的交集</em> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出：[9,4]</span><br><span class="line">解释：[4,9] 也是可通过的</span><br></pre></td></tr></table></figure>
<h2 id="22解法hashset"><a class="markdownIt-Anchor" href="#22解法hashset"></a> 2.2解法：HashSet</h2>
<ol>
<li>HashSet存放的是唯一，不重复的元素</li>
<li>步骤：定义<mark>两个HashSet，一个存放数组1的元素</mark>，<mark>一个存放两个数组共同（重复）的元素</mark>，最后将该HashSet转成数组即可</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">       Set&lt;Integer&gt; set1=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       Set&lt;Integer&gt; set2=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> num:nums1)&#123;</span><br><span class="line">           set1.add(num);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> num:nums2)&#123;</span><br><span class="line">           <span class="keyword">if</span>(set1.contains(num))&#123;</span><br><span class="line">               set2.add(num);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[set2.size()];</span><br><span class="line">       <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> num:set2)&#123;</span><br><span class="line">           arr[i++]=num;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="3快乐数"><a class="markdownIt-Anchor" href="#3快乐数"></a> 3.快乐数</h1>
<h2 id="31题目-4"><a class="markdownIt-Anchor" href="#31题目-4"></a> 3.1题目</h2>
<p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p>
<p><strong>「快乐数」</strong> 定义为：</p>
<ul>
<li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li>
<li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li>
<li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li>
</ul>
<p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 + 92 = 82</span><br><span class="line">82 + 22 = 68</span><br><span class="line">62 + 82 = 100</span><br><span class="line">12 + 02 + 02 = 1</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<h2 id="32解法哈希表"><a class="markdownIt-Anchor" href="#32解法哈希表"></a> 3.2解法：哈希表</h2>
<ol>
<li>题目提示会无限循环，即求和过程中，sum会重复出现</li>
<li>即使用哈希表设计思想，将sum放到哈希表中</li>
<li>逻辑：将每次对该数求sum封装成一个方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       Set&lt;Integer&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(n!=<span class="number">1</span> &amp;&amp; !set.contains(n))&#123;</span><br><span class="line">           set.add(n);     <span class="comment">//先加入集合</span></span><br><span class="line">           n=getSum(n);    <span class="comment">//再重新计算</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> n==<span class="number">1</span>;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">       <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="type">int</span> n=num%<span class="number">10</span>;</span><br><span class="line">           count+=n*n;</span><br><span class="line">           num/=<span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="4两数之和"><a class="markdownIt-Anchor" href="#4两数之和"></a> 4.两数之和</h1>
<h2 id="41题目-3"><a class="markdownIt-Anchor" href="#41题目-3"></a> 4.1题目</h2>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] </span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>
<h2 id="42解法key-value"><a class="markdownIt-Anchor" href="#42解法key-value"></a> 4.2解法：key-value</h2>
<ol>
<li>因为要存储数组元素、以及对应的下标的信息，即key-value信息；</li>
<li>采用HashMap数据结构：key存储数组元素、value存储数组下标</li>
<li>遍历整个数组、若发现 target-nums[i]存在于map中，即找到两者（返回两者下标 i 和 map.get(target-nums[i])）即可；否则添加到map中</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">       Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span>(map.containsKey(target-nums[i]))&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">           &#125;</span><br><span class="line">           map.put(nums[i],i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="5四数之和"><a class="markdownIt-Anchor" href="#5四数之和"></a> 5.四数之和</h1>
<h2 id="51题目-3"><a class="markdownIt-Anchor" href="#51题目-3"></a> 5.1题目</h2>
<p>给你四个整数数组 <code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和 <code>nums4</code> ，数组长度都是 <code>n</code> ，请你计算有多少个元组 <code>(i, j, k, l)</code> 能满足：</p>
<p><code>0 &lt;= i, j, k, l &lt; n</code></p>
<p><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>], nums2 = [-<span class="number">2</span>,-<span class="number">1</span>], nums3 = [-<span class="number">1</span>,<span class="number">2</span>], nums4 = [<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">两个元组如下：</span><br><span class="line"><span class="number">1.</span> (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) -&gt; nums1[<span class="number">0</span>] + nums2[<span class="number">0</span>] + nums3[<span class="number">0</span>] + nums4[<span class="number">1</span>] = <span class="number">1</span> + (-<span class="number">2</span>) + (-<span class="number">1</span>) + <span class="number">2</span> = <span class="number">0</span></span><br><span class="line"><span class="number">2.</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) -&gt; nums1[<span class="number">1</span>] + nums2[<span class="number">1</span>] + nums3[<span class="number">0</span>] + nums4[<span class="number">0</span>] = <span class="number">2</span> + (-<span class="number">1</span>) + (-<span class="number">1</span>) + <span class="number">0</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<h2 id="52解法key-value"><a class="markdownIt-Anchor" href="#52解法key-value"></a> 5.2解法：key-value</h2>
<ol>
<li>题目理解：在四个数组里面查找满足四个数之和为0的方法，有几种满足方式就返回几种</li>
<li>思路：使用HashMap
<ul>
<li>第一次遍历（第一、二个数组）HashMap存储 key为第一个数组和第二个数组中任意两个元素之和，value为出现的次数</li>
<li>第二次遍历（第三、四个数组）若发现 0 -（i+j）的元素在之前的HashMap集合中存在，则加上该value</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line"></span><br><span class="line">       Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">       <span class="comment">//遍历第一、二个数组</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i:nums1)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j:nums2)&#123;</span><br><span class="line">               map.put(i+j,map.getOrDefault(i+j,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//遍历第三、四个数组</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i:nums3)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j:nums4)&#123;</span><br><span class="line">               <span class="keyword">if</span>(map.containsKey(<span class="number">0</span>-i-j))&#123;</span><br><span class="line">                   count+=map.get(<span class="number">0</span>-i-j);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="6赎金信"><a class="markdownIt-Anchor" href="#6赎金信"></a> 6.赎金信</h1>
<h2 id="61题目-2"><a class="markdownIt-Anchor" href="#61题目-2"></a> 6.1题目</h2>
<p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p>
<p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p>
<p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<ul>
<li>示例三：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<h2 id="62解法哈希表思想"><a class="markdownIt-Anchor" href="#62解法哈希表思想"></a> 6.2解法：哈希表思想</h2>
<ol>
<li>题目提示均为小写字母，即可使用长度为26的数组作为哈希表，每个字母映射到数组的每一个下标，数组内容为该字母出现的次数</li>
<li>遍历两个数组，第一个数组，将检测到的数组元素对应的下标加1；第二个数组则减1</li>
<li>最后遍历哈希表数组，若发现有元素的值大于0，则说明有第二个数组不存在的字符</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(ransomNote.length()&gt;magazine.length())&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//哈希表思想</span></span><br><span class="line">       <span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">char</span> i:ransomNote.toCharArray())&#123;</span><br><span class="line">           arr[i-<span class="string">&#x27;a&#x27;</span>]+=<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">char</span> i:magazine.toCharArray())&#123;</span><br><span class="line">           arr[i-<span class="string">&#x27;a&#x27;</span>]-=<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i:arr)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="7三数之和"><a class="markdownIt-Anchor" href="#7三数之和"></a> 7.三数之和</h1>
<h2 id="71题目-2"><a class="markdownIt-Anchor" href="#71题目-2"></a> 7.1题目</h2>
<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回==所有和为 <code>0</code> 且<strong>不重复</strong>==的三元组（需要实现去重效果）。</p>
<p>**注意：**答案中不可以包含重复的三元组。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure>
<h2 id="72解法一哈希法"><a class="markdownIt-Anchor" href="#72解法一哈希法"></a> 7.2解法一：哈希法</h2>
<ol>
<li>使用两层for循环确定a和b的数值，并使用哈希法确定 0-(a+b)是否存在于数组中</li>
<li>关键问题：该题需要去重，即a、b、c同样的值只能有一份！唯一！三元组唯一</li>
<li>C#语言解法的可以将其（三元组）放进vector中，再去重，时间效率低</li>
</ol>
<h2 id="73解法二双指针法"><a class="markdownIt-Anchor" href="#73解法二双指针法"></a> 7.3解法二：双指针法</h2>
<ol>
<li>
<p>首先<mark>将数组排序</mark>，外面一层for循环，i从下标的地方开始遍历，同时定义一个left=i+1；right=数组末尾</p>
</li>
<li>
<p>即nums[i]=a，nums[left]=b，nums[right]=c</p>
</li>
<li>
<p>在循环里面只要left&lt;right，就不停遍历，若发现nums[i]+nums[left]+nums[right]=0，则将该a、b、c值加进list中</p>
</li>
<li>
<p>何时移动left和right：</p>
<ul>
<li>当nums[i]+nums[left]+nums[right]&gt;0，就要将right往左移，即right–；</li>
<li>当nums[i]+nums[left]+nums[right]&lt;0，就要将left往右移，即left++；</li>
</ul>
</li>
<li>
<p>关于去重：</p>
<ul>
<li>
<p>去重a：即a左右的元素若相同，则需要重新进入循环</p>
<ul>
<li>
<p>错误的去重a做法：<mark>将当前元素和下一个元素比较</mark>（显然下面这种例子是允许的）</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误去重a方法，将会漏掉-1,-1,2 这种情况</span></span><br><span class="line"><span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>正确的去重a做法：<mark>将当前元素和上一个元素比较（并在前判断当前元素不是第一个元素）</mark></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确去重a方法</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>去重b、c：</p>
<ul>
<li>去重b：将当前元素和下一元素对比</li>
<li>去重c：将当前元素和上一元素对比</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line"><span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) </span><br><span class="line">    right--;</span><br><span class="line"><span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) </span><br><span class="line">    left++;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="comment">//1、排序</span></span><br><span class="line">       Arrays.sort(nums);</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">int</span> left=i+<span class="number">1</span>;</span><br><span class="line">           <span class="type">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[i]+nums[left]+nums[right]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                   left++;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[left]+nums[right]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                   right--;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="comment">//找到一组三元组</span></span><br><span class="line">                   list.add(Arrays.asList(nums[i],nums[left],nums[right]));</span><br><span class="line">                   <span class="comment">//去重b、c应该在找到三元组之后</span></span><br><span class="line">                   <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]==nums[left+<span class="number">1</span>])&#123;</span><br><span class="line">                       left++;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right]==nums[right-<span class="number">1</span>])&#123;</span><br><span class="line">                       right--;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">//注意，找到一组之后需要移动left、right</span></span><br><span class="line">                   left++;</span><br><span class="line">                   right--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="8四数之和"><a class="markdownIt-Anchor" href="#8四数之和"></a> 8.四数之和</h1>
<h2 id="81题目-2"><a class="markdownIt-Anchor" href="#81题目-2"></a> 8.1题目</h2>
<p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<ul>
<li><code>0 &lt;= a, b, c, d &lt; n</code></li>
<li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li>
<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>
<p>你可以按 <strong>任意顺序</strong> 返回答案 。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,0,-1,0,-2,2], target = 0</span><br><span class="line">输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,2,2,2], target = 8</span><br><span class="line">输出：[[2,2,2,2]]</span><br></pre></td></tr></table></figure>
<h2 id="82解法一双指针法"><a class="markdownIt-Anchor" href="#82解法一双指针法"></a> 8.2解法一：双指针法</h2>
<ol>
<li>
<p>所谓四数之和，本质上和三数之和是一个思路，都是使用双指针法；<mark>四数之和的解法就是在三数之和的基础上再嵌套一层for循环</mark></p>
</li>
<li>
<p>四数之和的双指针解法是<mark>两层for循环nums[k] + nums[i]为确定值</mark>，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] == target的情况</p>
</li>
<li>
<p>注意剪枝代码：若<mark>数组是[-4, -3, -2, -1]，target是-10（负数）</mark>，则<mark>不能跳过</mark>，还需加上num[i]&gt;0条件</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[i]&gt;target &amp;&amp; nums[i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">       </span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="comment">//1、排序</span></span><br><span class="line">       Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="comment">//1、一级剪枝</span></span><br><span class="line">           <span class="comment">//若数组是[-4, -3, -2, -1]，target是-10（负数），则不能跳过，还需加上num[i]&gt;0条件</span></span><br><span class="line">           <span class="keyword">if</span>(nums[i]&gt;target &amp;&amp; nums[i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//去重a</span></span><br><span class="line">           <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">               <span class="comment">//2、二级剪枝</span></span><br><span class="line">               <span class="keyword">if</span>(nums[i]+nums[j]&gt;target &amp;&amp; nums[i]+nums[j]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//去重b</span></span><br><span class="line">               <span class="keyword">if</span>(j&gt;i+<span class="number">1</span> &amp;&amp; nums[j]==nums[j-<span class="number">1</span>])&#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="type">int</span> left=j+<span class="number">1</span>;</span><br><span class="line">               <span class="type">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                   <span class="type">int</span> sum=nums[i]+nums[j]+nums[left]+nums[right];</span><br><span class="line">                   <span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">                       left++;</span><br><span class="line">                   &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">                       right--;</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       <span class="comment">//找到一个四元组</span></span><br><span class="line">                       list.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));</span><br><span class="line"></span><br><span class="line">                       <span class="comment">//去重 c、d</span></span><br><span class="line">                       <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]==nums[left+<span class="number">1</span>])&#123;</span><br><span class="line">                           left++;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right]==nums[right-<span class="number">1</span>])&#123;</span><br><span class="line">                           right--;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">//注意：找到一个四元组后，需要同时移动left和right</span></span><br><span class="line">                       left++;</span><br><span class="line">                       right--;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="9字母异位词分组"><a class="markdownIt-Anchor" href="#9字母异位词分组"></a> 9.字母异位词分组</h1>
<h2 id="91题目"><a class="markdownIt-Anchor" href="#91题目"></a> 9.1题目</h2>
<p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p>
<p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [&quot;&quot;]</span><br><span class="line">输出: [[&quot;&quot;]]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例三：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [&quot;a&quot;]</span><br><span class="line">输出: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure>
<h2 id="92解法哈希法"><a class="markdownIt-Anchor" href="#92解法哈希法"></a> 9.2解法：哈希法</h2>
<h3 id="921哈希思路"><a class="markdownIt-Anchor" href="#921哈希思路"></a> 9.2.1哈希思路</h3>
<ul>
<li>一次遍历循环，遍历整个字符串数组</li>
<li>每次拿到数组中的字符串，先将其转成数组，并按照升序排序，再将其转成字符串</li>
<li>判断该字符串在map（String,List）中是否存在
<ul>
<li>不存在，存入map集合中</li>
</ul>
</li>
<li>不管是否存不存在，都要将nums[i]元素加进 以该字符串为 key的value中</li>
</ul>
<h3 id="922代码实现"><a class="markdownIt-Anchor" href="#922代码实现"></a> 9.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span>(strs.length==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       &#125;</span><br><span class="line">       Map&lt;String,List&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//1、将字符串其转成数组，并按照升序排序</span></span><br><span class="line">           <span class="type">char</span>[] ch=strs[i].toCharArray();</span><br><span class="line">           Arrays.sort(ch);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2、将其转成字符串，为key</span></span><br><span class="line">           String key=String.valueOf(ch);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(!map.containsKey(key))&#123;</span><br><span class="line">               map.put(key,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">           &#125;</span><br><span class="line">           map.get(key).add(strs[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(map.values());</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="10最长连续序列"><a class="markdownIt-Anchor" href="#10最长连续序列"></a> 10.最长连续序列</h1>
<h2 id="101题目"><a class="markdownIt-Anchor" href="#101题目"></a> 10.1题目</h2>
<p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>
<h2 id="102解法哈希法"><a class="markdownIt-Anchor" href="#102解法哈希法"></a> 10.2解法：哈希法</h2>
<h3 id="1021哈希思路"><a class="markdownIt-Anchor" href="#1021哈希思路"></a> 10.2.1哈希思路</h3>
<ul>
<li>题目要求时间复杂度为O(n)</li>
<li>核心：<strong>一次遍历，每个数都判断一次<mark>这个数是不是连续序列的开头那个数</mark></strong>。
<ul>
<li>用哈希表查找这个数前面一个数是否存在，即num-1在序列中是否存在。<mark>存在那这个数肯定不是开头，直接跳过</mark>。</li>
<li>因此只需要对每个开头的数进行循环，直到这个序列不再连续，因此复杂度是O(n)。</li>
</ul>
</li>
<li>举例：**[100，4，200，1，3，4，2]**去重后的哈希序列为：<br />
<strong>[100，4，200，1，3，2]</strong><br />
按照上面逻辑进行判断：
<ul>
<li>元素100是开头,因为没有99，且以100开头的序列长度为1</li>
<li>元素4不是开头，因为有3存在，过，</li>
<li>元素200是开头，因为没有199，且以200开头的序列长度为1</li>
<li>元素1是开头，因为没有0，且以1开头的序列长度为4，因为依次累加，2，3，4都存在。</li>
<li>元素3不是开头，因为2存在，过，</li>
<li>元素2不是开头，因为1存在，过。<br />
完</li>
</ul>
</li>
</ul>
<h3 id="1022代码实现"><a class="markdownIt-Anchor" href="#1022代码实现"></a> 10.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="type">int</span> res=Integer.MIN_VALUE;</span><br><span class="line">       Set&lt;Integer&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">           set.add(num);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//1、遍历整个nums数组</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">           <span class="comment">//2、判断 num 是否为有序序列的第一个元素</span></span><br><span class="line">           <span class="keyword">if</span>(set.contains(num-<span class="number">1</span>)==<span class="literal">false</span>)&#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//3、num为第一个元素</span></span><br><span class="line"></span><br><span class="line">               <span class="type">int</span> max=<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">while</span>(set.contains(num+<span class="number">1</span>))&#123;</span><br><span class="line">                   num++;</span><br><span class="line">                   max++;</span><br><span class="line">               &#125;</span><br><span class="line">   </span><br><span class="line">               <span class="comment">//4、更新最长连续序列长度</span></span><br><span class="line">               res=Math.max(res,max);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> <mark>滑动窗口</mark></h1>
<h1 id="1无重复字符的最长子串"><a class="markdownIt-Anchor" href="#1无重复字符的最长子串"></a> 1.无重复字符的最长子串</h1>
<h2 id="11题目-6"><a class="markdownIt-Anchor" href="#11题目-6"></a> 1.1题目</h2>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>
<h2 id="12解法一滑动窗口"><a class="markdownIt-Anchor" href="#12解法一滑动窗口"></a> 1.2解法一：滑动窗口</h2>
<h3 id="121解题思路"><a class="markdownIt-Anchor" href="#121解题思路"></a> 1.2.1解题思路</h3>
<ul>
<li>
<p>使用一个for循环代表窗口的结束位置，一个变量left代表窗口的起始位置；</p>
</li>
<li>
<p>使用一个<mark>map集合存储字符串中的 字符</mark> 以及在<mark>字符串中的索引位置</mark> ；</p>
</li>
<li>
<p>每次循环中，若map集合没有该字符，则将该字符以及索引位置存放到map中；</p>
</li>
<li>
<p>若已经存在该字符，则需移动left起始位置， <mark>left在（原有的left，重复字符的下一个位置）两个中取最大值</mark></p>
<ul>
<li>
<p>目的：<mark>确保left起始位置不会往前移动</mark></p>
</li>
<li>
<p>例子：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#求字符串 abba 的无重复字符的最长子串</span><br><span class="line"></span><br><span class="line">#在遍历索引为3的字符a时，left值为2</span><br><span class="line">#left在（原有的left：2，以及重复字符a索引的下一个位置，即1）中应该取原有的2</span><br><span class="line">#若left取了1，则left往前移动了</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><mark>原有的max长度和 （ j-left+1 ）比较，取最大值</mark></p>
</li>
</ul>
<h3 id="122代码实现-3"><a class="markdownIt-Anchor" href="#122代码实现-3"></a> 1.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span>(s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       Map&lt;Character,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="type">int</span> max=Integer.MIN_VALUE;</span><br><span class="line">       <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">           <span class="type">char</span> ch=s.charAt(j);</span><br><span class="line">           <span class="keyword">if</span>(map.containsKey(ch))&#123;</span><br><span class="line">               left=Math.max( left, map.get(ch)+<span class="number">1</span>);  <span class="comment">//起始位置取原来的值 或者 重复字符的下一位</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//加入该字母</span></span><br><span class="line">           map.put(ch,j);</span><br><span class="line">           max=max&gt;j-left+<span class="number">1</span>?max:j-left+<span class="number">1</span>;			<span class="comment">//更新最长子串的长度</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="2找到字符串中所有字母异位词"><a class="markdownIt-Anchor" href="#2找到字符串中所有字母异位词"></a> 2.找到字符串中所有字母异位词</h1>
<h2 id="21题目-6"><a class="markdownIt-Anchor" href="#21题目-6"></a> 2.1题目</h2>
<p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p><strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abab&quot;, p = &quot;ab&quot;</span><br><span class="line">输出: [0,1,2]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br></pre></td></tr></table></figure>
<h2 id="22解法滑动窗口"><a class="markdownIt-Anchor" href="#22解法滑动窗口"></a> 2.2解法：滑动窗口</h2>
<h3 id="221解题思路"><a class="markdownIt-Anchor" href="#221解题思路"></a> 2.2.1解题思路</h3>
<ul>
<li>使用两个数组<mark>标记两个字符串</mark>（第一个字符串以滑动窗口不断活动，第二个字符串全部字符）<mark>中字符出现的次数</mark></li>
<li>通过比较个数组是否相等，从而<mark>判断第一个字符串中滑动窗口内的字符是否为第二个字符串的异位词</mark></li>
</ul>
<h3 id="222代码实现-3"><a class="markdownIt-Anchor" href="#222代码实现-3"></a> 2.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line"></span><br><span class="line">       List&lt;Integer&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span>(s.length()&lt;p.length())&#123;</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span>[] scount=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">       <span class="type">int</span>[] pcount=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">       <span class="comment">//1、遍历s字符串中以第一个字符为起始的字符串</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.length();i++)&#123;</span><br><span class="line">           scount[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">           pcount[p.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2、判断第一个滑动窗口是否满足</span></span><br><span class="line">       <span class="keyword">if</span>(Arrays.equals(scount,pcount))&#123;</span><br><span class="line">           res.add(<span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3、滑动窗口</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length()-p.length();i++)&#123;</span><br><span class="line">           <span class="comment">//3.1、原来的起始位置的字符取消</span></span><br><span class="line">           scount[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">           <span class="comment">//3.2、末尾的字符加一</span></span><br><span class="line">           scount[s.charAt(i+p.length())-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">           <span class="comment">//3.3、判断是否为异位词</span></span><br><span class="line">           <span class="keyword">if</span>(Arrays.equals(scount,pcount))&#123;</span><br><span class="line">               res.add(i+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="栈与队列"><a class="markdownIt-Anchor" href="#栈与队列"></a> <mark>栈与队列</mark></h1>
<h1 id="1有效的括号"><a class="markdownIt-Anchor" href="#1有效的括号"></a> 1.有效的括号</h1>
<h2 id="11题目-7"><a class="markdownIt-Anchor" href="#11题目-7"></a> 1.1题目</h2>
<p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'&#123;'</code>，<code>'&#125;'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号</li>
</ol>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<ul>
<li>示例三：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<h2 id="12解法栈"><a class="markdownIt-Anchor" href="#12解法栈"></a> 1.2解法：栈</h2>
<ol>
<li>
<p>题目核心：要求左括号隔壁要有对应的有括号匹配</p>
</li>
<li>
<p>讨论三种不匹配的情况</p>
<ul>
<li>
<p>字符串里左方向的括号多余了 ，所以不匹配</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2020080915505387.png" alt="括号匹配1" /></p>
</li>
<li>
<p>括号没有多余，但是 括号的类型没有匹配上</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200809155107397.png" alt="括号匹配2" /></p>
</li>
<li>
<p>字符串里右方向的括号多余了，所以不匹配。</p>
</li>
</ul>
</li>
<li>
<p>解法：栈</p>
<ul>
<li><mark>若为左括号，则将对应的右括号入栈</mark></li>
<li><mark>若为右括号，则取出栈顶元素，并判断是否该为右括号类型，不是返回false即可</mark></li>
<li>相当于左括号——&gt;同样类型的右括号进栈；右括号——&gt;出栈（并判断栈顶元素是否为该类型的右括号）</li>
</ul>
</li>
<li>
<p>注意：</p>
<ul>
<li>Java中Deuqe接口进栈方法为 push(i)；</li>
<li>查看栈顶元素方法为 peek()</li>
<li>取出栈顶元素方法为 pop()</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       Deque&lt;Character&gt; deque=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">           </span><br><span class="line">           <span class="type">char</span> c=s.charAt(i);</span><br><span class="line">           <span class="comment">//1、若为左括号，则将对应的右括号类型进栈</span></span><br><span class="line">           <span class="keyword">if</span>(c==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">               deque.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">               deque.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">               deque.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(deque.isEmpty() || deque.peek()!=c)&#123;</span><br><span class="line">               <span class="comment">//2、右括号，取出栈顶元素并判断是否为该右括号类型</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               deque.pop();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> deque.isEmpty();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="2删除字符串中的所有相邻重复项"><a class="markdownIt-Anchor" href="#2删除字符串中的所有相邻重复项"></a> 2.删除字符串中的所有相邻重复项</h1>
<h2 id="21题目-7"><a class="markdownIt-Anchor" href="#21题目-7"></a> 2.1题目</h2>
<p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;abbaca&quot;</span><br><span class="line">输出：&quot;ca&quot;</span><br><span class="line">解释：</span><br><span class="line">例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</span><br></pre></td></tr></table></figure>
<h2 id="22解法栈"><a class="markdownIt-Anchor" href="#22解法栈"></a> 2.2解法：栈</h2>
<ol>
<li>核心：使用栈解法</li>
<li>若为栈为空或者插入元素与栈顶元素不相同，则插入该元素；否则将栈顶元素出栈</li>
<li>最后遍历栈，将栈顶元素放置在字符串前面</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">       Deque&lt;Character&gt; deque=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">char</span> ch:arr)&#123;</span><br><span class="line">           <span class="keyword">if</span>(deque.isEmpty() || deque.peek()!=ch )&#123;</span><br><span class="line">               deque.push(ch);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               deque.pop();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">       <span class="keyword">while</span>(!deque.isEmpty())&#123;</span><br><span class="line">           str=deque.pop()+str;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> str;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="3逆波兰表达式求值"><a class="markdownIt-Anchor" href="#3逆波兰表达式求值"></a> 3.逆波兰表达式求值</h1>
<h2 id="31题目-5"><a class="markdownIt-Anchor" href="#31题目-5"></a> 3.1题目</h2>
<p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表示法</a> 表示的算术表达式。</p>
<p>请你计算该表达式。返回一个表示表达式值的整数。</p>
<p><strong>注意：</strong></p>
<ul>
<li>
<p>有效的算符为 <code>'+'</code>、<code>'-'</code>、<code>'*'</code> 和 <code>'/'</code> 。</p>
</li>
<li>
<p>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</p>
</li>
<li>
<p>两个整数之间的除法总是 <strong>向零截断</strong> 。</p>
</li>
<li>
<p>表达式中不含除零运算。</p>
</li>
<li>
<p>输入是一个根据逆波兰表示法表示的算术表达式。</p>
</li>
<li>
<p>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示</p>
</li>
<li>
<p>示例一：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">输出：9</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]</span><br><span class="line">输出：6</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span><br></pre></td></tr></table></figure>
<ul>
<li>示例三：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</span><br><span class="line">输出：22</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></table></figure>
<h2 id="32解法栈"><a class="markdownIt-Anchor" href="#32解法栈"></a> 3.2解法：栈</h2>
<ol>
<li>
<p>核心：使用栈解法</p>
</li>
<li>
<p>解析逆波兰表达式：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">( 1 + 2 ) * ( 3 + 4 )</span><br><span class="line"></span><br><span class="line">//逆波兰表达式</span><br><span class="line"> ( ( 1 2 + ) ( 3 4 + ) * ) </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>关键：四个关键字符：+、*、-、/：若为上述这个字符，则取出栈顶的两个元素，进行运算之后再放进栈里面</p>
</li>
<li>
<p>注意：-、/两个运算的特殊性：若num1为第一个栈顶元素，num2为第二个栈顶元素</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">duque.push( num2-num1 )</span><br><span class="line"></span><br><span class="line">duque.push( num2/num1 )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">       Deque&lt;Integer&gt; deque=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(String s:tokens)&#123;</span><br><span class="line">           <span class="keyword">if</span>(s.equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">               deque.push( deque.pop()+deque.pop() );</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;*&quot;</span>))&#123;</span><br><span class="line">               deque.push( deque.pop()*deque.pop() );</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">               <span class="type">int</span> num1=deque.pop();</span><br><span class="line">               <span class="type">int</span> num2=deque.pop();</span><br><span class="line">               deque.push( num2-num1 );</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">               <span class="type">int</span> num1=deque.pop();</span><br><span class="line">               <span class="type">int</span> num2=deque.pop();</span><br><span class="line">               deque.push( num2/num1);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               deque.push(Integer.valueOf(s));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> deque.pop();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树"></a> <mark>二叉树</mark></h1>
<h1 id="1二叉树理论基础"><a class="markdownIt-Anchor" href="#1二叉树理论基础"></a> 1.二叉树理论基础</h1>
<h2 id="11二叉树的种类"><a class="markdownIt-Anchor" href="#11二叉树的种类"></a> 1.1二叉树的种类</h2>
<p>二叉树可分为两种：满二叉树、完全二叉树</p>
<h3 id="111满二叉树"><a class="markdownIt-Anchor" href="#111满二叉树"></a> 1.1.1满二叉树</h3>
<ul>
<li>满二叉树：除了叶子节点以外，每个节点都有两个节点；（一棵二叉树只有度为0和度为2的节点，并且度为0的节点都在同一层）</li>
<li>深度为k的二叉树，一共有2^k-1个节点的二叉树
<ul>
<li>例如：深度为1的二叉树，一共有1个节点</li>
<li>例如：深度为2的二叉树，一共有2个节点</li>
</ul>
</li>
</ul>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806185805576.png" alt="img" /></p>
<h3 id="112完全二叉树"><a class="markdownIt-Anchor" href="#112完全二叉树"></a> 1.1.2完全二叉树</h3>
<ul>
<li>完全二叉树：除了最底层节点可能没填满之外，<mark>其余每层节点都达到最大值</mark>，并且最下面一层节点都集中在该层最左边的若干个位置</li>
</ul>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200920221638903.png" alt="img" /></p>
<h3 id="113二叉搜索树"><a class="markdownIt-Anchor" href="#113二叉搜索树"></a> 1.1.3二叉搜索树</h3>
<ol>
<li><strong>二叉搜索树是一个<mark>有序树</mark></strong></li>
<li>若它的左子树不空，则<mark>左子树上所有结点的值均小于它的根结点的值</mark>；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>下面两棵树都是搜索树</li>
</ol>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806190304693.png" alt="img" /></p>
<h3 id="114平衡二叉搜索树"><a class="markdownIt-Anchor" href="#114平衡二叉搜索树"></a> 1.1.4平衡二叉搜索树</h3>
<p>平衡二叉搜索树：又被称为<mark>AVL</mark>（Adelson-Velsky and Landis）树，且具有以下性质：它是<mark>一棵空树或它的左右两个子树的高度差的绝对值不超过1</mark>，并且左右两个子树都是一棵平衡二叉树。</p>
<p>如图：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806190511967.png" alt="img" /></p>
<h2 id="12二叉树的存储方式"><a class="markdownIt-Anchor" href="#12二叉树的存储方式"></a> 1.2二叉树的存储方式</h2>
<ol>
<li><strong>二叉树可以链式存储，也可以顺序存储。</strong></li>
<li>那么链式存储方式就用指针， 顺序存储的方式就是用数组。</li>
</ol>
<h3 id="121链式存储"><a class="markdownIt-Anchor" href="#121链式存储"></a> 1.2.1链式存储</h3>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2020092019554618.png" alt="img" /></p>
<h3 id="122顺序存储"><a class="markdownIt-Anchor" href="#122顺序存储"></a> 1.2.2顺序存储</h3>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200920200429452.png" alt="img" /></p>
<p>用数组存储二叉树的遍历方法：<strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p>
<h2 id="13二叉树的遍历方式"><a class="markdownIt-Anchor" href="#13二叉树的遍历方式"></a> 1.3二叉树的遍历方式</h2>
<p>二叉树主要有两种遍历方式：</p>
<ol>
<li>
<p><mark><strong>深度优先遍历</strong></mark>：先往深走，<mark>遇到叶子节点再往回走</mark>。</p>
<ul>
<li>前序遍历（递归法，迭代法）</li>
<li>中序遍历（递归法，迭代法）</li>
<li>后序遍历（递归法，迭代法）</li>
</ul>
</li>
<li>
<p><mark><strong>广度优先遍历</strong></mark>：一层一层的去遍历。</p>
<ul>
<li>层次遍历（迭代法）</li>
</ul>
</li>
<li>
<p>深度优先遍历中的前序、中序、后序三者的顺序，其实<strong>指的就是<mark>中间节点的遍历顺序</mark></strong></p>
<ul>
<li>前序遍历：中左右</li>
<li>中序遍历：左中右</li>
<li>后序遍历：左右中</li>
</ul>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806191109896.png" alt="img" /></p>
</li>
<li>
<p>深度优先遍历一般借助栈使用递归方式实现；广度优先遍历一般使用队列实现</p>
</li>
</ol>
<h2 id="14二叉树的定义"><a class="markdownIt-Anchor" href="#14二叉树的定义"></a> 1.4二叉树的定义</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2二叉树的递归遍历"><a class="markdownIt-Anchor" href="#2二叉树的递归遍历"></a> 2.二叉树的递归遍历</h1>
<p>递归算法的三个要素：</p>
<ol>
<li>
<p><strong><mark>确定递归函数的参数和返回值</mark>：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; result)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><mark>确定终止条件</mark>：</strong> 写完了递归算法，运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><mark>确定单层递归的逻辑</mark>：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result.add(root.val);</span><br><span class="line">preorder(root.left, result);</span><br><span class="line">preorder(root.right, result);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>下面给出Java的前中后序遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历·递归·LC144_二叉树的前序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        preorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(root.val);			<span class="comment">//中</span></span><br><span class="line">        preorder(root.left, result);	<span class="comment">//左</span></span><br><span class="line">        preorder(root.right, result);	<span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历·递归·LC94_二叉树的中序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, list);</span><br><span class="line">        list.add(root.val);             <span class="comment">// 注意这一句</span></span><br><span class="line">        inorder(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历·递归·LC145_二叉树的后序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root.left, list);</span><br><span class="line">        postorder(root.right, list);</span><br><span class="line">        list.add(root.val);             <span class="comment">// 注意这一句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3二叉树的迭代遍历"><a class="markdownIt-Anchor" href="#3二叉树的迭代遍历"></a> 3.二叉树的迭代遍历</h1>
<ol>
<li>迭代遍历即非递归遍历</li>
<li>递归遍历中，<mark>每一次递归调用</mark>都会把<mark>函数的局部变量、参数值和返回地址</mark>等压入调用栈中</li>
<li>迭代遍历可以使用栈实现，下面以前序遍历举例：
<ul>
<li>先将根节点放入栈中，加入右孩子、加入左孩子</li>
<li><mark>出栈的时候，才是左孩子第一个出栈</mark></li>
</ul>
</li>
</ol>
<h2 id="31前序遍历迭代法"><a class="markdownIt-Anchor" href="#31前序遍历迭代法"></a> 3.1前序遍历（迭代法）</h2>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif" alt="二叉树前序遍历（迭代法）" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历顺序：中-左-右，入栈顺序：中-右-左</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);					<span class="comment">//将该根节点入栈</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();	<span class="comment">//取出栈的第一个元素</span></span><br><span class="line">            result.add(node.val);			</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>)&#123;		<span class="comment">//将该元素的右孩子入栈</span></span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>)&#123;			<span class="comment">//将该元素的左孩子入栈（这样左孩子就可以先出栈了）</span></span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="32中序遍历迭代法"><a class="markdownIt-Anchor" href="#32中序遍历迭代法"></a> 3.2中序遍历（迭代法）</h2>
<ol>
<li>前序遍历迭代的过程中的两个操作：
<ol>
<li>处理：将该元素放进result数组中</li>
<li>访问：遍历该节点的左右孩子</li>
</ol>
</li>
<li>而<mark>前序遍历迭代过程中的两个操作都是基于该中间节点</mark></li>
<li>而中序遍历（左中右）
<ol>
<li>访问：最先访问的是二叉树顶部节点，再一层一层向下遍历，直到到达树左边的的最底部；</li>
<li>处理：到达最底部后，再处理节点（将节点放进数组）</li>
<li><mark>故此造成处理顺序和访问顺序不一致</mark></li>
</ol>
</li>
<li>中序遍历的解决思路：
<ol>
<li><mark>先访问，再处理</mark>
<ol>
<li>访问：先通过==<strong>指针，</strong>==逐渐遍历根节点的左孩子，并将其入栈，直到到达左边最底端</li>
<li>处理：若指针为空，则弹出栈的第一个节点，<mark>并将其数值添加到数组中</mark>，同时指针指向该节点的右孩子</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif" alt="二叉树中序遍历（迭代法）" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历顺序: 左-中-右 入栈顺序： 左-右</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">if</span> (cur != <span class="literal">null</span>)&#123;					<span class="comment">//访问该节点的最底层</span></span><br><span class="line">               stack.push(cur);					<span class="comment">//将访问的节点进栈</span></span><br><span class="line">               cur = cur.left;					<span class="comment">//左</span></span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               cur = stack.pop();				<span class="comment">//遍历到最底层，弹出第一个数据</span></span><br><span class="line">               result.add(cur.val);				<span class="comment">//加入该数据</span></span><br><span class="line">               cur = cur.right;					<span class="comment">//右</span></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="33后序遍历迭代法"><a class="markdownIt-Anchor" href="#33后序遍历迭代法"></a> 3.3后序遍历（迭代法）</h2>
<ol>
<li>后续遍历是<mark>左右中</mark>，那么我们只需要调整一下==<strong>先序遍历（中左右）</strong><mark>的代码顺序，就变成</mark>中右左==的遍历顺序</li>
<li>然后在反转result数组，输出的结果顺序就是左右中了</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);						<span class="comment">//入中</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);			<span class="comment">//入左</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);			<span class="comment">//入右</span></span><br><span class="line">            &#125;									<span class="comment">//这样遍历的时候就是 中右左</span></span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);	<span class="comment">//反转：左右中</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4二叉树的统一迭代法"><a class="markdownIt-Anchor" href="#4二叉树的统一迭代法"></a> 4.二叉树的统一迭代法</h1>
<h2 id="41问题分析及解决思路"><a class="markdownIt-Anchor" href="#41问题分析及解决思路"></a> 4.1问题分析及解决思路</h2>
<ol>
<li>在第三部分中，我们通过栈，来模拟递归调用，实现了二叉树的深度优先遍历（前序、中序、后续遍历）</li>
<li>前序遍历（中左右）和后序遍历（左右中）代码差不多，因为只需调整下前序遍历代码中 左孩子先入栈，右孩子再入栈，遍历的时候就是先遍历有孩子。故此得出来是 （中右左）的顺序，只需反转下数组，即可得出后序遍历（左右中）的顺序</li>
<li>问题：中序遍历代码风格不同
<ul>
<li>原因：在迭代的过程中，两个操作（处理和访问的对象不一致）</li>
<li>解决思路：将访问的节点放入栈中，并把<mark>已经访问过，待处理（进入数组）的节点</mark>做上标记（在处理节点放入栈后，紧接着放入一个空指针作为标记）。</li>
</ul>
</li>
</ol>
<h2 id="42中序遍历统一迭代法"><a class="markdownIt-Anchor" href="#42中序遍历统一迭代法"></a> 4.2中序遍历（统一迭代法）</h2>
<ul>
<li>中序遍历：左中右</li>
</ul>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%EF%BC%88%E7%BB%9F%E4%B8%80%E5%86%99%E6%B3%95%EF%BC%89.gif" alt="中序遍历迭代（统一写法）" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    	Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    	<span class="keyword">if</span> (root != <span class="literal">null</span>) </span><br><span class="line">           st.push(root);</span><br><span class="line">        </span><br><span class="line">    	<span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">        	<span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">        	<span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            	st.pop(); 								<span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                </span><br><span class="line">	            <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) </span><br><span class="line">                    st.push(node.right);  				<span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">                </span><br><span class="line">    	        st.push(node);                         <span class="comment">// 添加中节点</span></span><br><span class="line">        	    st.push(<span class="literal">null</span>); 						   <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">	</span><br><span class="line">    	        <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) </span><br><span class="line">                    st.push(node.left); <span class="comment">// 添加左节点（空节点不入栈）   </span></span><br><span class="line">                						</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123; 					<span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">           		st.pop();           	<span class="comment">// 将空节点弹出</span></span><br><span class="line">	            node = st.peek();       <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">    	        st.pop();</span><br><span class="line">        	    result.add(node.val);   <span class="comment">// 加入到结果集</span></span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="43前序遍历"><a class="markdownIt-Anchor" href="#43前序遍历"></a> 4.3前序遍历</h2>
<ul>
<li>前序遍历：中左右</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.pop();</span><br><span class="line">                result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="44后序遍历"><a class="markdownIt-Anchor" href="#44后序遍历"></a> 4.4后序遍历</h2>
<ul>
<li>后序遍历：左右中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                </span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.pop();</span><br><span class="line">                result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5二叉树的层序遍历"><a class="markdownIt-Anchor" href="#5二叉树的层序遍历"></a> 5.二叉树的层序遍历</h1>
<h2 id="51-102_二叉树的层序遍历"><a class="markdownIt-Anchor" href="#51-102_二叉树的层序遍历"></a> 5.1 102_二叉树的层序遍历</h2>
<h3 id="511问题"><a class="markdownIt-Anchor" href="#511问题"></a> 5.1.1问题</h3>
<p>给你一个二叉树，请你返回其按 <mark><strong>层序遍历</strong></mark> 得到的节点值。 （即<mark>逐层地，从左到右访问所有节点</mark>）。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210203144842988.png" alt="102.二叉树的层序遍历" /></p>
<h3 id="512解法队列"><a class="markdownIt-Anchor" href="#512解法队列"></a> 5.1.2解法：队列</h3>
<ol>
<li>层序遍历需要借用一个辅助数据结构，即==<strong>队列</strong>==来实现</li>
<li><mark>队列先进先出</mark>，符合<mark>一层一层遍历的逻辑</mark></li>
<li>首先将根节点添加到队列中，接着开启一个循环（只要队列不为空，就一直循环）
<ol>
<li>在每次循环中，先<mark>拿到此时队列的长度</mark></li>
<li>接着<mark>依次取出<strong>此时</strong>队列的全部节点（先进先出）</mark>，并处理该元素</li>
<li>若该节点的左孩子不为空，则添加进队列；若该节点的右孩子不为空，则添加进队列</li>
<li>每次循环中，将处理完的list数组添加到返回值即可</li>
</ol>
</li>
</ol>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.gif" alt="102二叉树的层序遍历" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、借助队列实现：先进先出</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加根节点到队列</span></span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//只要队列不为空，就一直循环</span></span><br><span class="line">            List&lt;Integer&gt; tmp=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">//取出队列全部元素</span></span><br><span class="line">            <span class="type">int</span> len=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="comment">//添加值</span></span><br><span class="line">                tmp.add(node.val);                                 </span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            list.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="52-107_二叉树的层序遍历"><a class="markdownIt-Anchor" href="#52-107_二叉树的层序遍历"></a> 5.2 107_二叉树的层序遍历||</h2>
<h3 id="521问题"><a class="markdownIt-Anchor" href="#521问题"></a> 5.2.1问题</h3>
<p>给定一个二叉树，返回其==<strong>节点值自底向上</strong>==的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210203151058308.png" alt="107.二叉树的层次遍历II" /></p>
<h3 id="522解法队列"><a class="markdownIt-Anchor" href="#522解法队列"></a> 5.2.2解法：队列</h3>
<ol>
<li>思路：跟上一题一样，使用队列解决</li>
<li>由于是自底向上，所以结果反转list即可</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//遍历该层</span></span><br><span class="line">            List&lt;Integer&gt; tmp=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> len=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将该层结果添加到返回list中</span></span><br><span class="line">            list.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反转，也可以新建一个list，从后往前遍历原来的list</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="53-199_二叉树的右视图"><a class="markdownIt-Anchor" href="#53-199_二叉树的右视图"></a> 5.3 199_二叉树的右视图</h2>
<h3 id="531问题"><a class="markdownIt-Anchor" href="#531问题"></a> 5.3.1问题</h3>
<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1,3,4]</span><br></pre></td></tr></table></figure>
<h3 id="532解决队列"><a class="markdownIt-Anchor" href="#532解决队列"></a> 5.3.2解决：队列</h3>
<ol>
<li>思路：层序遍历，将每层的最右节点添加到返回list中即可</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> len=queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                </span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(i==len-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//每层的最后一个</span></span><br><span class="line">                    list.add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="54-637_二叉树的层平均值"><a class="markdownIt-Anchor" href="#54-637_二叉树的层平均值"></a> 5.4 637_二叉树的层平均值</h2>
<h3 id="541问题"><a class="markdownIt-Anchor" href="#541问题"></a> 5.4.1问题</h3>
<p>给定一个非空二叉树的根节点 <code>root</code> , 以数组的形式返回每一层节点的平均值。与实际答案相差 <code>10-5</code> 以内的答案可以被接受。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[3.00000,14.50000,11.00000]</span><br><span class="line">解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。</span><br><span class="line">因此返回 [3, 14.5, 11] 。</span><br></pre></td></tr></table></figure>
<h3 id="542解决队列"><a class="markdownIt-Anchor" href="#542解决队列"></a> 5.4.2解决：队列</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Double&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//遍历该层</span></span><br><span class="line">            <span class="type">int</span> len=queue.size();</span><br><span class="line">            Double tmp=<span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                tmp+=node.val;</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将该层结果添加到返回list中</span></span><br><span class="line">            list.add(tmp/len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="55-429_n叉树的层序遍历"><a class="markdownIt-Anchor" href="#55-429_n叉树的层序遍历"></a> 5.5 429_N叉树的层序遍历</h2>
<h3 id="551问题"><a class="markdownIt-Anchor" href="#551问题"></a> 5.5.1问题</h3>
<p>给定一个 N 叉树，返回其节点值的<em>层序遍历</em>。（即从左到右，逐层遍历）。</p>
<p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,3,2,4,null,5,6]</span><br><span class="line">输出：[[1],[3,2,4],[5,6]]</span><br></pre></td></tr></table></figure>
<h3 id="552解法层序遍历栈"><a class="markdownIt-Anchor" href="#552解法层序遍历栈"></a> 5.5.2解法：层序遍历+栈</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        Queue&lt;Node&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125; </span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> len=queue.size();</span><br><span class="line">            List&lt;Integer&gt; tmp=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                Node node=queue.poll();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//由左右节点变成孩子节点</span></span><br><span class="line">                List&lt;Node&gt; childrens=node.children;</span><br><span class="line">                <span class="keyword">for</span>(Node children:childrens)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(children!=<span class="literal">null</span>)&#123;</span><br><span class="line">                        queue.offer(children);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="56-515_在每个树行中找最大值"><a class="markdownIt-Anchor" href="#56-515_在每个树行中找最大值"></a> 5.6 515_在每个树行中找最大值</h2>
<h3 id="561问题"><a class="markdownIt-Anchor" href="#561问题"></a> 5.6.1问题</h3>
<p>给定一棵二叉树的根节点 <code>root</code> ，请找出该二叉树中每一层的最大值。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2020/08/21/largest_e1.jpg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [1,3,2,5,3,null,9]</span><br><span class="line">输出: [1,3,9]</span><br></pre></td></tr></table></figure>
<h3 id="562解法层序遍历"><a class="markdownIt-Anchor" href="#562解法层序遍历"></a> 5.6.2解法：层序遍历</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">largestValues</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> len=queue.size();</span><br><span class="line">            <span class="type">int</span> max=Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">while</span>(len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                max=max&gt;node.val?max:node.val;</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="57-116_填充每个节点的下一个右侧节点指针"><a class="markdownIt-Anchor" href="#57-116_填充每个节点的下一个右侧节点指针"></a> 5.7 116_填充每个节点的下一个右侧节点指针</h2>
<h3 id="571问题"><a class="markdownIt-Anchor" href="#571问题"></a> 5.7.1问题</h3>
<p>给定一个 <strong><mark>完美二叉树</mark></strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p>
<p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5,6,7]</span><br><span class="line">输出：[1,#,2,3,#,4,5,6,7,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#x27;#&#x27; 标志着每一层的结束。</span><br></pre></td></tr></table></figure>
<h3 id="572解法层序遍历"><a class="markdownIt-Anchor" href="#572解法层序遍历"></a> 5.7.2解法：层序遍历</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        Queue&lt;Node&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; </span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> len=queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                Node node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(i==len-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//最后一个节点</span></span><br><span class="line">                    node.next=<span class="literal">null</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//非最后一个节点</span></span><br><span class="line">                   node.next=queue.peek();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="58-116_填充每个节点的下一个右侧节点指针"><a class="markdownIt-Anchor" href="#58-116_填充每个节点的下一个右侧节点指针"></a> 5.8 116_填充每个节点的下一个右侧节点指针||</h2>
<h3 id="581问题"><a class="markdownIt-Anchor" href="#581问题"></a> 5.8.1问题</h3>
<p>给定一个二叉树：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code> 。</p>
<p>初始状态下，所有 next 指针都被设置为 <code>NULL</code> 。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5,null,7]</span><br><span class="line">输出：[1,#,2,3,#,4,5,7,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），&#x27;#&#x27; 表示每层的末尾。</span><br></pre></td></tr></table></figure>
<h3 id="582解法层序遍历"><a class="markdownIt-Anchor" href="#582解法层序遍历"></a> 5.8.2解法：层序遍历</h3>
<p>这道题目说是二叉树，但116题目说是完整二叉树，其实没有任何差别，一样的代码一样的逻辑</p>
<h2 id="59-104_二叉树的最大深度"><a class="markdownIt-Anchor" href="#59-104_二叉树的最大深度"></a> 5.9 104_二叉树的最大深度</h2>
<h3 id="591问题"><a class="markdownIt-Anchor" href="#591问题"></a> 5.9.1问题</h3>
<p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p>
<p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<h3 id="592解法层序遍历"><a class="markdownIt-Anchor" href="#592解法层序遍历"></a> 5.9.2解法：层序遍历</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> len=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                len--;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            max++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="510-111_二叉树的最小深度"><a class="markdownIt-Anchor" href="#510-111_二叉树的最小深度"></a> 5.10 111_二叉树的最小深度</h2>
<h3 id="5101问题"><a class="markdownIt-Anchor" href="#5101问题"></a> 5.10.1问题</h3>
<p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>**说明：**叶子节点是指没有子节点的节点。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<h3 id="5102解决"><a class="markdownIt-Anchor" href="#5102解决"></a> 5.10.2解决</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> len=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//注意：若该节点的左右孩子均为空，则到达最低点</span></span><br><span class="line">                <span class="keyword">if</span>(node.left==<span class="literal">null</span> &amp;&amp; node.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                    max++;  <span class="comment">//算上该层</span></span><br><span class="line">                    <span class="keyword">return</span> max;</span><br><span class="line">                &#125;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            max++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6翻转二叉树"><a class="markdownIt-Anchor" href="#6翻转二叉树"></a> 6.翻转二叉树</h1>
<h2 id="61问题"><a class="markdownIt-Anchor" href="#61问题"></a> 6.1问题</h2>
<p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>
<h2 id="62解法一递归"><a class="markdownIt-Anchor" href="#62解法一递归"></a> 6.2解法一：递归</h2>
<h3 id="621递归思路"><a class="markdownIt-Anchor" href="#621递归思路"></a> 6.2.1递归思路</h3>
<h4 id="1确定递归函数的参数和返回值"><a class="markdownIt-Anchor" href="#1确定递归函数的参数和返回值"></a> （1）确定递归函数的参数和返回值</h4>
<ul>
<li>题目为翻转根节点的左右孩子</li>
<li>最后返回根节点，即每次递归，传入TreeNode节点，返回该节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">reverse</span><span class="params">(TreeNode node)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="2确定终止条件"><a class="markdownIt-Anchor" href="#2确定终止条件"></a> （2）确定终止条件</h4>
<ul>
<li>当递归到的该节点为空，即返回</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node==<span class="literal">null</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3确定单层递归的逻辑"><a class="markdownIt-Anchor" href="#3确定单层递归的逻辑"></a> （3）确定单层递归的逻辑</h4>
<ul>
<li>当确定该节点不为空，先交换左、右孩子</li>
<li>再分别递归左孩子、右孩子</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">swap(node);</span><br><span class="line">reverse(node.left);</span><br><span class="line">reverse(node.right);</span><br></pre></td></tr></table></figure>
<h3 id="622全部代码"><a class="markdownIt-Anchor" href="#622全部代码"></a> 6.2.2全部代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverse(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">reverse</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(node);</span><br><span class="line">        reverse(node.left);</span><br><span class="line">        reverse(node.right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        TreeNode tmp=node.left;</span><br><span class="line">        node.left=node.right;</span><br><span class="line">        node.right=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="63解法二层序遍历"><a class="markdownIt-Anchor" href="#63解法二层序遍历"></a> 6.3解法二：层序遍历</h2>
<ol>
<li>将每一个从队列取出来的元素，进行左孩子和有孩子的交换</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//广度优先遍历</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                swap(node);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        TreeNode tmp=node.left;</span><br><span class="line">        node.left=node.right;</span><br><span class="line">        node.right=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="7对称二叉树"><a class="markdownIt-Anchor" href="#7对称二叉树"></a> 7.对称二叉树</h1>
<h2 id="71问题"><a class="markdownIt-Anchor" href="#71问题"></a> 7.1问题</h2>
<p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://pic.leetcode.cn/1698026966-JDYPDU-image.png" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<h2 id="72解法一递归"><a class="markdownIt-Anchor" href="#72解法一递归"></a> 7.2解法一：递归</h2>
<h3 id="721递归思路"><a class="markdownIt-Anchor" href="#721递归思路"></a> 7.2.1递归思路</h3>
<h4 id="1确定递归函数的参数和返回值-2"><a class="markdownIt-Anchor" href="#1确定递归函数的参数和返回值-2"></a> （1）确定递归函数的参数和返回值</h4>
<ol>
<li>比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要<mark>比较的是两个树，参数自然也是左子树节点和右子树节点</mark>。</li>
<li>返回值为boolean类型</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left,TreeNode right)</span></span><br></pre></td></tr></table></figure>
<h4 id="2确定终止条件-2"><a class="markdownIt-Anchor" href="#2确定终止条件-2"></a> （2）确定终止条件</h4>
<ol>
<li>首先排除左孩子、右孩子节点有空的情况
<ul>
<li>左孩子为空，右孩子不为空：return false</li>
<li>左孩子不为空，右孩子为空：return false</li>
<li>左、右孩子均为空：return true</li>
</ul>
</li>
<li>左、右孩子均不为空：
<ul>
<li>比较左右孩子的数值，不相同：return false</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (left == NULL &amp;&amp; right != NULL) </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left != NULL &amp;&amp; right == NULL) </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left == NULL &amp;&amp; right == NULL) </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 注意这里我没有使用else</span></span><br></pre></td></tr></table></figure>
<h4 id="3确定单层递归的逻辑-2"><a class="markdownIt-Anchor" href="#3确定单层递归的逻辑-2"></a> （3）确定单层递归的逻辑</h4>
<ul>
<li>单层递归的逻辑就是处理左右节点都不为空，且数值相同的情况。
<ul>
<li><mark>比较二叉树外侧是否对称</mark>：传入的是左节点的左孩子，右节点的右孩子。</li>
<li>比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。</li>
<li>如果左右都对称就返回true ，有一侧不对称就返回false 。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">outside</span> <span class="operator">=</span> compare(left.left, right.right);   <span class="comment">// 左子树：左、 右子树：右</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">inside</span> <span class="operator">=</span> compare(left.right, right.left);    <span class="comment">// 左子树：右、 右子树：左</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isSame</span> <span class="operator">=</span> outside &amp;&amp; inside;                    <span class="comment">// 左子树：中、 右子树：中（逻辑处理）</span></span><br><span class="line"><span class="keyword">return</span> isSame;</span><br></pre></td></tr></table></figure>
<h3 id="722代码实现-2"><a class="markdownIt-Anchor" href="#722代码实现-2"></a> 7.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> compare(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left,TreeNode right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">null</span> &amp;&amp; right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left!=<span class="literal">null</span> &amp;&amp; right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left==<span class="literal">null</span> &amp;&amp; right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left.val!=right.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//单层递归逻辑</span></span><br><span class="line">        <span class="type">boolean</span> out=compare(left.left,right.right);</span><br><span class="line">        <span class="type">boolean</span> in=compare(left.right,right.left);</span><br><span class="line">        <span class="keyword">return</span> (out&amp;&amp;in);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="73解法二迭代法"><a class="markdownIt-Anchor" href="#73解法二迭代法"></a> 7.3解法二：迭代法</h2>
<ol>
<li>使用队列来比较两个树（根节点的左右子树）是否相互翻转，（<strong>注意这不是层序遍历</strong>）</li>
</ol>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.gif" alt="101.对称二叉树" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//迭代法</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加根节点的左右孩子</span></span><br><span class="line">        queue.offer(root.left);</span><br><span class="line">        queue.offer(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode left=queue.poll();</span><br><span class="line">            TreeNode right=queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1、判断两个节点是否均为空</span></span><br><span class="line">            <span class="keyword">if</span>(left==<span class="literal">null</span> &amp;&amp; right==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;   <span class="comment">//对称，结束此次循环，再次取出新的两个节点判断</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2、判断不符合对称条件</span></span><br><span class="line">            <span class="keyword">if</span>(left==<span class="literal">null</span> || right==<span class="literal">null</span> || (left.val!=right.val))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3、添加新的两个节点：外层+内层</span></span><br><span class="line">            queue.offer(left.left);</span><br><span class="line">            queue.offer(right.right);</span><br><span class="line"></span><br><span class="line">            queue.offer(left.right);</span><br><span class="line">            queue.offer(right.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="8完全二叉树的节点个数"><a class="markdownIt-Anchor" href="#8完全二叉树的节点个数"></a> 8.完全二叉树的节点个数</h1>
<h2 id="81问题"><a class="markdownIt-Anchor" href="#81问题"></a> 8.1问题</h2>
<p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1~ 2h</code> 个节点。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5,6]</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>
<h2 id="82解法一递归"><a class="markdownIt-Anchor" href="#82解法一递归"></a> 8.2解法一：递归</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> leftCount=count(node.left);</span><br><span class="line">        <span class="type">int</span> rightCount=count(node.right);</span><br><span class="line">        <span class="keyword">return</span> leftCount+rightCount+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="83解法二层序遍历"><a class="markdownIt-Anchor" href="#83解法二层序遍历"></a> 8.3解法二：层序遍历</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//广度优先遍历</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            count+=size;</span><br><span class="line">            <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="9平衡二叉树"><a class="markdownIt-Anchor" href="#9平衡二叉树"></a> 9.平衡二叉树</h1>
<h2 id="91问题"><a class="markdownIt-Anchor" href="#91问题"></a> 9.1问题</h2>
<p>给定一个二叉树，判断它是否是 平衡二叉树</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<h2 id="92解法一递归"><a class="markdownIt-Anchor" href="#92解法一递归"></a> 9.2解法一：递归</h2>
<h3 id="921递归思路"><a class="markdownIt-Anchor" href="#921递归思路"></a> 9.2.1递归思路</h3>
<h4 id="1确定递归函数返回值和参数值"><a class="markdownIt-Anchor" href="#1确定递归函数返回值和参数值"></a> （1）确定递归函数返回值和参数值</h4>
<ol>
<li>题目为确定一棵树是否为平衡树</li>
<li>平衡树的定义：一棵树为空或者其左右节点的高度差的绝对值不超过1</li>
<li>即递归函数参数为一个树节点，返回值为该节点的高度（注意：若返回-1，则表明该树不平衡）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isBalancedTree</span><span class="params">(TreeNode node)</span></span><br></pre></td></tr></table></figure>
<h4 id="2确定终止条件-3"><a class="markdownIt-Anchor" href="#2确定终止条件-3"></a> （2）确定终止条件</h4>
<ol>
<li>若该节点为null，返回0</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node==<span class="literal">null</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3确定递归逻辑"><a class="markdownIt-Anchor" href="#3确定递归逻辑"></a> （3）确定递归逻辑</h4>
<ol>
<li>传入一个节点，要求返回其高度，即需要求其左、右节点的高度</li>
<li>分别求完左、右节点的高度之后，判断其中是否为-1，若为-1，则返回-1，代表不平衡</li>
<li>若均不为-1，则求出该节点的平衡因子，若其绝对值超过1，则返回-1，代表不平衡</li>
<li>否则返回当前节点为根节点的树的<mark>最大高度</mark></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> leftHeight=isBalancedTree(node.left);</span><br><span class="line"><span class="type">int</span> rightHeight=isBalancedTree(node.right);</span><br><span class="line"><span class="keyword">if</span>(leftHeight==-<span class="number">1</span> || rightHeight==-<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Math.abs(leftHeight-rightHeight)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>+Math(leftHeight,rightHeight);</span><br></pre></td></tr></table></figure>
<h3 id="922代码"><a class="markdownIt-Anchor" href="#922代码"></a> 9.2.2代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isBalancedTree(root)!=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">isBalancedTree</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> leftHeight=isBalancedTree(node.left);</span><br><span class="line">        <span class="type">int</span> rightHeight=isBalancedTree(node.right);</span><br><span class="line">        <span class="keyword">if</span>(leftHeight==-<span class="number">1</span> || rightHeight==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(leftHeight-rightHeight)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+Math.max(leftHeight,rightHeight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="10完全二叉树的所有路径"><a class="markdownIt-Anchor" href="#10完全二叉树的所有路径"></a> 10.完全二叉树的所有路径</h1>
<h2 id="101问题"><a class="markdownIt-Anchor" href="#101问题"></a> 10.1问题</h2>
<p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,null,5]</span><br><span class="line">输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</span><br></pre></td></tr></table></figure>
<h2 id="102解法一前序遍历回溯"><a class="markdownIt-Anchor" href="#102解法一前序遍历回溯"></a> 10.2解法一：前序遍历+回溯</h2>
<ol>
<li>题目要求从根节点到叶子的路径，所以需要前序遍历，这样才方便让<mark>父节点指向孩子节点，找到对应的路径</mark></li>
<li>把路径记录下来，需要回溯来回退一个路径再进入另一个路径。</li>
</ol>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240327153241191.png" alt="image-20240327153241191" /></p>
<h3 id="1021递归思路"><a class="markdownIt-Anchor" href="#1021递归思路"></a> 10.2.1递归思路</h3>
<h4 id="1确定递归函数参数以及返回值"><a class="markdownIt-Anchor" href="#1确定递归函数参数以及返回值"></a> （1）确定递归函数参数以及返回值</h4>
<ol>
<li>求根节点到达该ndoe节点的路径</li>
<li>paths存放路径值</li>
<li>res存放最终结果</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode node,List&lt;Integer&gt; paths,List&lt;String&gt; res)</span></span><br></pre></td></tr></table></figure>
<h4 id="2确定递归终止条件"><a class="markdownIt-Anchor" href="#2确定递归终止条件"></a> （2）确定递归终止条件</h4>
<ol>
<li>当遍历到了叶子节点，即为一条完整的路径</li>
<li>取出paths的全部节点，并加入到res中</li>
<li>直接return</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node.left==<span class="literal">null</span> &amp;&amp; node.right==<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();<span class="comment">// StringBuilder用来拼接字符串，速度更快</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; paths.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    	sb.append(paths.get(i)).append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(paths.get(paths.size() - <span class="number">1</span>));<span class="comment">// 记录最后一个节点</span></span><br><span class="line">    res.add(sb.toString());<span class="comment">// 收集一个路径</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3确定递归逻辑-2"><a class="markdownIt-Anchor" href="#3确定递归逻辑-2"></a> （3）确定递归逻辑</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归和回溯是同时进行，所以要放在同一个花括号里</span></span><br><span class="line">     <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123; <span class="comment">// 左</span></span><br><span class="line">         traversal(root.left, paths, res);</span><br><span class="line">         paths.remove(paths.size() - <span class="number">1</span>);<span class="comment">// 回溯</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123; <span class="comment">// 右</span></span><br><span class="line">         traversal(root.right, paths, res);</span><br><span class="line">         paths.remove(paths.size() - <span class="number">1</span>);<span class="comment">// 回溯</span></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1022代码实现-2"><a class="markdownIt-Anchor" href="#1022代码实现-2"></a> 10.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; paths=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        traversal(root,paths,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode node,List&lt;Integer&gt; paths,List&lt;String&gt; res)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1、前序遍历（中左右）处理该节点</span></span><br><span class="line">        paths.add(node.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、终止条件：该节点为叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(node.left==<span class="literal">null</span> &amp;&amp; node.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;paths.size()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">                sb.append(paths.get(i)).append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//加入最后一个节点</span></span><br><span class="line">            sb.append(paths.get(paths.size()-<span class="number">1</span>));</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、递归逻辑+回溯</span></span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            traversal(node.left,paths,res);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            paths.remove(paths.size() - <span class="number">1</span>); <span class="comment">//去除最后一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            traversal(node.right,paths,res);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            paths.remove(paths.size() - <span class="number">1</span>); <span class="comment">//去除最后一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="11左叶子之和"><a class="markdownIt-Anchor" href="#11左叶子之和"></a> 11.左叶子之和</h1>
<h2 id="111问题"><a class="markdownIt-Anchor" href="#111问题"></a> 11.1问题</h2>
<p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,9,20,null,null,15,7] </span><br><span class="line">输出: 24 </span><br><span class="line">解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</span><br></pre></td></tr></table></figure>
<h2 id="112解法一递归"><a class="markdownIt-Anchor" href="#112解法一递归"></a> 11.2解法一：递归</h2>
<ol>
<li>题目要求求左叶子之和，那什么是左叶子呢？</li>
<li>左叶子即：<strong>节点A的左孩子不为空，且左孩子的左右孩子都为空（说明是叶子节点），那么<mark>A节点的左孩子为左叶子节点</mark></strong></li>
<li>因此我们需要根据孩子的父节点来判断，该孩子是否为左叶子节点</li>
</ol>
<h3 id="1121递归思路"><a class="markdownIt-Anchor" href="#1121递归思路"></a> 11.2.1递归思路</h3>
<ol>
<li>递归遍历以root为根节点的树，求其左叶子之和</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>结束条件：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以不用加下面这段代码</span></span><br><span class="line"><span class="comment">//若为叶子节点则不用递归了，因为我们根据父节点来进行递归</span></span><br><span class="line"><span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>递归逻辑
<ol>
<li>递归求左节点的左叶子之和
<ol>
<li>若该节点的左孩子为左叶子，即找到了以该节点为根节点的左叶子之和</li>
</ol>
</li>
<li>递归求右节点的左叶子之和</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> leftValue=sumOfLeftLeaves(root.left);</span><br><span class="line"><span class="keyword">if</span>(root.left!=<span class="literal">null</span> &amp;&amp; root.left.left==<span class="literal">null</span> &amp;&amp; root.left.right==<span class="literal">null</span>)&#123;</span><br><span class="line">	leftValue=root.left.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> rightValue=sumOfLeftLeaves(root.right);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> leftValue+rightValue;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br></pre></td></tr></table></figure>
<h3 id="1122代码实现"><a class="markdownIt-Anchor" href="#1122代码实现"></a> 11.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftValue=sumOfLeftLeaves(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span> &amp;&amp; root.left.left==<span class="literal">null</span> &amp;&amp; root.left.right==<span class="literal">null</span>)&#123;</span><br><span class="line">	        leftValue=root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> rightValue=sumOfLeftLeaves(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> leftValue+rightValue;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="113解法二栈"><a class="markdownIt-Anchor" href="#113解法二栈"></a> 11.3解法二：栈</h2>
<h3 id="1131栈思想"><a class="markdownIt-Anchor" href="#1131栈思想"></a> 11.3.1栈思想</h3>
<ol>
<li>使用栈模拟实现递归</li>
<li>思想为<mark>中左右/中右左</mark></li>
</ol>
<h3 id="1132代码实现"><a class="markdownIt-Anchor" href="#1132代码实现"></a> 11.3.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node=stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="literal">null</span> &amp;&amp; node.left.left==<span class="literal">null</span> &amp;&amp; node.left.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//该node节点的左孩子为左叶子</span></span><br><span class="line">                sum+=node.left.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="12找树左下角的值"><a class="markdownIt-Anchor" href="#12找树左下角的值"></a> 12.找树左下角的值</h1>
<h2 id="121问题"><a class="markdownIt-Anchor" href="#121问题"></a> 12.1问题</h2>
<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p>
<p>假设二叉树中至少有一个节点。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [2,1,3]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<h2 id="122解法一层序遍历"><a class="markdownIt-Anchor" href="#122解法一层序遍历"></a> 12.2解法一：层序遍历</h2>
<ol>
<li>只需在每层遍历的时候，标记最左边的元素即可</li>
<li>注意，节点的左右孩子的放入队列顺序：左孩子先（先进先出）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//层序遍历</span></span><br><span class="line">        <span class="type">int</span> leftValue=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//每一层的最左边</span></span><br><span class="line">                    leftValue=node.val;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="13路径总和"><a class="markdownIt-Anchor" href="#13路径总和"></a> 13.路径总和</h1>
<h2 id="131问题"><a class="markdownIt-Anchor" href="#131问题"></a> 13.1问题</h2>
<p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><br><span class="line">输出：true</span><br><span class="line">解释：等于目标和的根节点到叶节点路径如上图所示。</span><br></pre></td></tr></table></figure>
<h2 id="132解法一递归"><a class="markdownIt-Anchor" href="#132解法一递归"></a> 13.2解法一：递归</h2>
<h3 id="1321递归思路"><a class="markdownIt-Anchor" href="#1321递归思路"></a> 13.2.1递归思路</h3>
<h4 id="1确定递归函数参数以及返回值-2"><a class="markdownIt-Anchor" href="#1确定递归函数参数以及返回值-2"></a> （1）确定递归函数参数以及返回值</h4>
<ul>
<li>参数：节点、计数器（记录从根节点到该节点的值）、targetSum</li>
<li>返回值：需要搜索整棵二叉树并且需要处理递归返回值的递归函数就需要返回值，此题使用boolean代表这颗树是否存在路径总和为targetSum的路径</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">traversal</span><span class="params">(TreeNode node,<span class="type">int</span> count,<span class="type">int</span> targetSum)</span></span><br></pre></td></tr></table></figure>
<h4 id="2确定终止条件-4"><a class="markdownIt-Anchor" href="#2确定终止条件-4"></a> （2）确定终止条件</h4>
<ul>
<li>当当前节点为叶子节点并且count=targetSum时，返回true（该count已经包含当前节点的值了）；</li>
<li>当当前节点为叶子节点，直接返回false</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node.left==<span class="literal">null</span> &amp;&amp; node.right==<span class="literal">null</span> &amp;&amp; count==targetSum)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node.left==<span class="literal">null</span> &amp;&amp; node.right==<span class="literal">null</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3确定递归逻辑-3"><a class="markdownIt-Anchor" href="#3确定递归逻辑-3"></a> （3）确定递归逻辑</h4>
<ul>
<li>因为终止条件是判断叶子节点，所以递归的过程中就不要<mark>让空节点进入递归</mark>了；</li>
<li>若该节点的左右孩子非空，则递归（注意递归函数的count加上左右孩子的值）；</li>
<li>递归完若发现为true，则直接返回true，否则进行回溯，不要该左孩子节点（count减去该值），进行右孩子节点的查找（回溯）；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(traversal(node.left,count+=node.left.val,targetSum))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    count-=node.left.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(traversal(node.right,count+=node.right.val,targetSum))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    count-=node.right.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<h3 id="1322代码实现"><a class="markdownIt-Anchor" href="#1322代码实现"></a> 13.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> traversal(root,root.val,targetSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">traversal</span><span class="params">(TreeNode node,<span class="type">int</span> count,<span class="type">int</span> targetSum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left==<span class="literal">null</span> &amp;&amp; node.right==<span class="literal">null</span> &amp;&amp; count==targetSum)&#123;</span><br><span class="line">	        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(node.left==<span class="literal">null</span> &amp;&amp; node.right==<span class="literal">null</span>)&#123;</span><br><span class="line">	        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">	        <span class="keyword">if</span>(traversal(node.left,count+=node.left.val,targetSum))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            count-=node.left.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">	        <span class="keyword">if</span>(traversal(node.right,count+=node.right.val,targetSum))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            count-=node.right.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="14路径总和"><a class="markdownIt-Anchor" href="#14路径总和"></a> 14.路径总和 ||</h1>
<h2 id="141问题"><a class="markdownIt-Anchor" href="#141问题"></a> 14.1问题</h2>
<p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和==<strong>的路径</strong>==。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">输出：[[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure>
<h2 id="142解法一递归"><a class="markdownIt-Anchor" href="#142解法一递归"></a> 14.2解法一：递归</h2>
<h3 id="1421递归思路"><a class="markdownIt-Anchor" href="#1421递归思路"></a> 14.2.1递归思路</h3>
<h4 id="1确定递归函数参数以及返回值-3"><a class="markdownIt-Anchor" href="#1确定递归函数参数以及返回值-3"></a> （1）确定递归函数参数以及返回值</h4>
<ul>
<li>参数说明：
<ul>
<li>求根节点到 node 节点的路径之和 == targetSum</li>
<li>paths存放当前路径</li>
<li>res存放符合路径总和为targetSum的路径</li>
<li>count代表从根节点到该节点的路径中和</li>
</ul>
</li>
<li>无返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode node, List&lt;Integer&gt; paths, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">int</span> count, <span class="type">int</span> targetSum)</span></span><br></pre></td></tr></table></figure>
<h4 id="2确定终止条件-5"><a class="markdownIt-Anchor" href="#2确定终止条件-5"></a> （2）确定终止条件</h4>
<ul>
<li>若该节点为叶子节点，则判断count==targetSum，符合则添加该paths到res中，否则返回</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node.left==<span class="literal">null</span> &amp;&amp; node.right==<span class="literal">null</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(count==targetSum)    &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3确定递归逻辑-4"><a class="markdownIt-Anchor" href="#3确定递归逻辑-4"></a> （3）确定递归逻辑</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">    paths.add(node.left.val);</span><br><span class="line">	traversal(node.left,paths,res,count+=node.left.val,targetSum);</span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line">    count-=node.left.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">    paths.add(node.right.val);</span><br><span class="line">	traversal(node.right,paths,res,count+=node.right.val,targetSum);</span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line">    count-=node.right.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1422代码实现"><a class="markdownIt-Anchor" href="#1422代码实现"></a> 14.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; paths=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        paths.add(root.val);</span><br><span class="line">        traversal(root,paths,res,count+=root.val,targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode node, List&lt;Integer&gt; paths, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">int</span> count, <span class="type">int</span> targetSum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left==<span class="literal">null</span> &amp;&amp; node.right==<span class="literal">null</span>)&#123;</span><br><span class="line">	        <span class="keyword">if</span>(count==targetSum)&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(paths));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            paths.add(node.left.val);</span><br><span class="line">	        traversal(node.left,paths,res,count+=node.left.val,targetSum);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line">            count-=node.left.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            paths.add(node.right.val);</span><br><span class="line">	        traversal(node.right,paths,res,count+=node.right.val,targetSum);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line">            count-=node.right.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="回溯"><a class="markdownIt-Anchor" href="#回溯"></a> <mark>回溯</mark></h1>
<h1 id="1回溯算法理论基础"><a class="markdownIt-Anchor" href="#1回溯算法理论基础"></a> 1.回溯算法理论基础</h1>
<h2 id="11什么是回溯法"><a class="markdownIt-Anchor" href="#11什么是回溯法"></a> 1.1什么是回溯法？</h2>
<ol>
<li>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。</li>
<li>回溯是递归的副产品，只要有递归就会有回溯。</li>
</ol>
<h2 id="12回溯法的效率"><a class="markdownIt-Anchor" href="#12回溯法的效率"></a> 1.2回溯法的效率</h2>
<ol>
<li><strong>虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法</strong>。</li>
<li><strong>因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</li>
</ol>
<h2 id="13回溯法解决的问题"><a class="markdownIt-Anchor" href="#13回溯法解决的问题"></a> 1.3回溯法解决的问题</h2>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<blockquote>
<p>补充：<strong>组合是不强调元素顺序的，排列是强调元素顺序</strong>。</p>
<p>例如：{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了。</p>
</blockquote>
<h2 id="14如何理解回溯法"><a class="markdownIt-Anchor" href="#14如何理解回溯法"></a> 1.4如何理解回溯法？</h2>
<ol>
<li><strong>回溯法解决的问题都可以抽象为树形结构</strong></li>
<li>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度就构成了树的深度</strong>。</li>
<li>递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</li>
</ol>
<h2 id="15回溯法模板"><a class="markdownIt-Anchor" href="#15回溯法模板"></a> 1.5回溯法模板</h2>
<ul>
<li>
<p>回溯三部曲：</p>
<ul>
<li>
<p><mark>回溯函数模板返回值以及参数</mark>（回溯算法中函数返回值一般为void）</p>
</li>
<li>
<p><mark>回溯函数终止条件</mark>：（搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。）</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (终止条件) &#123;</span><br><span class="line">    存放结果;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><mark>回溯搜索的遍历过程</mark>（回溯法一般是在集合中递归搜索，<mark>集合的大小构成了树的宽度</mark>，递归的深度构成的树的深度）</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">    处理节点;</span><br><span class="line">    backtracking(路径，选择列表); // 递归</span><br><span class="line">    回溯，撤销处理结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>for循环就是<mark>遍历集合区间</mark>，可以理解一个节点有多少个孩子，这个for循环就执行多少次。</li>
<li>大家可以从图中看出<strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong>，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>回溯算法模板框架：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="2组合"><a class="markdownIt-Anchor" href="#2组合"></a> 2.组合</h1>
<h2 id="21问题"><a class="markdownIt-Anchor" href="#21问题"></a> 2.1问题</h2>
<p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1, k = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>
<h2 id="22解法一暴力解法循环次数不确定"><a class="markdownIt-Anchor" href="#22解法一暴力解法循环次数不确定"></a> 2.2解法一：暴力解法（循环次数不确定）</h2>
<ul>
<li>
<p>使用for循环，例如示例中k为2，很容易想到 用两个for循环，这样就可以输出 和示例中一样的结果。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>如果n为100，k为50呢，那就50层for循环</strong>，循环写不出来</p>
</li>
</ul>
<h2 id="23解法二回溯"><a class="markdownIt-Anchor" href="#23解法二回溯"></a> 2.3解法二：回溯</h2>
<h3 id="231回溯思路"><a class="markdownIt-Anchor" href="#231回溯思路"></a> 2.3.1回溯思路</h3>
<ul>
<li>分解成一层一层的树形结构：</li>
</ul>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195223940.png" alt="77.组合" /></p>
<ul>
<li>使用res存放全部合适的结果；</li>
<li>使用paths存放当前的路径；</li>
</ul>
<h4 id="1回溯函数模板返回值以及参数"><a class="markdownIt-Anchor" href="#1回溯函数模板返回值以及参数"></a> （1）回溯函数模板返回值以及参数</h4>
<ul>
<li>回溯函数返回值一般为void；</li>
<li>参数：
<ul>
<li>题目要求 求范围[1,n]中所有可能的k个数的组合；</li>
<li>参数有 n、k</li>
<li>还要有一个startIndex，代表每次循环从数组第几个数开始遍历</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> startIndex)</span></span><br></pre></td></tr></table></figure>
<h4 id="2回溯函数终止条件"><a class="markdownIt-Anchor" href="#2回溯函数终止条件"></a> （2）回溯函数终止条件</h4>
<ul>
<li>当当前路径 path 的个数达到k时，添加到res中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(paths.size()==k)&#123;</span><br><span class="line">    res.add(paths);</span><br><span class="line">	<span class="keyword">return</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3回溯搜索的遍历过程"><a class="markdownIt-Anchor" href="#3回溯搜索的遍历过程"></a> （3）回溯搜索的遍历过程</h4>
<ul>
<li>从startIndex遍历该层的元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;=n;i++)&#123;</span><br><span class="line">	paths.add(i);</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    backtracking(n,k,i+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="232代码实现-2"><a class="markdownIt-Anchor" href="#232代码实现-2"></a> 2.3.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   List&lt;Integer&gt; paths=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">       </span><br><span class="line">       backtracking(n,k,<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(paths.size()==k)&#123;</span><br><span class="line">           res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(paths));</span><br><span class="line">        <span class="keyword">return</span>;	</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;=n;i++)&#123;</span><br><span class="line">        paths.add(i);</span><br><span class="line">           <span class="comment">//递归</span></span><br><span class="line">           backtracking(n,k,i+<span class="number">1</span>);</span><br><span class="line">           <span class="comment">//回溯</span></span><br><span class="line">           paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="233剪枝操作"><a class="markdownIt-Anchor" href="#233剪枝操作"></a> 2.3.3剪枝操作</h3>
<ul>
<li>
<p>回溯法虽然是暴力搜索，但也有时候可以有点剪枝优化一下的</p>
</li>
<li>
<p>遍历代码如下：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;=n;i++)&#123;</span><br><span class="line">    </span><br><span class="line">	paths.add(i);</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    backtracking(n,k,i+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>这个遍历的范围是可以剪枝优化的，怎么优化呢？</p>
<ul>
<li>
<p>来举一个例子，<mark>n = 4，k = 4</mark> 的话，那么第一层for循环的时候，<mark>从元素2开始的遍历都没有意义了</mark>。 在第二层for循环，从元素3开始的遍历都没有意义了。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210130194335207-20230310134409532.png" alt="77.组合4" /></p>
</li>
<li>
<p><strong>如果for循环选择的起始位置之后的<mark>元素个数 已经不足 我们需要的元素个数了</mark>，那么就没有必要搜索了</strong>。</p>
</li>
</ul>
</li>
<li>
<p>优化过程如下：</p>
<ul>
<li>已经选择的元素个数：path.size();</li>
<li>还需要的元素个数为: k - path.size();</li>
<li><mark>在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</mark></li>
</ul>
</li>
<li>
<p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p>
</li>
<li>
<p>举个例子，n = 4，k = 3， 目前<mark>已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2</mark>。</p>
</li>
<li>
<p>从2开始搜索都是合理的，可以是组合[2, 3, 4]。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;= n - (k - paths.size()) + <span class="number">1</span>;i++)&#123;</span><br><span class="line">	paths.add(i);</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    backtracking(n,k,i+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3组合总和"><a class="markdownIt-Anchor" href="#3组合总和"></a> 3.组合总和 |||</h1>
<h2 id="31问题"><a class="markdownIt-Anchor" href="#31问题"></a> 3.1问题</h2>
<p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p>
<ul>
<li>只使用数字1到9</li>
<li>每个数字 <strong>最多使用一次</strong></li>
</ul>
<p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 7</span><br><span class="line">输出: [[1,2,4]]</span><br><span class="line">解释:</span><br><span class="line">1 + 2 + 4 = 7</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure>
<h2 id="32解法回溯"><a class="markdownIt-Anchor" href="#32解法回溯"></a> 3.2解法：回溯</h2>
<h3 id="321回溯思路"><a class="markdownIt-Anchor" href="#321回溯思路"></a> 3.2.1回溯思路</h3>
<h4 id="1函数返回值以及参数"><a class="markdownIt-Anchor" href="#1函数返回值以及参数"></a> （1）函数返回值以及参数</h4>
<ul>
<li>无返回值</li>
<li>参数：
<ul>
<li>k：总共需要k个数</li>
<li>n：总和为n</li>
<li>startIndex：从startIndex开始遍历</li>
<li>count：当前路径总和</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n,<span class="type">int</span> startIndex,<span class="type">int</span> count)</span></span><br></pre></td></tr></table></figure>
<h4 id="2终止条件-2"><a class="markdownIt-Anchor" href="#2终止条件-2"></a> （2）终止条件</h4>
<ul>
<li>判断路径个数是否为k，路径总和是否为n，满足则添加到res中并返回</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( paths.size()==k )&#123;</span><br><span class="line">	<span class="keyword">if</span>(count==n)&#123;</span><br><span class="line">    	res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(paths));   </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3遍历过程-2"><a class="markdownIt-Anchor" href="#3遍历过程-2"></a> （3）遍历过程</h4>
<ul>
<li>从startIndex开始递归（paths加上该节点、count总和加上）</li>
<li>递归后回溯（paths移除最后一个节点、count总和减去该节点值）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">    </span><br><span class="line">	paths.add(i);</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    backtracking(k,n,i+<span class="number">1</span>,count+=i);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line">    count-=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="322代码实现"><a class="markdownIt-Anchor" href="#322代码实现"></a> 3.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   List&lt;Integer&gt; paths=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">       backtracking(k,n,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n,<span class="type">int</span> startIndex,<span class="type">int</span> count)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>( paths.size()==k )&#123;</span><br><span class="line">           <span class="keyword">if</span>(count==n)&#123;</span><br><span class="line">               res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(paths));   </span><br><span class="line">           &#125;</span><br><span class="line">        <span class="keyword">return</span>;	</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">        paths.add(i);</span><br><span class="line">           <span class="comment">//递归</span></span><br><span class="line">           backtracking(k,n,i+<span class="number">1</span>,count+=i);</span><br><span class="line">           <span class="comment">//回溯</span></span><br><span class="line">           paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line">           count-=i;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="323剪枝操作"><a class="markdownIt-Anchor" href="#323剪枝操作"></a> 3.2.3剪枝操作</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;= <span class="number">9</span>-(k-paths.size())+<span class="number">1</span> ;i++)&#123;</span><br><span class="line">       paths.add(i);</span><br><span class="line">          <span class="comment">//递归</span></span><br><span class="line">          backtracking(k,n,i+<span class="number">1</span>,count+=i);</span><br><span class="line">          <span class="comment">//回溯</span></span><br><span class="line">          paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line">          count-=i;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h1 id="4电话号码的字母组合"><a class="markdownIt-Anchor" href="#4电话号码的字母组合"></a> 4.电话号码的字母组合</h1>
<h2 id="41问题"><a class="markdownIt-Anchor" href="#41问题"></a> 4.1问题</h2>
<p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" alt="img" /></p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure>
<h2 id="42解法回溯"><a class="markdownIt-Anchor" href="#42解法回溯"></a> 4.2解法：回溯</h2>
<h3 id="421回溯思路"><a class="markdownIt-Anchor" href="#421回溯思路"></a> 4.2.1回溯思路</h3>
<ul>
<li>注意：
<ul>
<li>前面两个题目（组合、组合总和||）是在同一个集合中求组合</li>
<li>该题是在不同集合中求组合</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; res：最终返回结果</span><br><span class="line">StringBuffer paths：当前路径</span><br><span class="line">String[] numsString=&#123;</span><br><span class="line">	&quot;&quot;,</span><br><span class="line">	&quot;&quot;,</span><br><span class="line">	&quot;abc&quot;,</span><br><span class="line">	&quot;def&quot;,</span><br><span class="line">	&quot;ghi&quot;,</span><br><span class="line">	&quot;jkl&quot;,</span><br><span class="line">	&quot;mno&quot;,</span><br><span class="line">	&quot;pqrs&quot;,</span><br><span class="line">	&quot;tuv&quot;,</span><br><span class="line">	&quot;wxyz&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1函数返回值以及参数-2"><a class="markdownIt-Anchor" href="#1函数返回值以及参数-2"></a> （1）函数返回值以及参数</h4>
<ul>
<li>digits：题目给的数字字符串</li>
<li>cur：当前遍历的第几个数字</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String digits,<span class="type">int</span> cur)</span></span><br></pre></td></tr></table></figure>
<h4 id="2终止条件-3"><a class="markdownIt-Anchor" href="#2终止条件-3"></a> （2）终止条件</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( cur == digits.length() )&#123;</span><br><span class="line">    res.add( paths.toString() );</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3遍历过程-3"><a class="markdownIt-Anchor" href="#3遍历过程-3"></a> （3）遍历过程</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String arr=numsString[ digits.charAt(cur)-<span class="string">&#x27;0&#x27;</span> ];	<span class="comment">//取出对应数字的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length();i++)&#123;				<span class="comment">//遍历字符串</span></span><br><span class="line">    paths.append(arr[i]);</span><br><span class="line">    backtracking(digits,cur+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    paths.deleteCharAt(paths.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="422代码实现"><a class="markdownIt-Anchor" href="#422代码实现"></a> 4.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    StringBuffer paths=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    String[] numsString=&#123;</span><br><span class="line">	    <span class="string">&quot;&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;def&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        backtracking(digits,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String digits,<span class="type">int</span> cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( cur == digits.length() )&#123;</span><br><span class="line">            res.add( paths.toString() );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String arr=numsString[ digits.charAt(cur)-<span class="string">&#x27;0&#x27;</span> ];	<span class="comment">//取出对应数字的字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length();i++)&#123;				<span class="comment">//遍历字符串</span></span><br><span class="line">            paths.append(arr.charAt(i));</span><br><span class="line">            backtracking(digits,cur+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            paths.deleteCharAt(paths.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5组合总和"><a class="markdownIt-Anchor" href="#5组合总和"></a> 5.组合总和</h1>
<h2 id="51题目-4"><a class="markdownIt-Anchor" href="#51题目-4"></a> 5.1题目</h2>
<p>给你一个 <strong><mark>无重复元素</mark></strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>
<p><code>candidates</code> 中的 <strong><mark>同一个</mark></strong> 数字可以 <strong><mark>无限制重复被选取</mark></strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p>
<p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例三：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2], target = 1</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure>
<h2 id="52解法回溯"><a class="markdownIt-Anchor" href="#52解法回溯"></a> 5.2解法：回溯</h2>
<h3 id="521回溯思路"><a class="markdownIt-Anchor" href="#521回溯思路"></a> 5.2.1回溯思路</h3>
<ul>
<li>注意：题目本质为在同一个集合中求组合，所以需要startIndex，作为每次遍历的开始；</li>
<li>因为题目表明同一个数字可以 无限制被选取，所以每次递归遍历，需要从包含当前字母（下标为i）开始遍历</li>
</ul>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240413201325087.png" alt="image-20240413201325087" /></p>
<h4 id="1函数返回值以及参数-3"><a class="markdownIt-Anchor" href="#1函数返回值以及参数-3"></a> （1）函数返回值以及参数</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backing</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span></span><br></pre></td></tr></table></figure>
<h4 id="2终止条件-4"><a class="markdownIt-Anchor" href="#2终止条件-4"></a> （2）终止条件</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">	res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(paths));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3遍历过程-4"><a class="markdownIt-Anchor" href="#3遍历过程-4"></a> （3）遍历过程</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;candidates.length();i++)&#123;</span><br><span class="line">    paths.add(candidates[i]);</span><br><span class="line">    sum+=candidates[i];</span><br><span class="line">    backing(candidates,target,sum,i);</span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">   	paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line">    sum-=candidates[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="522代码实现"><a class="markdownIt-Anchor" href="#522代码实现"></a> 5.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   List&lt;Integer&gt; paths=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">       backing(candidates,target,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backing</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(paths));</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;candidates.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">           paths.add(candidates[i]);</span><br><span class="line">           sum+=candidates[i];</span><br><span class="line">           backing(candidates,target,sum,i);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//回溯</span></span><br><span class="line">  	        paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line">           sum-=candidates[i];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="6组合总和"><a class="markdownIt-Anchor" href="#6组合总和"></a> 6.组合总和 ||</h1>
<h2 id="61题目-3"><a class="markdownIt-Anchor" href="#61题目-3"></a> 6.1题目</h2>
<p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p>
<p>**注意：**解集不能包含重复的组合。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,2,2],</span><br><span class="line">[5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="62解法回溯"><a class="markdownIt-Anchor" href="#62解法回溯"></a> 6.2解法：回溯</h2>
<h3 id="621回溯思路"><a class="markdownIt-Anchor" href="#621回溯思路"></a> 6.2.1回溯思路</h3>
<ul>
<li>注意：题目本质为在同一个集合中求组合，所以<mark>需要startIndex，作为每次遍历的开始</mark>；</li>
<li>因为题目表明同一个数字不可以 无限制被选取，所以每次递归遍历，需要<mark>从下一个字母遍历</mark></li>
<li><mark>因为同一个数字，在树中只能用一遍</mark>
<ul>
<li>思路：将数组排序（重复的元素肯定相邻）</li>
<li>遍历该元素时，首先判断元素和上一个元素是否相同（即是否使用过），并且通过标记数组判断是在同一树枝（还是同一树层）使用过</li>
<li>若为同一树枝（从上到下），则可以使用该元素；若为同一树层，则不可以使用该元素</li>
<li>如图所示：</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240413205953207.png" alt="image-20240413205953207" /></p>
<h4 id="1函数返回值以及参数-4"><a class="markdownIt-Anchor" href="#1函数返回值以及参数-4"></a> （1）函数返回值以及参数</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backing</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> startIndex, <span class="type">boolean</span>[] isUsed)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="2终止条件-5"><a class="markdownIt-Anchor" href="#2终止条件-5"></a> （2）终止条件</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">	res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(paths));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3遍历过程-5"><a class="markdownIt-Anchor" href="#3遍历过程-5"></a> （3）遍历过程</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;candidates.length();i++)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; candidates[i]==candidates[i+<span class="number">1</span>] &amp;&amp; isUsed[i-<span class="number">1</span>]==<span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="comment">//该元素在同一树层中已经使用过了，不能再使用（不同位置上的数字只能 用一次）</span></span><br><span class="line">        <span class="comment">//若 isUsed[i-1]=true，则表明该元素在同一树枝上使用，不会影响该元素使用（不同位置）</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    paths.add(candidates[i]);</span><br><span class="line">    sum+=candidates[i];</span><br><span class="line">    isUsed[i]=<span class="literal">true</span>;</span><br><span class="line">    backing(candidates,target,i+<span class="number">1</span>,isUsed);</span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">   	paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line">    sum-=candidates[i];</span><br><span class="line">    isUsed[i]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="622代码"><a class="markdownIt-Anchor" href="#622代码"></a> 6.2.2代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   List&lt;Integer&gt; paths=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="type">boolean</span>[] isUsed;</span><br><span class="line">   </span><br><span class="line">   <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">       Arrays.sort(candidates);    <span class="comment">//排序，确保相同元素相邻</span></span><br><span class="line">       </span><br><span class="line">       isUsed=<span class="keyword">new</span> <span class="title class_">boolean</span>[candidates.length];</span><br><span class="line">       Arrays.fill(isUsed, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">       backing(candidates,target,<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backing</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(paths));</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;candidates.length;i++)&#123;</span><br><span class="line">   </span><br><span class="line">           <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; candidates[i]==candidates[i-<span class="number">1</span>] &amp;&amp; isUsed[i-<span class="number">1</span>]==<span class="literal">false</span>)&#123;</span><br><span class="line">               <span class="comment">//该元素在同一树层中已经使用过了，不能再使用（不同位置上的数字只能 用一次）</span></span><br><span class="line">               <span class="comment">//若 isUsed[i-1]=true，则表明该元素在同一树枝上使用，不会影响该元素使用（不同位置）</span></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           paths.add(candidates[i]);</span><br><span class="line">           sum+=candidates[i];</span><br><span class="line">           isUsed[i]=<span class="literal">true</span>;</span><br><span class="line">           backing(candidates,target,i+<span class="number">1</span>);</span><br><span class="line">           <span class="comment">//回溯</span></span><br><span class="line">  	        paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line">           sum-=candidates[i];</span><br><span class="line">           isUsed[i]=<span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="7分割回文串"><a class="markdownIt-Anchor" href="#7分割回文串"></a> 7.分割回文串</h1>
<h2 id="71题目-3"><a class="markdownIt-Anchor" href="#71题目-3"></a> 7.1题目</h2>
<p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：[[&quot;a&quot;]]</span><br></pre></td></tr></table></figure>
<h2 id="72解法回溯"><a class="markdownIt-Anchor" href="#72解法回溯"></a> 7.2解法：回溯</h2>
<h3 id="721回溯思路"><a class="markdownIt-Anchor" href="#721回溯思路"></a> 7.2.1回溯思路</h3>
<ul>
<li>例如对于字符串abcdef：
<ul>
<li>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中再选取第三个…。</li>
<li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中再切割第三段…。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240415093449950.png" alt="image-20240415093449950" /></p>
<h4 id="1函数返回值以及参数-5"><a class="markdownIt-Anchor" href="#1函数返回值以及参数-5"></a> （1）函数返回值以及参数</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backing</span><span class="params">(String s,<span class="type">int</span> startIndex)</span></span><br></pre></td></tr></table></figure>
<h4 id="2终止条件-6"><a class="markdownIt-Anchor" href="#2终止条件-6"></a> （2）终止条件</h4>
<ul>
<li>
<p>若要切割的位置已经超出数组范围，则添加该路径下的回文串</p>
</li>
<li>
<p>res：全部符合条件的回文串组合</p>
</li>
<li>
<p>paths：当前分割路径的回文串组合</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(startIndex &gt; s.length()-<span class="number">1</span>)&#123;</span><br><span class="line">	res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(paths));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3遍历过程-6"><a class="markdownIt-Anchor" href="#3遍历过程-6"></a> （3）遍历过程</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;s.length();i++)&#123;</span><br><span class="line">	<span class="comment">//判断当前段是否为回文</span></span><br><span class="line">    <span class="keyword">if</span>(isPalindrome(s,startIndex,i))&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取 [startIndex,i]的子串</span></span><br><span class="line">        String str=s.substring(startIndex,i+<span class="number">1</span>);</span><br><span class="line">        paths.add(str);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    backing(s,i+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>判断是否为回文串方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;start&lt;end;start++,end--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(start)!=s.charAt(end))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="722代码"><a class="markdownIt-Anchor" href="#722代码"></a> 7.2.2代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   List&lt;String&gt; paths=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       backing(s,<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backing</span><span class="params">(String s,<span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(startIndex&gt;s.length()-<span class="number">1</span>)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(paths));</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;  </span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="comment">//判断当前段是否为回文</span></span><br><span class="line">           <span class="keyword">if</span>(isPalindrome(s,startIndex,i))&#123;</span><br><span class="line">       </span><br><span class="line">               <span class="comment">//获取 [startIndex,i]的子串</span></span><br><span class="line">               String str=s.substring(startIndex,i+<span class="number">1</span>);</span><br><span class="line">               paths.add(str);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           backing(s,i+<span class="number">1</span>);</span><br><span class="line">   </span><br><span class="line">           <span class="comment">//回溯</span></span><br><span class="line">           paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line">       &#125;      </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;start&lt;end;start++,end--)&#123;</span><br><span class="line">           <span class="keyword">if</span>(s.charAt(start)!=s.charAt(end))&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="8复原ip地址"><a class="markdownIt-Anchor" href="#8复原ip地址"></a> 8.复原IP地址</h1>
<h2 id="81题目-3"><a class="markdownIt-Anchor" href="#81题目-3"></a> 8.1题目</h2>
<p><strong>有效 IP 地址</strong> 正好由四个整数（<mark>每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code></mark>），整数之间用 <code>'.'</code> 分隔。</p>
<ul>
<li>例如：<code>&quot;0.1.2.201&quot;</code> 和<code>&quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code>、<code>&quot;192.168.1.312&quot;</code> 和 <code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址。</li>
</ul>
<p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>'.'</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;25525511135&quot;</span><br><span class="line">输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;0000&quot;</span><br><span class="line">输出：[&quot;0.0.0.0&quot;]</span><br></pre></td></tr></table></figure>
<h2 id="82解法回溯"><a class="markdownIt-Anchor" href="#82解法回溯"></a> 8.2解法：回溯</h2>
<h3 id="821回溯思路"><a class="markdownIt-Anchor" href="#821回溯思路"></a> 8.2.1回溯思路</h3>
<ul>
<li>回溯思路如下：</li>
<li>回溯函数包含 .的个数，当.达到3的时候，若最后一个截取部分满足条件，则添加到返回结果中；</li>
<li>在每次遍历过程中，需要插入 .（StringBuffer），所以开启下一次递归是在(i+2)的位置上</li>
</ul>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240416173610306.png" alt="image-20240416173610306" /></p>
<h4 id="1函数返回值以及参数-6"><a class="markdownIt-Anchor" href="#1函数返回值以及参数-6"></a> （1）函数返回值以及参数</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backing</span><span class="params">(StringBuilder sb,<span class="type">int</span> startIndex,<span class="type">int</span> count)</span></span><br></pre></td></tr></table></figure>
<h4 id="2终止条件-7"><a class="markdownIt-Anchor" href="#2终止条件-7"></a> （2）终止条件</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(count==<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(vaild(sb, startIndex, sb.size()-<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="comment">//判断[startIndex,sb.size()-1]的字符串是否符合条件</span></span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(sb));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3遍历过程-7"><a class="markdownIt-Anchor" href="#3遍历过程-7"></a> （3）遍历过程</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;sb.size();i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(vaild(sb,startIndex,i))&#123;</span><br><span class="line">        </span><br><span class="line">        sb.insert(i+<span class="number">1</span>,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        count++;</span><br><span class="line">        </span><br><span class="line">        backing(sb,i+<span class="number">2</span>,count);</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        sb.deleteCharAt(i+<span class="number">1</span>);</span><br><span class="line">        count--;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//不用再循环了</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>private boolean vaild(StringBuilder sb, int start, int end)：判断[start,end]是否合法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">vaild</span><span class="params">(StringBuilder sb, <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(start&gt;end)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s.charAt(start)==<span class="string">&#x27;0&#x27;</span> &amp;&amp; start!=end)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将string----&gt;int</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">        <span class="type">int</span> digit=s.charAt(i)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        num=num*<span class="number">10</span>+digit;</span><br><span class="line">        <span class="keyword">if</span>(num&gt;<span class="number">255</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="822代码实现-2"><a class="markdownIt-Anchor" href="#822代码实现-2"></a> 8.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">       backing(sb,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backing</span><span class="params">(StringBuilder sb,<span class="type">int</span> startIndex,<span class="type">int</span> count)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(count==<span class="number">3</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(vaild(sb, startIndex, sb.length()-<span class="number">1</span>))&#123;</span><br><span class="line">               <span class="comment">//判断[startIndex,sb.size()-1]的字符串是否符合条件</span></span><br><span class="line">               res.add(sb.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;sb.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vaild(sb,startIndex,i))&#123;</span><br><span class="line">       </span><br><span class="line">               sb.insert(i+<span class="number">1</span>,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">               count++;</span><br><span class="line">               backing(sb,i+<span class="number">2</span>,count);</span><br><span class="line">               <span class="comment">//回溯</span></span><br><span class="line">               sb.deleteCharAt(i+<span class="number">1</span>);</span><br><span class="line">               count--;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//不用再循环了</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">vaild</span><span class="params">(StringBuilder sb, <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;end)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(sb.charAt(start)==<span class="string">&#x27;0&#x27;</span> &amp;&amp; start!=end)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">       <span class="comment">//将string----&gt;int</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">           <span class="type">int</span> digit=sb.charAt(i)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           num=num*<span class="number">10</span>+digit;</span><br><span class="line">           <span class="keyword">if</span>(num&gt;<span class="number">255</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="9子集"><a class="markdownIt-Anchor" href="#9子集"></a> 9.子集</h1>
<h2 id="91题目-2"><a class="markdownIt-Anchor" href="#91题目-2"></a> 9.1题目</h2>
<p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure>
<h2 id="92解法回溯"><a class="markdownIt-Anchor" href="#92解法回溯"></a> 9.2解法：回溯</h2>
<h3 id="921回溯思路"><a class="markdownIt-Anchor" href="#921回溯思路"></a> 9.2.1回溯思路</h3>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240417125635959.png" alt="image-20240417125635959" /></p>
<h4 id="1函数返回值以及参数-7"><a class="markdownIt-Anchor" href="#1函数返回值以及参数-7"></a> （1）函数返回值以及参数</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backing</span><span class="params">(<span class="type">int</span> startIndex,<span class="type">int</span>[] nums)</span></span><br></pre></td></tr></table></figure>
<h4 id="2终止条件-8"><a class="markdownIt-Anchor" href="#2终止条件-8"></a> （2）终止条件</h4>
<ul>
<li>
<p>每次递归遍历都要把当前子集加进res中</p>
</li>
<li>
<p>当startIndex大于数组长度，则结束递归</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(paths));</span><br><span class="line"><span class="keyword">if</span>(startIndex&gt;=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3遍历过程-8"><a class="markdownIt-Anchor" href="#3遍历过程-8"></a> （3）遍历过程</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;nums.length;i++)&#123;</span><br><span class="line">    paths.add(nums[i]);</span><br><span class="line">	backing(i+<span class="number">1</span>,nums);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    paths.remove(nums.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="922代码实现-2"><a class="markdownIt-Anchor" href="#922代码实现-2"></a> 9.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   List&lt;Integer&gt; paths=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       backing(<span class="number">0</span>,nums);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backing</span><span class="params">(<span class="type">int</span> startIndex,<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">       res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(paths));</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span>(startIndex&gt;nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;nums.length;i++)&#123;</span><br><span class="line">           paths.add(nums[i]);</span><br><span class="line">           backing(i+<span class="number">1</span>,nums);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//回溯  </span></span><br><span class="line">           paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="10子集"><a class="markdownIt-Anchor" href="#10子集"></a> 10.子集 ||</h1>
<h2 id="101题目-2"><a class="markdownIt-Anchor" href="#101题目-2"></a> 10.1题目</h2>
<p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的 子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,2]</span><br><span class="line">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure>
<h2 id="102解法回溯"><a class="markdownIt-Anchor" href="#102解法回溯"></a> 10.2解法：回溯</h2>
<h3 id="1021回溯思路"><a class="markdownIt-Anchor" href="#1021回溯思路"></a> 10.2.1回溯思路</h3>
<ul>
<li>先将数组排序，这样重复元素肯定相邻</li>
<li>同一树层，不可以使用同一元素；同一树枝，可以使用同一元素；</li>
<li>isUsed[i]：为true，则代表同一树枝用到了元素nums[i]，isUsed[i+1]还可以用</li>
</ul>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240417135008494.png" alt="image-20240417135008494" /></p>
<h3 id="1022代码实现-3"><a class="markdownIt-Anchor" href="#1022代码实现-3"></a> 10.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   List&lt;Integer&gt; paths=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="type">boolean</span>[] isUsed;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       Arrays.sort(nums);</span><br><span class="line">       isUsed=<span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">       Arrays.fill(isUsed,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">       backing(<span class="number">0</span>,nums);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backing</span><span class="params">(<span class="type">int</span> startIndex,<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">       res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(paths));</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span>(startIndex&gt;nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>] &amp;&amp; isUsed[i-<span class="number">1</span>]==<span class="literal">false</span>)&#123;</span><br><span class="line">               <span class="comment">//该元素在同一树层已经用过了</span></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;&#123;</span><br><span class="line">               paths.add(nums[i]);</span><br><span class="line">               isUsed[i]=<span class="literal">true</span>;</span><br><span class="line">               backing(i+<span class="number">1</span>,nums);</span><br><span class="line"></span><br><span class="line">               <span class="comment">//回溯  </span></span><br><span class="line">               paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line">               isUsed[i]=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="11全排列"><a class="markdownIt-Anchor" href="#11全排列"></a> 11.全排列</h1>
<h2 id="111题目"><a class="markdownIt-Anchor" href="#111题目"></a> 11.1题目</h2>
<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[[0,1],[1,0]]</span><br></pre></td></tr></table></figure>
<h2 id="112解法回溯"><a class="markdownIt-Anchor" href="#112解法回溯"></a> 11.2解法：回溯</h2>
<h3 id="1121回溯思路"><a class="markdownIt-Anchor" href="#1121回溯思路"></a> 11.2.1回溯思路</h3>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240418112032340.png" alt="image-20240418112032340" /></p>
<h4 id="1函数返回值以及参数-8"><a class="markdownIt-Anchor" href="#1函数返回值以及参数-8"></a> （1）函数返回值以及参数</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backing</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br></pre></td></tr></table></figure>
<h4 id="2终止条件-9"><a class="markdownIt-Anchor" href="#2终止条件-9"></a> （2）终止条件</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(paths.size()==nums.length)&#123;</span><br><span class="line">	res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(paths));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3遍历过程-9"><a class="markdownIt-Anchor" href="#3遍历过程-9"></a> （3）遍历过程</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(isUsed[i]==<span class="literal">true</span>)	&#123;</span><br><span class="line">        <span class="comment">//该元素已经用过了</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    isUsed[i]==<span class="literal">true</span>;</span><br><span class="line">    paths.add(nums[i);</span><br><span class="line">    backing(nums);</span><br><span class="line">                   </span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    isUsed[i]=<span class="literal">false</span>;</span><br><span class="line">    paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1122代码实现-2"><a class="markdownIt-Anchor" href="#1122代码实现-2"></a> 11.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   List&lt;Integer&gt; paths=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="type">boolean</span>[] isUsed;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       isUsed=<span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">       Arrays.fill(isUsed,<span class="literal">false</span>);</span><br><span class="line">       backing(nums);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backing</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(paths.size()==nums.length)&#123;</span><br><span class="line">       	res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(paths));</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isUsed[i]==<span class="literal">true</span>)	&#123;</span><br><span class="line">               <span class="comment">//该元素已经用过了</span></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           isUsed[i]=<span class="literal">true</span>;</span><br><span class="line">           paths.add(nums[i]);</span><br><span class="line">           backing(nums);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//回溯</span></span><br><span class="line">           isUsed[i]=<span class="literal">false</span>;</span><br><span class="line">           paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="12全排列"><a class="markdownIt-Anchor" href="#12全排列"></a> 12.全排列 ||</h1>
<h2 id="121题目"><a class="markdownIt-Anchor" href="#121题目"></a> 12.1题目</h2>
<p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>
<h2 id="122解法回溯"><a class="markdownIt-Anchor" href="#122解法回溯"></a> 12.2解法：回溯</h2>
<h3 id="1221回溯思路"><a class="markdownIt-Anchor" href="#1221回溯思路"></a> 12.2.1回溯思路</h3>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240418114400677.png" alt="image-20240418114400677" /></p>
<h3 id="1223代码实现"><a class="markdownIt-Anchor" href="#1223代码实现"></a> 12.2.3代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   List&lt;Integer&gt; paths=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="type">boolean</span>[] isUsed;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       Arrays.sort(nums);</span><br><span class="line">       isUsed=<span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">       Arrays.fill(isUsed,<span class="literal">false</span>);</span><br><span class="line">       backing(nums);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backing</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(paths.size()==nums.length)&#123;</span><br><span class="line">       	res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(paths));</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isUsed[i]==<span class="literal">true</span>)	&#123;</span><br><span class="line">               <span class="comment">//同一树枝上，该元素已经用过了</span></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>] &amp;&amp; isUsed[i-<span class="number">1</span>]==<span class="literal">false</span>)&#123;</span><br><span class="line">               <span class="comment">//同一树层上，该元素已经用过了</span></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           isUsed[i]=<span class="literal">true</span>;</span><br><span class="line">           paths.add(nums[i]);</span><br><span class="line">           backing(nums);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//回溯</span></span><br><span class="line">           isUsed[i]=<span class="literal">false</span>;</span><br><span class="line">           paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="13n皇后"><a class="markdownIt-Anchor" href="#13n皇后"></a> 13.N皇后</h1>
<h2 id="131题目"><a class="markdownIt-Anchor" href="#131题目"></a> 13.1题目</h2>
<p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p>
<p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p>
<p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code> 分别代表了皇后和空位。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</span><br><span class="line">解释：如上图所示，4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[&quot;Q&quot;]]</span><br></pre></td></tr></table></figure>
<h2 id="132解法回溯"><a class="markdownIt-Anchor" href="#132解法回溯"></a> 13.2解法：回溯</h2>
<h3 id="1321回溯思路"><a class="markdownIt-Anchor" href="#1321回溯思路"></a> 13.2.1回溯思路</h3>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240419101417373.png" alt="image-20240419101417373" /></p>
<h4 id="1函数返回值以及参数-9"><a class="markdownIt-Anchor" href="#1函数返回值以及参数-9"></a> （1）函数返回值以及参数</h4>
<ul>
<li>深度：递归控制数组的每一行的遍历，即深度，从上到下</li>
<li>广度：遍历过程中使用for循环控制数组的每一列的遍历，即广度，从左到右</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backing</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> row,<span class="type">char</span>[][] chessboard)</span></span><br></pre></td></tr></table></figure>
<h4 id="2终止条件-10"><a class="markdownIt-Anchor" href="#2终止条件-10"></a> （2）终止条件</h4>
<ul>
<li>遍历的行数超出数组的行数（用数组下标表示）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(row==n)&#123;</span><br><span class="line">	res.add(array2list(chessboard));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将数组转成list</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">priavte List <span class="title function_">array2list</span><span class="params">(<span class="type">char</span>[][] chessboard)</span>&#123;</span><br><span class="line">	List&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span>[] ch:chessboard)&#123;</span><br><span class="line">        list.add(String.copyValueOf(ch));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3遍历过程-10"><a class="markdownIt-Anchor" href="#3遍历过程-10"></a> （3）遍历过程</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">0</span>;col&lt;n;col++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(vaild(row,col,chessboard,n))&#123;</span><br><span class="line">		chessboard[row][col]=<span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">		row++;</span><br><span class="line">		backing(n,row,chessboard);</span><br><span class="line">		row--;</span><br><span class="line">		chessboard[row][col]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>vaild(int row,int col,char[] chessboard)：判定该位置存放‘Q’是否合法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">vaild</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> col,<span class="type">char</span>[][] chessboard,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="comment">//判断同一列：从上到下</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(chessboard[i][col]==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断 45度角：右上角</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=row-<span class="number">1</span>,j=col+<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&lt;=n-<span class="number">1</span>;i--,j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(chessboard[i][j]==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断 135度角：左上角</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=row-<span class="number">1</span>,j=col-<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>;i--,j--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(chessboard[i][j]==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1322代码实现-2"><a class="markdownIt-Anchor" href="#1322代码实现-2"></a> 13.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="type">char</span>[][] chessboard=<span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">char</span>[] ch : chessboard)&#123;</span><br><span class="line">           Arrays.fill(ch,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       backing(n,<span class="number">0</span>,chessboard);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backing</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> row,<span class="type">char</span>[][] chessboard)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(row==n)&#123;</span><br><span class="line">        res.add(array2list(chessboard));</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">0</span>;col&lt;n;col++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vaild(row,col,chessboard,n))&#123;</span><br><span class="line">	        chessboard[row][col]=<span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">	        row++;</span><br><span class="line">	        backing(n,row,chessboard);</span><br><span class="line">	        row--;</span><br><span class="line">	        chessboard[row][col]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;       </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">vaild</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> col,<span class="type">char</span>[][] chessboard,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="comment">//判断同一列：从上到下</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(chessboard[i][col]==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="comment">//判断 45度角：右上角</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=row-<span class="number">1</span>,j=col+<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&lt;=n-<span class="number">1</span>;i--,j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(chessboard[i][j]==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="comment">//判断 135度角：左上角</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=row-<span class="number">1</span>,j=col-<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>;i--,j--)&#123;</span><br><span class="line">           <span class="keyword">if</span>(chessboard[i][j]==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> List <span class="title function_">array2list</span><span class="params">(<span class="type">char</span>[][] chessboard)</span>&#123;</span><br><span class="line">    List&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">char</span>[] ch:chessboard)&#123;</span><br><span class="line">           list.add(String.copyValueOf(ch));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="14括号生成"><a class="markdownIt-Anchor" href="#14括号生成"></a> 14.括号生成</h1>
<h2 id="141题目"><a class="markdownIt-Anchor" href="#141题目"></a> 14.1题目</h2>
<p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[&quot;()&quot;]</span><br></pre></td></tr></table></figure>
<h2 id="142解法回溯"><a class="markdownIt-Anchor" href="#142解法回溯"></a> 14.2解法：回溯</h2>
<ul>
<li>此解法当n&gt;=8时，超出时间限制</li>
</ul>
<h3 id="1421回溯思路"><a class="markdownIt-Anchor" href="#1421回溯思路"></a> 14.2.1回溯思路</h3>
<h4 id="1函数返回值以及参数-10"><a class="markdownIt-Anchor" href="#1函数返回值以及参数-10"></a> （1）函数返回值以及参数</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backing</span><span class="params">(<span class="type">int</span> startIndex,<span class="type">int</span> n)</span></span><br></pre></td></tr></table></figure>
<h4 id="2终止条件-11"><a class="markdownIt-Anchor" href="#2终止条件-11"></a> （2）终止条件</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sb.length() == <span class="number">2</span>*n)&#123;</span><br><span class="line">    <span class="comment">//判断当前路径是否为有效括号</span></span><br><span class="line">    <span class="keyword">if</span>(isValid(sb))&#123;</span><br><span class="line">    	res.add(<span class="keyword">new</span> <span class="title class_">String</span>(sb.toString()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3遍历过程-11"><a class="markdownIt-Anchor" href="#3遍历过程-11"></a> （3）遍历过程</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">	sb.append(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    backing(i+<span class="number">1</span>,n);</span><br><span class="line">     </span><br><span class="line">    sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">		sb.append(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        backing(i+<span class="number">1</span>,n);</span><br><span class="line">		sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>验证是否为回文串方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean isValid(StringBuffer sb)&#123;</span><br><span class="line"></span><br><span class="line">       Deque&lt;Character&gt; deque=new LinkedList&lt;&gt;();</span><br><span class="line">       for(int i=0;i&lt;sb.length() ;i++)&#123;</span><br><span class="line">           if(sb.charAt(i)==&#x27;(&#x27;)&#123;</span><br><span class="line">               //左括号</span><br><span class="line">               deque.push(&#x27;(&#x27;);</span><br><span class="line">           &#125;else if( !deque.isEmpty() &amp;&amp; deque.peek()==&#x27;(&#x27; )&#123;</span><br><span class="line">               deque.pop();</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               return false;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return deque.isEmpty();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1422代码实现-2"><a class="markdownIt-Anchor" href="#1422代码实现-2"></a> 14.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   StringBuffer sb=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       backing(<span class="number">0</span>,n);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backing</span><span class="params">(<span class="type">int</span> startIndex,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(sb.length() == <span class="number">2</span>*n)&#123;</span><br><span class="line">           <span class="comment">//判断当前路径是否为有效括号</span></span><br><span class="line">           <span class="keyword">if</span>(isValid(sb))&#123;</span><br><span class="line">               res.add(<span class="keyword">new</span> <span class="title class_">String</span>(sb.toString()));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">           sb.append(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">           backing(i+<span class="number">1</span>,n);</span><br><span class="line">           sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">               sb.append(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">               backing(i+<span class="number">1</span>,n);</span><br><span class="line">               sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(StringBuffer sb)</span>&#123;</span><br><span class="line"></span><br><span class="line">       Deque&lt;Character&gt; deque=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sb.length() ;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(sb.charAt(i)==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">               <span class="comment">//左括号</span></span><br><span class="line">               deque.push(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>( !deque.isEmpty() &amp;&amp; deque.peek()==<span class="string">&#x27;(&#x27;</span> )&#123;</span><br><span class="line">               deque.pop();</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> deque.isEmpty();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>力扣刷题</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://www.haipeng-lin.cn/posts/f7912a82.html">https://www.haipeng-lin.cn/posts/f7912a82.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a" style="display: inline-block;width: 120px"><h>作者</h><div class="post-copyright-cc-info"><h>拾忆鱼</h></div></div><div class="post-copyright-c" style="display: inline-block;width: 120px"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-08-29</h></div></div><div class="post-copyright-u" style="display: inline-block;width: 120px"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-09-01</h></div></div><div class="post-copyright-c" style="display: inline-block;width: 120px"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/linhaipengg/md_-picture/raw/master/算法.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/8a9d5576.html"><img class="prev-cover" src="https://gitee.com/linhaipengg/md_-picture/raw/master/算法.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">动态规划思想</div></div></a></div><div class="next-post pull-right"><a href="/posts/18bf100b.html"><img class="next-cover" src="https://i-blog.csdnimg.cn/blog_migrate/2b37069e05120f2696d7a1cb32152359.jpeg#pic_center" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringBoot基础篇</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410101530409.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">拾忆鱼</div><div class="author-info__description">一条菜鱼的小破站</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">小菜鱼正在从CSDN博客搬家，尽请期待　　      地址：<a target="_blank" rel="noopener" href="https://haipeng-lin.blog.csdn.net/">haipeng-lin.blog.csdn.net</a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%90%E4%B8%B2"><span class="toc-text"> 子串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-text"> 1.和为K的子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E9%A2%98%E7%9B%AE"><span class="toc-text"> 1.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E8%A7%A3%E6%B3%95%E5%89%8D%E7%BC%80%E5%92%8C%E5%93%88%E5%B8%8C"><span class="toc-text"> 1.2解法：前缀和+哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#121%E8%A7%A3%E6%B3%95%E6%80%9D%E8%B7%AF"><span class="toc-text"> 1.2.1解法思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#122%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 1.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text"> 2.滑动窗口最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E9%A2%98%E7%9B%AE"><span class="toc-text"> 2.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E8%A7%A3%E6%B3%95%E4%B8%80%E6%9A%B4%E5%8A%9B"><span class="toc-text"> 2.2解法一：暴力</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#221%E6%9A%B4%E5%8A%9B%E6%80%9D%E8%B7%AF"><span class="toc-text"> 2.2.1暴力思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#222%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 2.2.2代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E8%A7%A3%E6%B3%95%E4%BA%8C%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97"><span class="toc-text"> 2.3解法二：双向队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#231%E6%80%9D%E8%B7%AF"><span class="toc-text"> 2.3.1思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#232%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 2.3.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text"> 二分查找</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-text"> 3.寻找两个正序数组的中位数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E9%A2%98%E7%9B%AE"><span class="toc-text"> 3.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E8%A7%A3%E6%B3%95%E6%9A%B4%E5%8A%9B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text"> 3.2解法：暴力（归并排序）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33%E8%A7%A3%E6%B3%95%E4%BA%8C%E5%88%86%E6%B3%95"><span class="toc-text"> 3.3解法：二分法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text"> 双指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="toc-text"> 1.移动零</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E9%A2%98%E7%9B%AE-2"><span class="toc-text"> 1.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E8%A7%A3%E6%B3%95%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text"> 1.2解法：双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#121%E5%8F%8C%E6%8C%87%E9%92%88%E6%80%9D%E8%B7%AF"><span class="toc-text"> 1.2.1双指针思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#122%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-text"> 1.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text"> 2.盛最多水的容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E9%A2%98%E7%9B%AE-2"><span class="toc-text"> 2.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E8%A7%A3%E6%B3%95%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text"> 2.2解法：双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#221%E5%8F%8C%E6%8C%87%E9%92%88%E6%80%9D%E8%B7%AF"><span class="toc-text"> 2.2.1双指针思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#222%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-text"> 2.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text"> 数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text"> 1.二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E9%A2%98%E7%9B%AE-3"><span class="toc-text"> 1.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E6%80%9D%E8%B7%AF%E6%A0%B8%E5%BF%83%E5%8C%BA%E9%97%B4%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text"> 1.2思路（核心：区间的定义）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E5%B7%A6%E9%97%AD%E5%8F%B3%E9%97%AD"><span class="toc-text"> 1.3左闭右闭</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E5%B7%A6%E9%97%AD%E5%8F%B3%E5%BC%80"><span class="toc-text"> 1.4左闭右开</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E6%80%BB%E7%BB%93"><span class="toc-text"> 1.5总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text"> 2.移除元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E9%A2%98%E7%9B%AE-3"><span class="toc-text"> 2.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E6%80%9D%E8%B7%AF"><span class="toc-text"> 2.1思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#221%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95"><span class="toc-text"> 2.2.1暴力解法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#222%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="toc-text"> 2.2.2双指针法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E6%80%BB%E7%BB%93"><span class="toc-text"> 23总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="toc-text"> 3.有序数组的平方</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E9%A2%98%E7%9B%AE-2"><span class="toc-text"> 3.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E6%80%9D%E8%B7%AF"><span class="toc-text"> 3.2思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#321%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95"><span class="toc-text"> 3.2.1暴力解法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#322%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="toc-text"> 3.2.2双指针法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-text"> 4.长度最小的子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41%E9%A2%98%E7%9B%AE"><span class="toc-text"> 4.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42%E6%80%9D%E8%B7%AF"><span class="toc-text"> 4.2思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#421%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95"><span class="toc-text"> 4.2.1暴力解法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#422%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8F%8C%E6%8C%87%E9%92%88%E5%8D%87%E7%BA%A7"><span class="toc-text"> 4.2.2滑动窗口（双指针升级）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B52"><span class="toc-text"> 5.螺旋矩阵2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51%E9%A2%98%E7%9B%AE"><span class="toc-text"> 5.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52%E6%80%9D%E8%B7%AF"><span class="toc-text"> 5.2思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text"> 链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text"> 1.移除元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E9%A2%98%E7%9B%AE-4"><span class="toc-text"> 1.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E6%80%9D%E8%B7%AF"><span class="toc-text"> 1.2思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#121%E6%96%B9%E6%B3%95%E4%B8%80%E5%88%A0%E9%99%A4%E5%A4%B4%E8%8A%82%E7%82%B9"><span class="toc-text"> 1.2.1方法一：删除头节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E4%BD%BF%E7%94%A8pre-cur%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E5%AE%9E%E7%8E%B0%E5%88%A0%E9%99%A4%E9%80%BB%E8%BE%91"><span class="toc-text"> （1）使用pre、cur两个节点实现删除逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E4%BD%BF%E7%94%A8curr%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E5%AE%9E%E7%8E%B0%E5%88%A0%E9%99%A4%E9%80%BB%E8%BE%91"><span class="toc-text"> （2）使用curr一个节点实现删除逻辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#122%E6%96%B9%E6%B3%95%E4%BA%8C%E8%99%9A%E6%8B%9F%E5%A4%B4%E8%8A%82%E7%82%B9"><span class="toc-text"> 1.2.2方法二：虚拟头节点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text"> 2.反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E9%A2%98%E7%9B%AE-4"><span class="toc-text"> 2.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E8%A7%A3%E6%B3%95"><span class="toc-text"> 2.2解法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#221%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="toc-text"> 2.2.1双指针法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#222%E9%80%92%E5%BD%92%E6%B3%95"><span class="toc-text"> 2.2.2递归法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text"> 3.两两交换链表中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E9%A2%98%E7%9B%AE-3"><span class="toc-text"> 3.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E8%A7%A3%E6%B3%95%E8%99%9A%E6%8B%9F%E5%A4%B4%E8%8A%82%E7%82%B9"><span class="toc-text"> 3.2解法：虚拟头节点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%9A%84%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-text"> 4.删除链表的倒数的第N个节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41%E9%A2%98%E7%9B%AE-2"><span class="toc-text"> 4.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42%E8%A7%A3%E6%B3%95%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text"> 4.2解法：双指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4"><span class="toc-text"> 5.链表相交</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51%E9%A2%98%E7%9B%AE-2"><span class="toc-text"> 5.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52%E8%A7%A3%E6%B3%95%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text"> 5.2解法：双指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-text"> 6.环形链表 ||</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#61%E9%A2%98%E7%9B%AE"><span class="toc-text"> 6.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62%E8%A7%A3%E6%B3%95%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%8C%96%E7%AE%80"><span class="toc-text"> 6.2解法：数学公式化简</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#621%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF"><span class="toc-text"> 6.2.1判断链表是否有环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#622%E6%80%8E%E4%B9%88%E6%89%BE%E5%88%B0%E8%AF%A5%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3"><span class="toc-text"> 6.2.2怎么找到该环的入口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#623%E4%BB%A3%E7%A0%81"><span class="toc-text"> 6.2.3代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-text"> 7.排序链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#71%E9%A2%98%E7%9B%AE"><span class="toc-text"> 7.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72%E8%A7%A3%E6%B3%95%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text"> 7.2解法：归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#721%E6%8E%92%E5%BA%8F%E6%80%9D%E8%B7%AF"><span class="toc-text"> 7.2.1排序思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BB%A5%E5%8F%8A%E5%8F%82%E6%95%B0"><span class="toc-text"> （1）递归函数返回值以及参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6"><span class="toc-text"> （2）终止条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E9%81%8D%E5%8E%86%E8%BF%87%E7%A8%8B"><span class="toc-text"> （3）遍历过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#722%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 7.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-text"> 8.回文链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#81%E9%A2%98%E7%9B%AE"><span class="toc-text"> 8.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82%E8%A7%A3%E6%B3%95%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text"> 8.2解法：双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#821%E8%A7%A3%E6%B3%95%E6%80%9D%E8%B7%AF"><span class="toc-text"> 8.2.1解法思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#822%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 8.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%B8%8C"><span class="toc-text"> 哈希</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-text"> 1.有效的字母异位词</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E9%A2%98%E7%9B%AE-5"><span class="toc-text"> 1.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E8%A7%A3%E6%B3%95%E5%93%88%E5%B8%8C%E8%A1%A8%E6%80%9D%E6%83%B3"><span class="toc-text"> 1.2解法：哈希表思想</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="toc-text"> 2.两个数组的交集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E9%A2%98%E7%9B%AE-5"><span class="toc-text"> 2.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E8%A7%A3%E6%B3%95hashset"><span class="toc-text"> 2.2解法：HashSet</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="toc-text"> 3.快乐数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E9%A2%98%E7%9B%AE-4"><span class="toc-text"> 3.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E8%A7%A3%E6%B3%95%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text"> 3.2解法：哈希表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text"> 4.两数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41%E9%A2%98%E7%9B%AE-3"><span class="toc-text"> 4.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42%E8%A7%A3%E6%B3%95key-value"><span class="toc-text"> 4.2解法：key-value</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text"> 5.四数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51%E9%A2%98%E7%9B%AE-3"><span class="toc-text"> 5.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52%E8%A7%A3%E6%B3%95key-value"><span class="toc-text"> 5.2解法：key-value</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E8%B5%8E%E9%87%91%E4%BF%A1"><span class="toc-text"> 6.赎金信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#61%E9%A2%98%E7%9B%AE-2"><span class="toc-text"> 6.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62%E8%A7%A3%E6%B3%95%E5%93%88%E5%B8%8C%E8%A1%A8%E6%80%9D%E6%83%B3"><span class="toc-text"> 6.2解法：哈希表思想</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text"> 7.三数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#71%E9%A2%98%E7%9B%AE-2"><span class="toc-text"> 7.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72%E8%A7%A3%E6%B3%95%E4%B8%80%E5%93%88%E5%B8%8C%E6%B3%95"><span class="toc-text"> 7.2解法一：哈希法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73%E8%A7%A3%E6%B3%95%E4%BA%8C%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="toc-text"> 7.3解法二：双指针法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text"> 8.四数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#81%E9%A2%98%E7%9B%AE-2"><span class="toc-text"> 8.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82%E8%A7%A3%E6%B3%95%E4%B8%80%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="toc-text"> 8.2解法一：双指针法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="toc-text"> 9.字母异位词分组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#91%E9%A2%98%E7%9B%AE"><span class="toc-text"> 9.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92%E8%A7%A3%E6%B3%95%E5%93%88%E5%B8%8C%E6%B3%95"><span class="toc-text"> 9.2解法：哈希法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#921%E5%93%88%E5%B8%8C%E6%80%9D%E8%B7%AF"><span class="toc-text"> 9.2.1哈希思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#922%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 9.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="toc-text"> 10.最长连续序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#101%E9%A2%98%E7%9B%AE"><span class="toc-text"> 10.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102%E8%A7%A3%E6%B3%95%E5%93%88%E5%B8%8C%E6%B3%95"><span class="toc-text"> 10.2解法：哈希法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1021%E5%93%88%E5%B8%8C%E6%80%9D%E8%B7%AF"><span class="toc-text"> 10.2.1哈希思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1022%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 10.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text"> 滑动窗口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-text"> 1.无重复字符的最长子串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E9%A2%98%E7%9B%AE-6"><span class="toc-text"> 1.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E8%A7%A3%E6%B3%95%E4%B8%80%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text"> 1.2解法一：滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#121%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text"> 1.2.1解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#122%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-text"> 1.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-text"> 2.找到字符串中所有字母异位词</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E9%A2%98%E7%9B%AE-6"><span class="toc-text"> 2.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E8%A7%A3%E6%B3%95%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text"> 2.2解法：滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#221%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text"> 2.2.1解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#222%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-text"> 2.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-text"> 栈与队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-text"> 1.有效的括号</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E9%A2%98%E7%9B%AE-7"><span class="toc-text"> 1.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E8%A7%A3%E6%B3%95%E6%A0%88"><span class="toc-text"> 1.2解法：栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-text"> 2.删除字符串中的所有相邻重复项</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E9%A2%98%E7%9B%AE-7"><span class="toc-text"> 2.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E8%A7%A3%E6%B3%95%E6%A0%88"><span class="toc-text"> 2.2解法：栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-text"> 3.逆波兰表达式求值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E9%A2%98%E7%9B%AE-5"><span class="toc-text"> 3.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E8%A7%A3%E6%B3%95%E6%A0%88"><span class="toc-text"> 3.2解法：栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text"> 二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-text"> 1.二叉树理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-text"> 1.1二叉树的种类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#111%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text"> 1.1.1满二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#112%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text"> 1.1.2完全二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#113%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text"> 1.1.3二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#114%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text"> 1.1.4平衡二叉搜索树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-text"> 1.2二叉树的存储方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#121%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-text"> 1.2.1链式存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#122%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-text"> 1.2.2顺序存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-text"> 1.3二叉树的遍历方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text"> 1.4二叉树的定义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-text"> 2.二叉树的递归遍历</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86"><span class="toc-text"> 3.二叉树的迭代遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="toc-text"> 3.1前序遍历（迭代法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="toc-text"> 3.2中序遍历（迭代法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="toc-text"> 3.3后序遍历（迭代法）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="toc-text"> 4.二叉树的统一迭代法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-text"> 4.1问题分析及解决思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="toc-text"> 4.2中序遍历（统一迭代法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text"> 4.3前序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text"> 4.4后序遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text"> 5.二叉树的层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51-102_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text"> 5.1 102_二叉树的层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#511%E9%97%AE%E9%A2%98"><span class="toc-text"> 5.1.1问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#512%E8%A7%A3%E6%B3%95%E9%98%9F%E5%88%97"><span class="toc-text"> 5.1.2解法：队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-107_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text"> 5.2 107_二叉树的层序遍历||</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#521%E9%97%AE%E9%A2%98"><span class="toc-text"> 5.2.1问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#522%E8%A7%A3%E6%B3%95%E9%98%9F%E5%88%97"><span class="toc-text"> 5.2.2解法：队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-199_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="toc-text"> 5.3 199_二叉树的右视图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#531%E9%97%AE%E9%A2%98"><span class="toc-text"> 5.3.1问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#532%E8%A7%A3%E5%86%B3%E9%98%9F%E5%88%97"><span class="toc-text"> 5.3.2解决：队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-637_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="toc-text"> 5.4 637_二叉树的层平均值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#541%E9%97%AE%E9%A2%98"><span class="toc-text"> 5.4.1问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#542%E8%A7%A3%E5%86%B3%E9%98%9F%E5%88%97"><span class="toc-text"> 5.4.2解决：队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-429_n%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text"> 5.5 429_N叉树的层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#551%E9%97%AE%E9%A2%98"><span class="toc-text"> 5.5.1问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#552%E8%A7%A3%E6%B3%95%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E6%A0%88"><span class="toc-text"> 5.5.2解法：层序遍历+栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-515_%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text"> 5.6 515_在每个树行中找最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#561%E9%97%AE%E9%A2%98"><span class="toc-text"> 5.6.1问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#562%E8%A7%A3%E6%B3%95%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text"> 5.6.2解法：层序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57-116_%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="toc-text"> 5.7 116_填充每个节点的下一个右侧节点指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#571%E9%97%AE%E9%A2%98"><span class="toc-text"> 5.7.1问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#572%E8%A7%A3%E6%B3%95%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text"> 5.7.2解法：层序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58-116_%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="toc-text"> 5.8 116_填充每个节点的下一个右侧节点指针||</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#581%E9%97%AE%E9%A2%98"><span class="toc-text"> 5.8.1问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#582%E8%A7%A3%E6%B3%95%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text"> 5.8.2解法：层序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59-104_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-text"> 5.9 104_二叉树的最大深度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#591%E9%97%AE%E9%A2%98"><span class="toc-text"> 5.9.1问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#592%E8%A7%A3%E6%B3%95%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text"> 5.9.2解法：层序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#510-111_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="toc-text"> 5.10 111_二叉树的最小深度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5101%E9%97%AE%E9%A2%98"><span class="toc-text"> 5.10.1问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5102%E8%A7%A3%E5%86%B3"><span class="toc-text"> 5.10.2解决</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text"> 6.翻转二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#61%E9%97%AE%E9%A2%98"><span class="toc-text"> 6.1问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62%E8%A7%A3%E6%B3%95%E4%B8%80%E9%80%92%E5%BD%92"><span class="toc-text"> 6.2解法一：递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#621%E9%80%92%E5%BD%92%E6%80%9D%E8%B7%AF"><span class="toc-text"> 6.2.1递归思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E7%A1%AE%E5%AE%9A%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text"> （1）确定递归函数的参数和返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%A1%AE%E5%AE%9A%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6"><span class="toc-text"> （2）确定终止条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E7%A1%AE%E5%AE%9A%E5%8D%95%E5%B1%82%E9%80%92%E5%BD%92%E7%9A%84%E9%80%BB%E8%BE%91"><span class="toc-text"> （3）确定单层递归的逻辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#622%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81"><span class="toc-text"> 6.2.2全部代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63%E8%A7%A3%E6%B3%95%E4%BA%8C%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text"> 6.3解法二：层序遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text"> 7.对称二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#71%E9%97%AE%E9%A2%98"><span class="toc-text"> 7.1问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72%E8%A7%A3%E6%B3%95%E4%B8%80%E9%80%92%E5%BD%92"><span class="toc-text"> 7.2解法一：递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#721%E9%80%92%E5%BD%92%E6%80%9D%E8%B7%AF"><span class="toc-text"> 7.2.1递归思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E7%A1%AE%E5%AE%9A%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC-2"><span class="toc-text"> （1）确定递归函数的参数和返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%A1%AE%E5%AE%9A%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6-2"><span class="toc-text"> （2）确定终止条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E7%A1%AE%E5%AE%9A%E5%8D%95%E5%B1%82%E9%80%92%E5%BD%92%E7%9A%84%E9%80%BB%E8%BE%91-2"><span class="toc-text"> （3）确定单层递归的逻辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#722%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-text"> 7.2.2代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73%E8%A7%A3%E6%B3%95%E4%BA%8C%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="toc-text"> 7.3解法二：迭代法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-text"> 8.完全二叉树的节点个数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#81%E9%97%AE%E9%A2%98"><span class="toc-text"> 8.1问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82%E8%A7%A3%E6%B3%95%E4%B8%80%E9%80%92%E5%BD%92"><span class="toc-text"> 8.2解法一：递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#83%E8%A7%A3%E6%B3%95%E4%BA%8C%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text"> 8.3解法二：层序遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text"> 9.平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#91%E9%97%AE%E9%A2%98"><span class="toc-text"> 9.1问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92%E8%A7%A3%E6%B3%95%E4%B8%80%E9%80%92%E5%BD%92"><span class="toc-text"> 9.2解法一：递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#921%E9%80%92%E5%BD%92%E6%80%9D%E8%B7%AF"><span class="toc-text"> 9.2.1递归思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E7%A1%AE%E5%AE%9A%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8C%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-text"> （1）确定递归函数返回值和参数值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%A1%AE%E5%AE%9A%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6-3"><span class="toc-text"> （2）确定终止条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E7%A1%AE%E5%AE%9A%E9%80%92%E5%BD%92%E9%80%BB%E8%BE%91"><span class="toc-text"> （3）确定递归逻辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#922%E4%BB%A3%E7%A0%81"><span class="toc-text"> 9.2.2代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-text"> 10.完全二叉树的所有路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#101%E9%97%AE%E9%A2%98"><span class="toc-text"> 10.1问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102%E8%A7%A3%E6%B3%95%E4%B8%80%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%9B%9E%E6%BA%AF"><span class="toc-text"> 10.2解法一：前序遍历+回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1021%E9%80%92%E5%BD%92%E6%80%9D%E8%B7%AF"><span class="toc-text"> 10.2.1递归思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E7%A1%AE%E5%AE%9A%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text"> （1）确定递归函数参数以及返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%A1%AE%E5%AE%9A%E9%80%92%E5%BD%92%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6"><span class="toc-text"> （2）确定递归终止条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E7%A1%AE%E5%AE%9A%E9%80%92%E5%BD%92%E9%80%BB%E8%BE%91-2"><span class="toc-text"> （3）确定递归逻辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1022%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-text"> 10.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="toc-text"> 11.左叶子之和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#111%E9%97%AE%E9%A2%98"><span class="toc-text"> 11.1问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#112%E8%A7%A3%E6%B3%95%E4%B8%80%E9%80%92%E5%BD%92"><span class="toc-text"> 11.2解法一：递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1121%E9%80%92%E5%BD%92%E6%80%9D%E8%B7%AF"><span class="toc-text"> 11.2.1递归思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1122%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 11.2.2代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#113%E8%A7%A3%E6%B3%95%E4%BA%8C%E6%A0%88"><span class="toc-text"> 11.3解法二：栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1131%E6%A0%88%E6%80%9D%E6%83%B3"><span class="toc-text"> 11.3.1栈思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1132%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 11.3.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="toc-text"> 12.找树左下角的值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#121%E9%97%AE%E9%A2%98"><span class="toc-text"> 12.1问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#122%E8%A7%A3%E6%B3%95%E4%B8%80%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text"> 12.2解法一：层序遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-text"> 13.路径总和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#131%E9%97%AE%E9%A2%98"><span class="toc-text"> 13.1问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#132%E8%A7%A3%E6%B3%95%E4%B8%80%E9%80%92%E5%BD%92"><span class="toc-text"> 13.2解法一：递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1321%E9%80%92%E5%BD%92%E6%80%9D%E8%B7%AF"><span class="toc-text"> 13.2.1递归思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E7%A1%AE%E5%AE%9A%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC-2"><span class="toc-text"> （1）确定递归函数参数以及返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%A1%AE%E5%AE%9A%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6-4"><span class="toc-text"> （2）确定终止条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E7%A1%AE%E5%AE%9A%E9%80%92%E5%BD%92%E9%80%BB%E8%BE%91-3"><span class="toc-text"> （3）确定递归逻辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1322%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 13.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-text"> 14.路径总和 ||</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#141%E9%97%AE%E9%A2%98"><span class="toc-text"> 14.1问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142%E8%A7%A3%E6%B3%95%E4%B8%80%E9%80%92%E5%BD%92"><span class="toc-text"> 14.2解法一：递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1421%E9%80%92%E5%BD%92%E6%80%9D%E8%B7%AF"><span class="toc-text"> 14.2.1递归思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E7%A1%AE%E5%AE%9A%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC-3"><span class="toc-text"> （1）确定递归函数参数以及返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%A1%AE%E5%AE%9A%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6-5"><span class="toc-text"> （2）确定终止条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E7%A1%AE%E5%AE%9A%E9%80%92%E5%BD%92%E9%80%BB%E8%BE%91-4"><span class="toc-text"> （3）确定递归逻辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1422%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 14.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-text"> 回溯</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-text"> 1.回溯算法理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E6%BA%AF%E6%B3%95"><span class="toc-text"> 1.1什么是回溯法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E5%9B%9E%E6%BA%AF%E6%B3%95%E7%9A%84%E6%95%88%E7%8E%87"><span class="toc-text"> 1.2回溯法的效率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E5%9B%9E%E6%BA%AF%E6%B3%95%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text"> 1.3回溯法解决的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E6%B3%95"><span class="toc-text"> 1.4如何理解回溯法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%A8%A1%E6%9D%BF"><span class="toc-text"> 1.5回溯法模板</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E7%BB%84%E5%90%88"><span class="toc-text"> 2.组合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E9%97%AE%E9%A2%98"><span class="toc-text"> 2.1问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E8%A7%A3%E6%B3%95%E4%B8%80%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95%E5%BE%AA%E7%8E%AF%E6%AC%A1%E6%95%B0%E4%B8%8D%E7%A1%AE%E5%AE%9A"><span class="toc-text"> 2.2解法一：暴力解法（循环次数不确定）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E8%A7%A3%E6%B3%95%E4%BA%8C%E5%9B%9E%E6%BA%AF"><span class="toc-text"> 2.3解法二：回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#231%E5%9B%9E%E6%BA%AF%E6%80%9D%E8%B7%AF"><span class="toc-text"> 2.3.1回溯思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%9B%9E%E6%BA%AF%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BB%A5%E5%8F%8A%E5%8F%82%E6%95%B0"><span class="toc-text"> （1）回溯函数模板返回值以及参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%9B%9E%E6%BA%AF%E5%87%BD%E6%95%B0%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6"><span class="toc-text"> （2）回溯函数终止条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%9B%9E%E6%BA%AF%E6%90%9C%E7%B4%A2%E7%9A%84%E9%81%8D%E5%8E%86%E8%BF%87%E7%A8%8B"><span class="toc-text"> （3）回溯搜索的遍历过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#232%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-text"> 2.3.2代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#233%E5%89%AA%E6%9E%9D%E6%93%8D%E4%BD%9C"><span class="toc-text"> 2.3.3剪枝操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text"> 3.组合总和 |||</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E9%97%AE%E9%A2%98"><span class="toc-text"> 3.1问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E8%A7%A3%E6%B3%95%E5%9B%9E%E6%BA%AF"><span class="toc-text"> 3.2解法：回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#321%E5%9B%9E%E6%BA%AF%E6%80%9D%E8%B7%AF"><span class="toc-text"> 3.2.1回溯思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BB%A5%E5%8F%8A%E5%8F%82%E6%95%B0"><span class="toc-text"> （1）函数返回值以及参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6-2"><span class="toc-text"> （2）终止条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E9%81%8D%E5%8E%86%E8%BF%87%E7%A8%8B-2"><span class="toc-text"> （3）遍历过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#322%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 3.2.2代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#323%E5%89%AA%E6%9E%9D%E6%93%8D%E4%BD%9C"><span class="toc-text"> 3.2.3剪枝操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-text"> 4.电话号码的字母组合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41%E9%97%AE%E9%A2%98"><span class="toc-text"> 4.1问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42%E8%A7%A3%E6%B3%95%E5%9B%9E%E6%BA%AF"><span class="toc-text"> 4.2解法：回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#421%E5%9B%9E%E6%BA%AF%E6%80%9D%E8%B7%AF"><span class="toc-text"> 4.2.1回溯思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BB%A5%E5%8F%8A%E5%8F%82%E6%95%B0-2"><span class="toc-text"> （1）函数返回值以及参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6-3"><span class="toc-text"> （2）终止条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E9%81%8D%E5%8E%86%E8%BF%87%E7%A8%8B-3"><span class="toc-text"> （3）遍历过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#422%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 4.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text"> 5.组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51%E9%A2%98%E7%9B%AE-4"><span class="toc-text"> 5.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52%E8%A7%A3%E6%B3%95%E5%9B%9E%E6%BA%AF"><span class="toc-text"> 5.2解法：回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#521%E5%9B%9E%E6%BA%AF%E6%80%9D%E8%B7%AF"><span class="toc-text"> 5.2.1回溯思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BB%A5%E5%8F%8A%E5%8F%82%E6%95%B0-3"><span class="toc-text"> （1）函数返回值以及参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6-4"><span class="toc-text"> （2）终止条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E9%81%8D%E5%8E%86%E8%BF%87%E7%A8%8B-4"><span class="toc-text"> （3）遍历过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#522%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 5.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text"> 6.组合总和 ||</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#61%E9%A2%98%E7%9B%AE-3"><span class="toc-text"> 6.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62%E8%A7%A3%E6%B3%95%E5%9B%9E%E6%BA%AF"><span class="toc-text"> 6.2解法：回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#621%E5%9B%9E%E6%BA%AF%E6%80%9D%E8%B7%AF"><span class="toc-text"> 6.2.1回溯思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BB%A5%E5%8F%8A%E5%8F%82%E6%95%B0-4"><span class="toc-text"> （1）函数返回值以及参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6-5"><span class="toc-text"> （2）终止条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E9%81%8D%E5%8E%86%E8%BF%87%E7%A8%8B-5"><span class="toc-text"> （3）遍历过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#622%E4%BB%A3%E7%A0%81"><span class="toc-text"> 6.2.2代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-text"> 7.分割回文串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#71%E9%A2%98%E7%9B%AE-3"><span class="toc-text"> 7.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72%E8%A7%A3%E6%B3%95%E5%9B%9E%E6%BA%AF"><span class="toc-text"> 7.2解法：回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#721%E5%9B%9E%E6%BA%AF%E6%80%9D%E8%B7%AF"><span class="toc-text"> 7.2.1回溯思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BB%A5%E5%8F%8A%E5%8F%82%E6%95%B0-5"><span class="toc-text"> （1）函数返回值以及参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6-6"><span class="toc-text"> （2）终止条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E9%81%8D%E5%8E%86%E8%BF%87%E7%A8%8B-6"><span class="toc-text"> （3）遍历过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#722%E4%BB%A3%E7%A0%81"><span class="toc-text"> 7.2.2代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80"><span class="toc-text"> 8.复原IP地址</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#81%E9%A2%98%E7%9B%AE-3"><span class="toc-text"> 8.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82%E8%A7%A3%E6%B3%95%E5%9B%9E%E6%BA%AF"><span class="toc-text"> 8.2解法：回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#821%E5%9B%9E%E6%BA%AF%E6%80%9D%E8%B7%AF"><span class="toc-text"> 8.2.1回溯思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BB%A5%E5%8F%8A%E5%8F%82%E6%95%B0-6"><span class="toc-text"> （1）函数返回值以及参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6-7"><span class="toc-text"> （2）终止条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E9%81%8D%E5%8E%86%E8%BF%87%E7%A8%8B-7"><span class="toc-text"> （3）遍历过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#822%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-text"> 8.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9%E5%AD%90%E9%9B%86"><span class="toc-text"> 9.子集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#91%E9%A2%98%E7%9B%AE-2"><span class="toc-text"> 9.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92%E8%A7%A3%E6%B3%95%E5%9B%9E%E6%BA%AF"><span class="toc-text"> 9.2解法：回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#921%E5%9B%9E%E6%BA%AF%E6%80%9D%E8%B7%AF"><span class="toc-text"> 9.2.1回溯思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BB%A5%E5%8F%8A%E5%8F%82%E6%95%B0-7"><span class="toc-text"> （1）函数返回值以及参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6-8"><span class="toc-text"> （2）终止条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E9%81%8D%E5%8E%86%E8%BF%87%E7%A8%8B-8"><span class="toc-text"> （3）遍历过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#922%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-text"> 9.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10%E5%AD%90%E9%9B%86"><span class="toc-text"> 10.子集 ||</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#101%E9%A2%98%E7%9B%AE-2"><span class="toc-text"> 10.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102%E8%A7%A3%E6%B3%95%E5%9B%9E%E6%BA%AF"><span class="toc-text"> 10.2解法：回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1021%E5%9B%9E%E6%BA%AF%E6%80%9D%E8%B7%AF"><span class="toc-text"> 10.2.1回溯思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1022%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-text"> 10.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-text"> 11.全排列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#111%E9%A2%98%E7%9B%AE"><span class="toc-text"> 11.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#112%E8%A7%A3%E6%B3%95%E5%9B%9E%E6%BA%AF"><span class="toc-text"> 11.2解法：回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1121%E5%9B%9E%E6%BA%AF%E6%80%9D%E8%B7%AF"><span class="toc-text"> 11.2.1回溯思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BB%A5%E5%8F%8A%E5%8F%82%E6%95%B0-8"><span class="toc-text"> （1）函数返回值以及参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6-9"><span class="toc-text"> （2）终止条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E9%81%8D%E5%8E%86%E8%BF%87%E7%A8%8B-9"><span class="toc-text"> （3）遍历过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1122%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-text"> 11.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-text"> 12.全排列 ||</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#121%E9%A2%98%E7%9B%AE"><span class="toc-text"> 12.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#122%E8%A7%A3%E6%B3%95%E5%9B%9E%E6%BA%AF"><span class="toc-text"> 12.2解法：回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1221%E5%9B%9E%E6%BA%AF%E6%80%9D%E8%B7%AF"><span class="toc-text"> 12.2.1回溯思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1223%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 12.2.3代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13n%E7%9A%87%E5%90%8E"><span class="toc-text"> 13.N皇后</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#131%E9%A2%98%E7%9B%AE"><span class="toc-text"> 13.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#132%E8%A7%A3%E6%B3%95%E5%9B%9E%E6%BA%AF"><span class="toc-text"> 13.2解法：回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1321%E5%9B%9E%E6%BA%AF%E6%80%9D%E8%B7%AF"><span class="toc-text"> 13.2.1回溯思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BB%A5%E5%8F%8A%E5%8F%82%E6%95%B0-9"><span class="toc-text"> （1）函数返回值以及参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6-10"><span class="toc-text"> （2）终止条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E9%81%8D%E5%8E%86%E8%BF%87%E7%A8%8B-10"><span class="toc-text"> （3）遍历过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1322%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-text"> 13.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="toc-text"> 14.括号生成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#141%E9%A2%98%E7%9B%AE"><span class="toc-text"> 14.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142%E8%A7%A3%E6%B3%95%E5%9B%9E%E6%BA%AF"><span class="toc-text"> 14.2解法：回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1421%E5%9B%9E%E6%BA%AF%E6%80%9D%E8%B7%AF"><span class="toc-text"> 14.2.1回溯思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BB%A5%E5%8F%8A%E5%8F%82%E6%95%B0-10"><span class="toc-text"> （1）函数返回值以及参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6-11"><span class="toc-text"> （2）终止条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E9%81%8D%E5%8E%86%E8%BF%87%E7%A8%8B-11"><span class="toc-text"> （3）遍历过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1422%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-text"> 14.2.2代码实现</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/3dec2828.html" title="自定义雪花算法"><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202411072128141.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="自定义雪花算法"/></a><div class="content"><a class="title" href="/posts/3dec2828.html" title="自定义雪花算法">自定义雪花算法</a><time datetime="2024-11-07T13:27:29.000Z" title="发表于 2024-11-07 21:27:29">2024-11-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2fccc80a.html" title="基于ES和Canal分别实现数据检索/同步"><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202411031858285.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于ES和Canal分别实现数据检索/同步"/></a><div class="content"><a class="title" href="/posts/2fccc80a.html" title="基于ES和Canal分别实现数据检索/同步">基于ES和Canal分别实现数据检索/同步</a><time datetime="2024-11-03T10:56:12.000Z" title="发表于 2024-11-03 18:56:12">2024-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/46ceb5bd.html" title="基于Redis实现用户活跃月/日排行榜"><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410291146967.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于Redis实现用户活跃月/日排行榜"/></a><div class="content"><a class="title" href="/posts/46ceb5bd.html" title="基于Redis实现用户活跃月/日排行榜">基于Redis实现用户活跃月/日排行榜</a><time datetime="2024-10-29T03:44:41.000Z" title="发表于 2024-10-29 11:44:41">2024-10-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8239deef.html" title="基于微信公众号+验证码实现微信登录"><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410282106730.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于微信公众号+验证码实现微信登录"/></a><div class="content"><a class="title" href="/posts/8239deef.html" title="基于微信公众号+验证码实现微信登录">基于微信公众号+验证码实现微信登录</a><time datetime="2024-10-28T13:05:25.000Z" title="发表于 2024-10-28 21:05:25">2024-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/172c1a2d.html" title="ElasticSearch学习笔记"><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410161138400.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ElasticSearch学习笔记"/></a><div class="content"><a class="title" href="/posts/172c1a2d.html" title="ElasticSearch学习笔记">ElasticSearch学习笔记</a><time datetime="2024-10-16T03:36:17.000Z" title="发表于 2024-10-16 11:36:17">2024-10-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer-left"><div class="footer-title"><span>拾忆鱼's Blog | </span><span class="footer-copyright">&copy;2024 By 拾忆鱼</span></div><div class="wordcount"></div><span>拾忆鱼 已经写了 265.5k 字，</span><span>好像写完一本 钱钟书 的 《围城》 了啊</span></div><div id="footer-right"><div class="footer_custom_text"><div id="runtime"></div></div><div class="footer-totop"><i class="fas fa-chevron-up" onclick="rmf.scrollToTop()"></i></div><div class="footer-info"><p>使用Hexo框架 | 基于butterfly修改 | 萌ICP备20240730号</p><!--a(title='湘公网安备 2023003198号' href='http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=2023003198')= '湘公网安备 2023003198号'--><!--a(title='湘ICP备2023003198号' href='https://beian.miit.gov.cn/')= '湘ICP备2023003198号'--></div><div class="footer-service"><a title="51LA" target="_blank" rel="noopener" href="https://www.51.la"><img alt="51LA" src="https://gitee.com/linhaipengg/md_-picture/raw/master/51la.png"/></a><a title="CC BY-NC-SA 4.0" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><img alt="CC BY-NC-SA 4.0" src="https://img.june-pj.cn/img/2024/01/16/cc.webp"/></a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.haipeng-lin.cn',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.haipeng-lin.cn',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/twikoo/1.4.18/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script data-pjax src="/gitcalendar/js/gitcalendar.js"></script><script data-pjax src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/js/swiper.min.js"></script><script src="/js/footer.js"></script><script type="text/javascript" src="/js/main.js"></script><script data-pjax type="text/javascript" src="/js/essay/essay.js"></script><script data-pjax type="text/javascript" src="/js/essay/waterfall.js"></script><link rel="stylesheet" href="/css/swiper.css"><script data-pjax src="/js/categoryBar/categoryBar.js"></script><link data-pjax defer="" rel="stylesheet" href="/css/categoryBar/heoMainColor.css"><link data-pjax defer="" rel="stylesheet" href="/css/categoryBar/categoryBar.css"><script type="text/javascript" src="/js/nav.js"></script><script src="/js/countup.js"></script><script data-pjax type="text/javascript" src="/js/memos/waterfall.min.js"></script><script data-pjax type="text/javascript" src="/js/memos/imgStatus.min.js"></script><script data-pjax type="text/javascript" src="/js/memos/lately.min.js"></script><script type="text/javascript" src="/js/memos/photo.js"></script><script type="text/javascript" src="/js/icat.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>