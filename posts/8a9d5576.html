<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>动态规划思想 | 拾忆鱼's Blog</title><meta name="author" content="拾忆鱼"><meta name="copyright" content="拾忆鱼"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer" /><meta name="description" content="动态规划  1.动态规划理论基础  1.1题目分类大纲   1.2什么是动态规划？  动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。 所以动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的，   1.3背包问题   例如：有N件物品和一个最多能背重量为W 的背包。">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划思想">
<meta property="og:url" content="https://www.haipeng-lin.cn/posts/8a9d5576.html">
<meta property="og:site_name" content="拾忆鱼&#39;s Blog">
<meta property="og:description" content="动态规划  1.动态规划理论基础  1.1题目分类大纲   1.2什么是动态规划？  动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。 所以动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的，   1.3背包问题   例如：有N件物品和一个最多能背重量为W 的背包。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/linhaipengg/md_-picture/raw/master/%E7%AE%97%E6%B3%95.png">
<meta property="article:published_time" content="2024-08-29T04:47:07.000Z">
<meta property="article:modified_time" content="2024-09-01T01:41:00.039Z">
<meta property="article:author" content="拾忆鱼">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/linhaipengg/md_-picture/raw/master/%E7%AE%97%E6%B3%95.png"><link rel="shortcut icon" href="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410101530409.png"><link rel="canonical" href="https://www.haipeng-lin.cn/posts/8a9d5576"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="msvalidate.01" content="7A691DA1ABC779E7F680EF66E1D934AA"/><meta name="google-site-verification"/><meta name="baidu-site-verification" content="XXXXX"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":250},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 拾忆鱼","link":"链接: ","source":"来源: 拾忆鱼's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '动态规划思想',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-01 09:41:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/gitcalendar/css/gitcalendar.css"/><link rel="stylesheet" href="/css/tag_plugins.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/swiper.min.css"><script src="https://libs.baidu.com/jquery/2.1.4/jquery.min.js"></script><link rel="stylesheet" href="/css/tags.css"><link rel="stylesheet" href="/css/double_article.css"><link rel="stylesheet" href="/css/nav.css"><link rel="stylesheet" href="/css/essay_page.css"><script type="text/javascript" src="/js/echarts.min.js"></script><script type="text/javascript" src="/js/copy.js"></script><script src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><link rel="stylesheet" href="/css/copyright.css"><link rel="stylesheet" href="/css/progress_bar.css"><link rel="stylesheet" href="/css/footer.css"><link rel="stylesheet" href="/css/page.css"><link rel="stylesheet" href="/css/layout.css"><link rel="stylesheet" href="/css/color.css"><link rel="stylesheet" href="/css/cursors/cursors.css"><link rel="stylesheet" href="/css/fonts/font.css"><link rel="stylesheet" href="/css/about/about.css"><link rel="stylesheet" href="/css/about/careers.css"><link rel="stylesheet" href="/css/about/genshinimpact.css"><link rel="stylesheet" href="/css/about/hello-about.css"><link rel="stylesheet" href="/css/about/site.css"><link rel="stylesheet" href="/css/about/skills.css"><link rel="stylesheet" href="/css/photo.css"><link rel="stylesheet" href="/css/icat.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="拾忆鱼's Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410101530409.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives"><i class="fa-fw fas fa-archive"></i><span> 全部</span></a></li><li><a class="site-page child" href="/categories"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heart"></i><span> 空间</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/essay"><i class="fa-fw fas fa-comments"></i><span> 碎碎念</span></a></li><li><a class="site-page child" href="/collect"><i class="fa-fw fas fa-walking"></i><span> 足迹阁</span></a></li><li><a class="site-page child" href="/photo"><i class="fa-fw fas fa-images"></i><span> 照片墙</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about"><i class="fa-fw fas fa-address-card"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">拾忆鱼's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives"><i class="fa-fw fas fa-archive"></i><span> 全部</span></a></li><li><a class="site-page child" href="/categories"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heart"></i><span> 空间</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/essay"><i class="fa-fw fas fa-comments"></i><span> 碎碎念</span></a></li><li><a class="site-page child" href="/collect"><i class="fa-fw fas fa-walking"></i><span> 足迹阁</span></a></li><li><a class="site-page child" href="/photo"><i class="fa-fw fas fa-images"></i><span> 照片墙</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about"><i class="fa-fw fas fa-address-card"></i><span> 关于</span></a></div></div><center id="name-container"><a id="page-name" href="javascript:btf.scrollToDest(0, 500)">PAGE_NAME</a></center></div><div id="toggleButtons"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">动态规划思想</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-29T04:47:07.000Z" title="发表于 2024-08-29 12:47:07">2024-08-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-01T01:41:00.039Z" title="更新于 2024-09-01 09:41:00">2024-09-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91/">【算法】</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="动态规划思想"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> <mark>动态规划</mark></h1>
<h1 id="1动态规划理论基础"><a class="markdownIt-Anchor" href="#1动态规划理论基础"></a> 1.动态规划理论基础</h1>
<h2 id="11题目分类大纲"><a class="markdownIt-Anchor" href="#11题目分类大纲"></a> 1.1题目分类大纲</h2>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%80%BB%E7%BB%93%E5%A4%A7%E7%BA%B21.jpg" alt="img" /></p>
<h2 id="12什么是动态规划"><a class="markdownIt-Anchor" href="#12什么是动态规划"></a> 1.2什么是动态规划？</h2>
<ul>
<li>动态规划，英文：Dynamic Programming，简称DP，如果<mark>某一问题有很多重叠子问题</mark>，使用动态规划是最有效的。</li>
<li>所以<mark>动态规划中每一个状态一定是由上一个状态推导出来的</mark>，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的，</li>
</ul>
<h2 id="13背包问题"><a class="markdownIt-Anchor" href="#13背包问题"></a> 1.3背包问题</h2>
<ul>
<li>
<p>例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong><mark>每件物品只能用一次</mark></strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
</li>
<li>
<p>动态规划中dp[j]是由dp[j-weight[i]]推导出来的，然后取max(dp[j], dp[j - weight[i]] + value[i])。</p>
</li>
</ul>
<p>但如果是<mark>贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系</mark>。</p>
<p>所以贪心解决不了动态规划的问题。</p>
<h2 id="14解题步骤"><a class="markdownIt-Anchor" href="#14解题步骤"></a> 1.4解题步骤</h2>
<p>将动态规划问题拆解为如下五部曲：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<h2 id="15动态规划应该如何debug"><a class="markdownIt-Anchor" href="#15动态规划应该如何debug"></a> 1.5动态规划应该如何debug？</h2>
<ul>
<li>
<p><strong>找问题的最好方式就是<mark>把dp数组打印出来</mark>，看看究竟是不是按照自己思路推导的！</strong></p>
</li>
<li>
<p>做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果</p>
</li>
<li>
<p>若出现代码错误，可以先思考以下三个问题：</p>
<ul>
<li>这道题目我举例推导状态转移公式了么？</li>
<li>我打印dp数组的日志了么？</li>
<li>打印出来了dp数组和我想的一样么？</li>
</ul>
</li>
</ul>
<h1 id="2斐波那契数"><a class="markdownIt-Anchor" href="#2斐波那契数"></a> 2.斐波那契数</h1>
<h2 id="21题目"><a class="markdownIt-Anchor" href="#21题目"></a> 2.1题目</h2>
<p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0，F(1) = 1</span><br><span class="line">F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure>
<p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) = F(1) + F(0) = 1 + 0 = 1</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：F(3) = F(2) + F(1) = 1 + 1 = 2</span><br></pre></td></tr></table></figure>
<ul>
<li>示例三：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：3</span><br><span class="line">解释：F(4) = F(3) + F(2) = 2 + 1 = 3</span><br></pre></td></tr></table></figure>
<h2 id="22解法动态规划"><a class="markdownIt-Anchor" href="#22解法动态规划"></a> 2.2解法：动态规划</h2>
<h3 id="221动态规划思路"><a class="markdownIt-Anchor" href="#221动态规划思路"></a> 2.2.1动态规划思路</h3>
<p>动规五部曲：</p>
<h4 id="1确定dp数组以及下标的含义"><a class="markdownIt-Anchor" href="#1确定dp数组以及下标的含义"></a> （1）确定dp数组以及下标的含义</h4>
<p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p>
<h4 id="2确定递推公式"><a class="markdownIt-Anchor" href="#2确定递推公式"></a> （2）确定递推公式</h4>
<p>题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</p>
<h4 id="3dp数组初始化"><a class="markdownIt-Anchor" href="#3dp数组初始化"></a> （3）dp数组初始化</h4>
<p>题目中把如何初始化也直接给我们了，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[0] = 0;</span><br><span class="line">dp[1] = 1;</span><br></pre></td></tr></table></figure>
<h4 id="4确定遍历顺序"><a class="markdownIt-Anchor" href="#4确定遍历顺序"></a> （4）确定遍历顺序</h4>
<p>从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p>
<h4 id="5举例推导dp数组"><a class="markdownIt-Anchor" href="#5举例推导dp数组"></a> （5）举例推导dp数组</h4>
<p>按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p>
<p>0 1 1 2 3 5 8 13 21 34 55</p>
<p>如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。</p>
<h3 id="222代码实现"><a class="markdownIt-Anchor" href="#222代码实现"></a> 2.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> n;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//1、确定dp数组以及下标含义，下标n的元素代表了数字n的斐波那契数</span></span><br><span class="line">       <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">       <span class="comment">//3、dp数组初始化</span></span><br><span class="line">       dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">       dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">       <span class="comment">//4、确定遍历顺序（注意：要到数字n）</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           <span class="comment">//2、确定递归公式</span></span><br><span class="line">           dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[n];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="3爬楼梯"><a class="markdownIt-Anchor" href="#3爬楼梯"></a> 3.爬楼梯</h1>
<h2 id="31题目"><a class="markdownIt-Anchor" href="#31题目"></a> 3.1题目</h2>
<p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure>
<h2 id="32解法动规"><a class="markdownIt-Anchor" href="#32解法动规"></a> 3.2解法：动规</h2>
<h3 id="321动规思路"><a class="markdownIt-Anchor" href="#321动规思路"></a> 3.2.1动规思路</h3>
<p>动规五部曲：</p>
<h4 id="1确定dp数组以及下标的含义-2"><a class="markdownIt-Anchor" href="#1确定dp数组以及下标的含义-2"></a> （1）确定dp数组以及下标的含义</h4>
<p>dp[i]的定义为：第i层楼梯一共有dp[i]种方法</p>
<h4 id="2确定递推公式-2"><a class="markdownIt-Anchor" href="#2确定递推公式-2"></a> （2）确定递推公式</h4>
<p>爬到第i层楼梯一共有两种情况：</p>
<ul>
<li>从第（i-1）层楼梯爬一个台阶</li>
<li>从第（i-2）层楼梯爬二个台阶</li>
</ul>
<p>故此，dp[i]=dp[i-1]+dp[i-2]</p>
<h4 id="3dp数组初始化-2"><a class="markdownIt-Anchor" href="#3dp数组初始化-2"></a> （3）dp数组初始化</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[1] = 1;</span><br><span class="line">dp[2] = 2;</span><br></pre></td></tr></table></figure>
<h4 id="4确定遍历顺序-2"><a class="markdownIt-Anchor" href="#4确定遍历顺序-2"></a> （4）确定遍历顺序</h4>
<p>从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p>
<h4 id="5举例推导dp数组-2"><a class="markdownIt-Anchor" href="#5举例推导dp数组-2"></a> （5）举例推导dp数组</h4>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240501095829088.png" alt="image-20240501095829088" /></p>
<h3 id="322代码实现"><a class="markdownIt-Anchor" href="#322代码实现"></a> 3.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> n;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">       dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">       dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[n];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="4使用最小花费爬楼梯"><a class="markdownIt-Anchor" href="#4使用最小花费爬楼梯"></a> 4.使用最小花费爬楼梯</h1>
<h2 id="41题目"><a class="markdownIt-Anchor" href="#41题目"></a> 4.1题目</h2>
<p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>
<p>你可以<mark>选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯</mark>。</p>
<p>请你计算并返回达到楼梯顶部的最低花费。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [10,15,20]</span><br><span class="line">输出：15</span><br><span class="line">解释：你将从下标为 1 的台阶开始。</span><br><span class="line">- 支付 15 ，向上爬两个台阶，到达楼梯顶部。</span><br><span class="line">总花费为 15 。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [1,100,1,1,1,100,1,1,100,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：你将从下标为 0 的台阶开始。</span><br><span class="line">- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。</span><br><span class="line">- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。</span><br><span class="line">- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。</span><br><span class="line">- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。</span><br><span class="line">- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。</span><br><span class="line">- 支付 1 ，向上爬一个台阶，到达楼梯顶部。</span><br><span class="line">总花费为 6 。</span><br></pre></td></tr></table></figure>
<h2 id="42解法动规"><a class="markdownIt-Anchor" href="#42解法动规"></a> 4.2解法：动规</h2>
<h3 id="421动规思路"><a class="markdownIt-Anchor" href="#421动规思路"></a> 4.2.1动规思路</h3>
<h4 id="1确定dp数组以及下标的含义-3"><a class="markdownIt-Anchor" href="#1确定dp数组以及下标的含义-3"></a> （1）确定dp数组以及下标的含义</h4>
<p>dp[i]的定义为：爬到第i层楼梯的最低花费</p>
<h4 id="2确定递推公式-3"><a class="markdownIt-Anchor" href="#2确定递推公式-3"></a> （2）确定递推公式</h4>
<p>爬到第i层楼梯一共有两种情况：</p>
<ul>
<li>从第（i-1）层楼梯爬一个台阶，花费第[i-1]层楼梯的代价</li>
<li>从第（i-2）层楼梯爬二个台阶，花费第[i-2]层楼梯的代价1</li>
</ul>
<p>故此，dp[i]=Math.min(dp[i-1]+cost[i-1] , dp[i-2]+cost[i-2])</p>
<h4 id="3dp数组初始化-3"><a class="markdownIt-Anchor" href="#3dp数组初始化-3"></a> （3）dp数组初始化</h4>
<p>新题目描述中明确说了 “你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。” 也就是说 到达 第 0 个台阶是不花费的，但从 第0 个台阶 往上跳的话，需要花费 cost[0]。</p>
<p>所以初始化 dp[0] = 0，dp[1] = 0;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[0] = 0;</span><br><span class="line">dp[1] = 0;</span><br></pre></td></tr></table></figure>
<h4 id="4确定遍历顺序-3"><a class="markdownIt-Anchor" href="#4确定遍历顺序-3"></a> （4）确定遍历顺序</h4>
<p>因为是模拟台阶，而且dp[i]由dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以了。</p>
<blockquote>
<p><strong>但是稍稍有点难度的动态规划，其遍历顺序并不容易确定下来</strong>。 例如：01背包，都知道两个for循环，一个for遍历物品嵌套一个for遍历背包容量，那么为什么不是一个for遍历背包容量嵌套一个for遍历物品呢？ 以及在使用一维dp数组的时候遍历背包容量为什么要倒序呢？</p>
</blockquote>
<h4 id="5举例推导dp数组-3"><a class="markdownIt-Anchor" href="#5举例推导dp数组-3"></a> （5）举例推导dp数组</h4>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240501105504714.png" alt="image-20240501105504714" /></p>
<h3 id="422代码实现"><a class="markdownIt-Anchor" href="#422代码实现"></a> 4.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">       <span class="type">int</span> len=cost.length;</span><br><span class="line">       <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[len+<span class="number">1</span>];    <span class="comment">//注意楼顶是数组最后一个元素的下一个</span></span><br><span class="line">       dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">       dp[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=len;i++)&#123;</span><br><span class="line">           dp[i]=Math.min(dp[i-<span class="number">1</span>]+cost[i-<span class="number">1</span>] , dp[i-<span class="number">2</span>]+cost[i-<span class="number">2</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[len];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="5不同路径"><a class="markdownIt-Anchor" href="#5不同路径"></a> 5.不同路径</h1>
<h2 id="51题目"><a class="markdownIt-Anchor" href="#51题目"></a> 5.1题目</h2>
<p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240502094133166.png" alt="image-20240502094133166" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向下</span><br></pre></td></tr></table></figure>
<h2 id="52解法一深度搜索"><a class="markdownIt-Anchor" href="#52解法一深度搜索"></a> 5.2解法一：深度搜索</h2>
<h3 id="521深度搜索思路"><a class="markdownIt-Anchor" href="#521深度搜索思路"></a> 5.2.1深度搜索思路</h3>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240502094118662.png" alt="image-20240502094118662" /></p>
<h3 id="522代码实现"><a class="markdownIt-Anchor" href="#522代码实现"></a> 5.2.2代码实现</h3>
<ul>
<li>最终通过 （38/63个测试用例）</li>
</ul>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240502094430701.png" alt="image-20240502094430701" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> dfs(<span class="number">1</span>,<span class="number">1</span>,m,n);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">       <span class="comment">//1、超过边界</span></span><br><span class="line">       <span class="keyword">if</span>(i&gt;m||j&gt;n)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2、终点</span></span><br><span class="line">       <span class="keyword">if</span>(i==m&amp;&amp;j==n)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3、遍历</span></span><br><span class="line">       <span class="keyword">return</span> dfs(i+<span class="number">1</span>,j,m,n)+dfs(i,j+<span class="number">1</span>,m,n);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="53解法二动规"><a class="markdownIt-Anchor" href="#53解法二动规"></a> 5.3解法二：动规</h2>
<h3 id="531动规思路"><a class="markdownIt-Anchor" href="#531动规思路"></a> 5.3.1动规思路</h3>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240502094509490.png" alt="image-20240502094509490" /></p>
<h3 id="532代码实现"><a class="markdownIt-Anchor" href="#532代码实现"></a> 5.3.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">       <span class="comment">//3、初始化</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">           dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">           dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//4、遍历顺序</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">               <span class="comment">//2、递推公式</span></span><br><span class="line">               dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="6不同路径"><a class="markdownIt-Anchor" href="#6不同路径"></a> 6.不同路径||</h1>
<h2 id="61题目"><a class="markdownIt-Anchor" href="#61题目"></a> 6.1题目</h2>
<p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p><mark>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示</mark>。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]</span><br><span class="line">输出：2</span><br><span class="line">解释：3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacleGrid = [[0,1],[0,0]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<h2 id="62解法动规"><a class="markdownIt-Anchor" href="#62解法动规"></a> 6.2解法：动规</h2>
<h3 id="621动规思路"><a class="markdownIt-Anchor" href="#621动规思路"></a> 6.2.1动规思路</h3>
<p>机器人从（0,0）位置开始后，到达（m-1,n-1）终点</p>
<h4 id="1dp数组以及下标含义"><a class="markdownIt-Anchor" href="#1dp数组以及下标含义"></a> （1）dp数组以及下标含义</h4>
<p>dp(i)(j)：从（0,0）出发，到（i,j）有dp(i)(j)条不同路径</p>
<h4 id="2递推公式"><a class="markdownIt-Anchor" href="#2递推公式"></a> （2）递推公式</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(obstacleGrid[i][j]==0)&#123;</span><br><span class="line">	dp[i][j]=dp[i-1][j]+dp[i][j-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3dp数组初始化-4"><a class="markdownIt-Anchor" href="#3dp数组初始化-4"></a> （3）dp数组初始化</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) </span><br><span class="line">	dp[i][0] = 1;</span><br><span class="line">for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; j++) </span><br><span class="line">	dp[0][j] = 1;</span><br></pre></td></tr></table></figure>
<h4 id="4确定遍历顺序-4"><a class="markdownIt-Anchor" href="#4确定遍历顺序-4"></a> （4）确定遍历顺序</h4>
<p>从左到右</p>
<h4 id="5举例推到dp数组"><a class="markdownIt-Anchor" href="#5举例推到dp数组"></a> （5）举例推到dp数组</h4>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240502100535260.png" alt="image-20240502100535260" /></p>
<h3 id="622代码实现"><a class="markdownIt-Anchor" href="#622代码实现"></a> 6.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">       <span class="type">int</span> m=obstacleGrid.length;</span><br><span class="line">       <span class="type">int</span> n=obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">       <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">       <span class="comment">//3、初始化</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m &amp;&amp; obstacleGrid[i][<span class="number">0</span>]==<span class="number">0</span>;i++)&#123;</span><br><span class="line">           dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n &amp;&amp; obstacleGrid[<span class="number">0</span>][j]==<span class="number">0</span>;j++)&#123;</span><br><span class="line">           dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//4、遍历顺序</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">               <span class="comment">//2、递推公式</span></span><br><span class="line">               <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                   dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="7整数拆分"><a class="markdownIt-Anchor" href="#7整数拆分"></a> 7.整数拆分</h1>
<h2 id="71题目"><a class="markdownIt-Anchor" href="#71题目"></a> 7.1题目</h2>
<p>给定一个正整数 <code>n</code> ，将其拆分为 <code>k</code> 个 <strong>正整数</strong> 的和（ <code>k &gt;= 2</code> ），并使这些整数的乘积最大化。</p>
<p>返回 <em>你可以获得的最大乘积</em> 。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1。</span><br></pre></td></tr></table></figure>
<h2 id="72解法动规"><a class="markdownIt-Anchor" href="#72解法动规"></a> 7.2解法：动规</h2>
<h3 id="721动规思路"><a class="markdownIt-Anchor" href="#721动规思路"></a> 7.2.1动规思路</h3>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240502105202151.png" alt="image-20240502105202151" /></p>
<h3 id="722代码实现"><a class="markdownIt-Anchor" href="#722代码实现"></a> 7.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">       dp[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           <span class="comment">//j从1开始遍历</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">               dp[i]=Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[n];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="8不同的二叉搜索树"><a class="markdownIt-Anchor" href="#8不同的二叉搜索树"></a> 8.不同的二叉搜索树</h1>
<h2 id="81题目"><a class="markdownIt-Anchor" href="#81题目"></a> 8.1题目</h2>
<p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<h2 id="82解法动规"><a class="markdownIt-Anchor" href="#82解法动规"></a> 8.2解法：动规</h2>
<h3 id="821动规思路"><a class="markdownIt-Anchor" href="#821动规思路"></a> 8.2.1动规思路</h3>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240502113211747.png" alt="image-20240502113211747" /></p>
<h3 id="822代码实现"><a class="markdownIt-Anchor" href="#822代码实现"></a> 8.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">       dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">               dp[i]+=(dp[j]*dp[i-j-<span class="number">1</span>]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[n];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="90-1背包理论基础"><a class="markdownIt-Anchor" href="#90-1背包理论基础"></a> 9.0-1背包理论基础</h1>
<h2 id="91背包问题分类"><a class="markdownIt-Anchor" href="#91背包问题分类"></a> 9.1背包问题分类</h2>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240503103041491.png" alt="image-20240503103041491" /></p>
<h2 id="92-01背包二维数组"><a class="markdownIt-Anchor" href="#92-01背包二维数组"></a> 9.2 01背包（二维数组）</h2>
<h3 id="921问题"><a class="markdownIt-Anchor" href="#921问题"></a> 9.2.1问题</h3>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240503103131607.png" alt="image-20240503103131607" /></p>
<h3 id="922动规思路"><a class="markdownIt-Anchor" href="#922动规思路"></a> 9.2.2动规思路</h3>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240503103203773.png" alt="image-20240503103203773" /></p>
<ul>
<li>第五步：举例推导dp数组</li>
</ul>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240503103230459.png" alt="image-20240503103230459" /></p>
<h2 id="93变换题目"><a class="markdownIt-Anchor" href="#93变换题目"></a> 9.3变换题目</h2>
<h3 id="931题目"><a class="markdownIt-Anchor" href="#931题目"></a> 9.3.1题目</h3>
<p>题目描述</p>
<blockquote>
<p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的空间，并且具有不同的价值。</p>
<p>小明的行李空间为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料只能选择一次，并且只有选与不选两种选择，不能进行切割。</p>
</blockquote>
<p>输入描述</p>
<blockquote>
<p>第一行包含两个正整数，第一个整数 M 代表研究材料的种类，第二个正整数 N，代表小明的行李空间。</p>
<p>第二行包含 M 个正整数，代表每种研究材料的所占空间。</p>
<p>第三行包含 M 个正整数，代表每种研究材料的价值。</p>
</blockquote>
<p>输出描述</p>
<blockquote>
<p>输出一个整数，代表小明能够携带的研究材料的最大价值。</p>
</blockquote>
<ul>
<li>示例一：</li>
</ul>
<p>输入示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6 1</span><br><span class="line">2 2 3 1 5 2</span><br><span class="line">2 3 1 5 4 3</span><br></pre></td></tr></table></figure>
<p>输出示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<p>提示信息</p>
<blockquote>
<p>小明能够携带 6 种研究材料，但是行李空间只有 1，而占用空间为 1 的研究材料价值为 5，所以最终答案输出 5。</p>
<p>数据范围：<br />
1 &lt;= N &lt;= 5000<br />
1 &lt;= M &lt;= 5000<br />
研究材料占用空间和价值都小于等于 1000</p>
</blockquote>
<h3 id="932代码实现"><a class="markdownIt-Anchor" href="#932代码实现"></a> 9.3.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 背包容量 N</span></span><br><span class="line">        <span class="comment">// 物品种类 M</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] values = <span class="keyword">new</span> <span class="title class_">int</span>[M];</span><br><span class="line">        <span class="type">int</span>[] weights = <span class="keyword">new</span> <span class="title class_">int</span>[M];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; M;i++) &#123;</span><br><span class="line">            weights[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; M;i++) &#123;</span><br><span class="line">            values[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[M][N+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> weights[<span class="number">0</span>]; i &lt;= N; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = values[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; M; i++) &#123;</span><br><span class="line">            <span class="comment">// 后背包</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(weights[i] &gt; j) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-weights[i]] + values[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[M-<span class="number">1</span>][N]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="10分割等和子集"><a class="markdownIt-Anchor" href="#10分割等和子集"></a> 10.分割等和子集</h1>
<h2 id="101题目"><a class="markdownIt-Anchor" href="#101题目"></a> 10.1题目</h2>
<p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,5,11,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：数组可以分割成 [1, 5, 5] 和 [11] 。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,5]</span><br><span class="line">输出：false</span><br><span class="line">解释：数组不能分割成两个元素和相等的子集。</span><br></pre></td></tr></table></figure>
<h2 id="102解法动规"><a class="markdownIt-Anchor" href="#102解法动规"></a> 10.2解法：动规</h2>
<h3 id="1021动规思路"><a class="markdownIt-Anchor" href="#1021动规思路"></a> 10.2.1动规思路</h3>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240503112541561.png" alt="image-20240503112541561" /></p>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240503112606642.png" alt="image-20240503112606642" /></p>
<h3 id="1022代码实现"><a class="markdownIt-Anchor" href="#1022代码实现"></a> 10.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="type">int</span> len=nums.length;    <span class="comment">//物品个数</span></span><br><span class="line">       <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">       <span class="comment">//1、计算target</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">           sum+=num;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2、判断是否为奇数，若为奇数，则直接返回false</span></span><br><span class="line">       <span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> target=sum/<span class="number">2</span>;      <span class="comment">//目标总和，也为背包容量</span></span><br><span class="line">       <span class="comment">//3、dp数组</span></span><br><span class="line">       <span class="type">boolean</span>[][] dp=<span class="keyword">new</span> <span class="title class_">boolean</span>[len][target+<span class="number">1</span>];  </span><br><span class="line">       <span class="comment">//4、初始化：第一个数的value能让容积为它自己的背包装满</span></span><br><span class="line">       <span class="keyword">if</span>(nums[<span class="number">0</span>]&lt;=target)&#123;</span><br><span class="line">           dp[<span class="number">0</span>][nums[<span class="number">0</span>]]=<span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//5、遍历物品以及背包重量</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=target;j++)&#123;</span><br><span class="line">               <span class="comment">//5.1、先不加上该物品</span></span><br><span class="line">               dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">               <span class="comment">//5.2、判断该物品重量恰好为背包容量</span></span><br><span class="line">               <span class="keyword">if</span>(nums[i]==j)&#123;</span><br><span class="line">                   dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//5.3、若该数小于j，则更新（不加上该数/加上该数）</span></span><br><span class="line">               <span class="keyword">if</span>(nums[i]&lt;j)&#123;</span><br><span class="line">                   dp[i][j]=dp[i-<span class="number">1</span>][j] || dp[i-<span class="number">1</span>][j-nums[i]];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[len-<span class="number">1</span>][target];</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="11最后一块石头的重量"><a class="markdownIt-Anchor" href="#11最后一块石头的重量"></a> 11.最后一块石头的重量||</h1>
<h2 id="111题目"><a class="markdownIt-Anchor" href="#111题目"></a> 11.1题目</h2>
<p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p>
<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>
</ul>
<p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [2,7,4,1,8,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，</span><br><span class="line">组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，</span><br><span class="line">组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，</span><br><span class="line">组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [31,26,33,21,40]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<h2 id="112解法动规"><a class="markdownIt-Anchor" href="#112解法动规"></a> 11.2解法：动规</h2>
<h3 id="1121动规思路"><a class="markdownIt-Anchor" href="#1121动规思路"></a> 11.2.1动规思路</h3>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240503160425032.png" alt="image-20240503160425032" /></p>
<h3 id="1122代码实现"><a class="markdownIt-Anchor" href="#1122代码实现"></a> 11.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">       <span class="comment">//1、计算出sum和target</span></span><br><span class="line">       <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> stone:stones)&#123;</span><br><span class="line">           sum+=stone;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> target=sum/<span class="number">2</span>;</span><br><span class="line">       <span class="type">int</span> len=stones.length;</span><br><span class="line">       <span class="comment">//2、dp数组</span></span><br><span class="line">       <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[len][target+<span class="number">1</span>];</span><br><span class="line">       <span class="comment">//3、初始化</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=target;j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(stones[<span class="number">0</span>]&lt;=j)&#123;</span><br><span class="line">               dp[<span class="number">0</span>][j]=stones[<span class="number">0</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//4、遍历物品和背包重量</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=target;j++)&#123;</span><br><span class="line">               <span class="comment">//4.1、先考虑不加上该物品的情况</span></span><br><span class="line">               dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">               <span class="comment">//4.2、该物品的重量刚刚好为背包重量</span></span><br><span class="line">               <span class="keyword">if</span>(stones[i]==j)&#123;</span><br><span class="line">                   dp[i][j]=j;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//4.3、再确定不加该物品、加该物品</span></span><br><span class="line">               <span class="keyword">if</span>(stones[i]&lt;j)&#123;</span><br><span class="line">                   dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-stones[i]]+stones[i]);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//5、返回结果</span></span><br><span class="line">       <span class="keyword">return</span> sum-dp[len-<span class="number">1</span>][target]-dp[len-<span class="number">1</span>][target];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="12目标和"><a class="markdownIt-Anchor" href="#12目标和"></a> 12.目标和</h1>
<h2 id="121题目"><a class="markdownIt-Anchor" href="#121题目"></a> 12.1题目</h2>
<p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>
<ul>
<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>'+'</code> ，在 <code>1</code> 之前添加 <code>'-'</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li>
</ul>
<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,1,1], target = 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有 5 种方法让最终目标和为 3 。</span><br><span class="line">-1 + 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 = 3</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], target = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<h2 id="122解法动规"><a class="markdownIt-Anchor" href="#122解法动规"></a> 12.2解法：动规</h2>
<h3 id="1221动规思路"><a class="markdownIt-Anchor" href="#1221动规思路"></a> 12.2.1动规思路</h3>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240504100732565.png" alt="image-20240504100732565" /></p>
<h3 id="1222代码实现"><a class="markdownIt-Anchor" href="#1222代码实现"></a> 12.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">       <span class="comment">//1、计算sum、left</span></span><br><span class="line">       <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">           sum+=num;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//1.2、保证sum + target一定是大于等于零的，进而确保left也是大于等于零</span></span><br><span class="line">       <span class="keyword">if</span>(sum &lt; Math.abs(target))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//1.3、如果所求的left数组和为小数，则作为整数数组的nums里的任何元素自然是没有办法凑出这个小数的</span></span><br><span class="line">       <span class="keyword">if</span>((sum+target)%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> left=(sum+target)/<span class="number">2</span>;</span><br><span class="line">       <span class="type">int</span> len=nums.length;</span><br><span class="line">       <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[len][left+<span class="number">1</span>];</span><br><span class="line">       <span class="comment">//2、初始化dp数组</span></span><br><span class="line">       <span class="comment">//2.1、最上面一列</span></span><br><span class="line">       <span class="keyword">if</span>(nums[<span class="number">0</span>]&lt;=left)&#123;</span><br><span class="line">           dp[<span class="number">0</span>][nums[<span class="number">0</span>]]=<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2.2、最左边一列</span></span><br><span class="line">       <span class="type">int</span> zeroNums=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">               zeroNums++;</span><br><span class="line">           &#125;</span><br><span class="line">           dp[i][<span class="number">0</span>]=(<span class="type">int</span>)Math.pow(<span class="number">2</span>,zeroNums);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3、遍历dp</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=left;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[i]&gt;j)&#123;</span><br><span class="line">                   dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i-<span class="number">1</span>][j-nums[i]];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[len-<span class="number">1</span>][left];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="13一和零"><a class="markdownIt-Anchor" href="#13一和零"></a> 13.一和零</h1>
<h2 id="131题目"><a class="markdownIt-Anchor" href="#131题目"></a> 13.1题目</h2>
<p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p>
<p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p>
<p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m = 5, n = 3</span><br><span class="line">输出：4</span><br><span class="line">解释：最多有 5 个 0 和 3 个 1 的最大子集是 &#123;&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;&#125; ，因此答案是 4 。</span><br><span class="line">其他满足题意但较小的子集包括 &#123;&quot;0001&quot;,&quot;1&quot;&#125; 和 &#123;&quot;10&quot;,&quot;1&quot;,&quot;0&quot;&#125; 。&#123;&quot;111001&quot;&#125; 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [&quot;10&quot;, &quot;0&quot;, &quot;1&quot;], m = 1, n = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：最大的子集是 &#123;&quot;0&quot;, &quot;1&quot;&#125; ，所以答案是 2 。</span><br></pre></td></tr></table></figure>
<h2 id="132解法动规"><a class="markdownIt-Anchor" href="#132解法动规"></a> 13.2解法：动规</h2>
<h3 id="1321动规思路"><a class="markdownIt-Anchor" href="#1321动规思路"></a> 13.2.1动规思路</h3>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240504143955825.png" alt="image-20240504143955825" /></p>
<h3 id="1322代码实现"><a class="markdownIt-Anchor" href="#1322代码实现"></a> 13.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="comment">//1、dp一维数组</span></span><br><span class="line">       <span class="comment">//dp[i][j]：字符串数组中，最多有i个0和j个1的最大子集个数为dp[i][j]</span></span><br><span class="line">       <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];   </span><br><span class="line">       <span class="type">int</span> zeroNum=<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> oneNum=<span class="number">0</span>;</span><br><span class="line">       <span class="comment">//2、遍历物品：字符串（从前往后）</span></span><br><span class="line">       <span class="keyword">for</span>(String str:strs)&#123;</span><br><span class="line">           zeroNum=<span class="number">0</span>;</span><br><span class="line">           oneNum=<span class="number">0</span>;</span><br><span class="line">           <span class="comment">//2.1、统计0和1的字符</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">char</span> ch:str.toCharArray())&#123;</span><br><span class="line">               <span class="keyword">if</span>(ch==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                   zeroNum++;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   oneNum++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//2.2、遍历背包容量（从后往前）</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=zeroNum;i--)&#123;</span><br><span class="line">               <span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;=oneNum;j--)&#123;</span><br><span class="line">                   dp[i][j]=Math.max(dp[i][j],dp[i-zeroNum][j-oneNum]+<span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[m][n];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="140-1背包例题小结"><a class="markdownIt-Anchor" href="#140-1背包例题小结"></a> 14.0-1背包例题小结</h1>
<ul>
<li>纯 0 - 1 背包：求 给定背包容量 <mark>装满背包 的最大价值是多少</mark>。</li>
<li>10.分割等和子集：求 给定背包容量，<mark>能不能装满这个背包</mark>。</li>
<li>11.最后一块石头的重量：求 给定背包容量，尽可能装，<mark>最多能装多少</mark></li>
<li>12.目标和：求 给定背包容量，<mark>装满背包有多少种方法</mark>。</li>
<li>13.一和零：求 给定背包容量，<mark>装满背包最多有多少个物品</mark>。</li>
</ul>
<h1 id="15完全背包理论基础"><a class="markdownIt-Anchor" href="#15完全背包理论基础"></a> 15.完全背包理论基础</h1>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240518160915259.png" alt="image-20240518160915259" /></p>
<h1 id="16零钱兑换"><a class="markdownIt-Anchor" href="#16零钱兑换"></a> 16.零钱兑换||</h1>
<h2 id="161题目"><a class="markdownIt-Anchor" href="#161题目"></a> 16.1题目</h2>
<p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p>
<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p>
<p>假设每一种面额的硬币有无限个。</p>
<p>题目数据保证结果符合 32 位带符号整数。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = 5, coins = [1, 2, 5]</span><br><span class="line">输出：4</span><br><span class="line">解释：有四种方式可以凑成总金额：</span><br><span class="line">5=5</span><br><span class="line">5=2+2+1</span><br><span class="line">5=2+1+1+1</span><br><span class="line">5=1+1+1+1+1</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = 3, coins = [2]</span><br><span class="line">输出：0</span><br><span class="line">解释：只用面额 2 的硬币不能凑成总金额 3 。</span><br></pre></td></tr></table></figure>
<h2 id="162解法动规"><a class="markdownIt-Anchor" href="#162解法动规"></a> 16.2解法：动规</h2>
<h3 id="1621动规思路"><a class="markdownIt-Anchor" href="#1621动规思路"></a> 16.2.1动规思路</h3>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240518161047012.png" alt="image-20240518161047012" /></p>
<h3 id="1622代码实现"><a class="markdownIt-Anchor" href="#1622代码实现"></a> 16.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">       <span class="type">int</span> len=coins.length;</span><br><span class="line">       <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">       dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=coins[i];j&lt;=amount;j++)&#123;</span><br><span class="line">               dp[j]+=dp[j-coins[i]];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[amount];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="17组合总和iv"><a class="markdownIt-Anchor" href="#17组合总和iv"></a> 17.组合总和IV</h1>
<h2 id="171题目"><a class="markdownIt-Anchor" href="#171题目"></a> 17.1题目</h2>
<p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3], target = 4</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [9], target = 3</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<h2 id="172解法动规"><a class="markdownIt-Anchor" href="#172解法动规"></a> 17.2解法：动规</h2>
<h3 id="1721动规思路"><a class="markdownIt-Anchor" href="#1721动规思路"></a> 17.2.1动规思路</h3>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240608091338353.png" alt="image-20240608091338353" /></p>
<h3 id="1722代码实现"><a class="markdownIt-Anchor" href="#1722代码实现"></a> 17.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[target+<span class="number">1</span>];</span><br><span class="line">       dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=target;j++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(j&gt;=nums[i])&#123;</span><br><span class="line">                   dp[j]+=dp[j-nums[i]];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[target];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="18爬楼梯进阶版"><a class="markdownIt-Anchor" href="#18爬楼梯进阶版"></a> 18.爬楼梯（进阶版）</h1>
<h2 id="181题目"><a class="markdownIt-Anchor" href="#181题目"></a> 18.1题目</h2>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬至多m (1 &lt;= m &lt; n)个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p>输入描述：输入共一行，包含两个正整数，分别表示n, m</p>
<p>输出描述：输出一个整数，表示爬到楼顶的方法数。</p>
<p>输入示例：3 2</p>
<p>输出示例：3</p>
<p>提示：</p>
<p>当 m = 2，n = 3 时，n = 3 这表示一共有三个台阶，m = 2 代表你每次可以爬一个台阶或者两个台阶。</p>
<p>此时你有三种方法可以爬到楼顶。</p>
<ul>
<li>1 阶 + 1 阶 + 1 阶段</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ul>
<h2 id="182解法动规"><a class="markdownIt-Anchor" href="#182解法动规"></a> 18.2解法：动规</h2>
<h3 id="1821动规思路"><a class="markdownIt-Anchor" href="#1821动规思路"></a> 18.2.1动规思路</h3>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240608095529726.png" alt="image-20240608095529726" /></p>
<h3 id="1822代码实现"><a class="markdownIt-Anchor" href="#1822代码实现"></a> 18.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> m, n;</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNextInt()) &#123;</span><br><span class="line">            <span class="comment">// 从键盘输入参数，中间用空格隔开</span></span><br><span class="line">            n = sc.nextInt();</span><br><span class="line">            m = sc.nextInt();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 求排列问题，先遍历背包再遍历物品</span></span><br><span class="line">            <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j&gt;=i)&#123;</span><br><span class="line">                         dp[j] += dp[j - i];</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(dp[n]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="19零钱兑换"><a class="markdownIt-Anchor" href="#19零钱兑换"></a> 19.零钱兑换</h1>
<h2 id="191题目"><a class="markdownIt-Anchor" href="#191题目"></a> 19.1题目</h2>
<p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [2], amount = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>
<h2 id="192解法动规"><a class="markdownIt-Anchor" href="#192解法动规"></a> 19.2解法：动规</h2>
<h3 id="1921动规思路"><a class="markdownIt-Anchor" href="#1921动规思路"></a> 19.2.1动规思路</h3>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240608101624896.png" alt="image-20240608101624896" /></p>
<h3 id="1922代码实现"><a class="markdownIt-Anchor" href="#1922代码实现"></a> 19.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">       dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=amount;i++)&#123;</span><br><span class="line">           dp[i]=Integer.MAX_VALUE;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;coins.length;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=coins[i];j&lt;=amount;j++)&#123;</span><br><span class="line">               <span class="comment">//注意：dp[j-coins[i]]要有意义</span></span><br><span class="line">               <span class="keyword">if</span>( dp[j-coins[i]]!= Integer.MAX_VALUE)&#123;</span><br><span class="line">                   dp[j]=Math.min(dp[j-coins[i]]+<span class="number">1</span>,dp[j]);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[amount]==Integer.MAX_VALUE? -<span class="number">1</span>:dp[amount];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="20完全平方数"><a class="markdownIt-Anchor" href="#20完全平方数"></a> 20.完全平方数</h1>
<h2 id="201题目"><a class="markdownIt-Anchor" href="#201题目"></a> 20.1题目</h2>
<p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p>
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 = 4 + 4 + 4</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 13</span><br><span class="line">输出：2</span><br><span class="line">解释：13 = 4 + 9</span><br></pre></td></tr></table></figure>
<h2 id="202解法"><a class="markdownIt-Anchor" href="#202解法"></a> 20.2解法</h2>
<h3 id="2021解法思路动规"><a class="markdownIt-Anchor" href="#2021解法思路动规"></a> 20.2.1解法思路：动规</h3>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240608104202769.png" alt="image-20240608104202769" /></p>
<h3 id="2022代码实现"><a class="markdownIt-Anchor" href="#2022代码实现"></a> 20.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">       <span class="type">int</span> max=Integer.MAX_VALUE;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           dp[i]=max;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//先遍历背包</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=j;i++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(j&gt;=i*i)&#123;</span><br><span class="line">                   dp[j]=Math.min(dp[j],dp[j-i*i]+<span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[n];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="21单词拆分"><a class="markdownIt-Anchor" href="#21单词拆分"></a> 21.单词拆分</h1>
<h2 id="211题目"><a class="markdownIt-Anchor" href="#211题目"></a> 21.1题目</h2>
<p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code> 则返回 <code>true</code>。</p>
<p>**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。</span><br><span class="line">     注意，你可以重复使用字典中的单词</span><br></pre></td></tr></table></figure>
<h2 id="212解法动规"><a class="markdownIt-Anchor" href="#212解法动规"></a> 21.2解法：动规</h2>
<h3 id="2121动规思路"><a class="markdownIt-Anchor" href="#2121动规思路"></a> 21.2.1动规思路</h3>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240609094110964.png" alt="image-20240609094110964" /></p>
<h3 id="2122代码实现"><a class="markdownIt-Anchor" href="#2122代码实现"></a> 21.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">       <span class="type">boolean</span>[] dp=<span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">       dp[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">       <span class="comment">//先遍历背包</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=s.length();j++)&#123;</span><br><span class="line">           <span class="comment">//再遍历物品</span></span><br><span class="line">           <span class="keyword">for</span>(String word:wordDict)&#123;</span><br><span class="line">               <span class="type">int</span> len=word.length();</span><br><span class="line">               <span class="keyword">if</span>( j&gt;=len &amp;&amp; dp[j-len] &amp;&amp; word.equals(s.substring(j-len,j)))&#123;</span><br><span class="line">                   <span class="comment">//若dp[i]为true且[i,j]出现在字典中</span></span><br><span class="line">                   dp[j]=<span class="literal">true</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="22打家劫舍"><a class="markdownIt-Anchor" href="#22打家劫舍"></a> 22.打家劫舍</h1>
<h2 id="221题目"><a class="markdownIt-Anchor" href="#221题目"></a> 22.1题目</h2>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure>
<h2 id="222解法动规"><a class="markdownIt-Anchor" href="#222解法动规"></a> 22.2解法：动规</h2>
<h3 id="2221动规思路"><a class="markdownIt-Anchor" href="#2221动规思路"></a> 22.2.1动规思路</h3>
<ol>
<li>确定dp数组以及下标：dp[i]：下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]</li>
<li>确定递推公式：偷/不偷：dp[i]=Math.max(nums[i]+dp[i-2]，dp[i-1])</li>
<li>dp数组初始化：dp[0]=nums[0]；dp[1]为nums[0]、nums[1]两者的最大者</li>
<li>确定遍历顺序：从前往后</li>
</ol>
<h3 id="2222代码实现"><a class="markdownIt-Anchor" href="#2222代码实现"></a> 22.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">       dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">       dp[<span class="number">1</span>]=nums[<span class="number">0</span>]&gt;nums[<span class="number">1</span>]?nums[<span class="number">0</span>]:nums[<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="comment">//取、不取</span></span><br><span class="line">           dp[i]=Math.max(nums[i]+dp[i-<span class="number">2</span>],dp[i-<span class="number">1</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="23打家劫舍"><a class="markdownIt-Anchor" href="#23打家劫舍"></a> 23.打家劫舍||</h1>
<h2 id="231题目"><a class="markdownIt-Anchor" href="#231题目"></a> 23.1题目</h2>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure>
<h2 id="232解法动规"><a class="markdownIt-Anchor" href="#232解法动规"></a> 23.2解法：动规</h2>
<h3 id="2321动规思路"><a class="markdownIt-Anchor" href="#2321动规思路"></a> 23.2.1动规思路</h3>
<ol>
<li>
<p>与上一题：打家劫舍不同，该题房屋是呈环状的，即第一个房屋和最后一个房屋是连在一起的</p>
</li>
<li>
<p>情况一：取第一个房屋：</p>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240609200503083.png" alt="image-20240609200503083" /></p>
</li>
<li>
<p>情况二：取最后一个房屋：、</p>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240609200528695.png" alt="image-20240609200528695" /></p>
</li>
</ol>
<h3 id="2322代码实现"><a class="markdownIt-Anchor" href="#2322代码实现"></a> 23.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Math.max(robRange(nums,<span class="number">0</span>,nums.length-<span class="number">2</span>),robRange(nums,<span class="number">1</span>,nums.length-<span class="number">1</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//寻找区间[start,end]的最大金额值</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">robRange</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">           <span class="keyword">return</span> nums[start];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">       dp[start]=nums[start];</span><br><span class="line">       dp[start+<span class="number">1</span>]=Math.max(nums[start],nums[start+<span class="number">1</span>]);</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=start+<span class="number">2</span>;i&lt;=end;i++)&#123;</span><br><span class="line">           dp[i]=Math.max(nums[i]+dp[i-<span class="number">2</span>],dp[i-<span class="number">1</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[end];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="24打家劫舍"><a class="markdownIt-Anchor" href="#24打家劫舍"></a> 24.打家劫舍|||</h1>
<h2 id="241题目"><a class="markdownIt-Anchor" href="#241题目"></a> 24.1题目</h2>
<p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root</code> 。</p>
<p>除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警。</p>
<p>给定二叉树的 <code>root</code> 。返回 <em><strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额</em> 。</p>
<ul>
<li>示例一：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,2,3,null,3,null,1]</span><br><span class="line">输出: 7 </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg" alt="img" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,4,5,1,3,null,1]</span><br><span class="line">输出: 9</span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9</span><br></pre></td></tr></table></figure>
<h2 id="242解法状态动规"><a class="markdownIt-Anchor" href="#242解法状态动规"></a> 24.2解法：状态动规</h2>
<h3 id="2421动规思路"><a class="markdownIt-Anchor" href="#2421动规思路"></a> 24.2.1动规思路</h3>
<ol>
<li>
<p>思路：使用一个长度为2的数组，记录当前节点偷与不偷所得到的的最大金钱</p>
</li>
<li>
<p>确定递归函数的参数和返回值，返回的数组即dp数组，dp数组（dp table）以及下标的含义：<mark><strong>下标为0记录不偷该节点所得到的的最大金钱</strong>，<strong>下标为1记录偷该节点所得到的的最大金钱</strong></mark>。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] robTree(TreeNode cur)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>确定终止条件：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cur==<span class="literal">null</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>确定遍历顺序：通过递归左节点，得到左节点偷与不偷的金钱；通过递归右节点，得到右节点偷与不偷的金钱。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] left=robTree(cur.left);</span><br><span class="line">int[] right=robTree(cur.right);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>确定单层递归逻辑，对于该节点：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//偷val，不偷左右孩子</span><br><span class="line">int val1=cur.val+left[0]+right[0];</span><br><span class="line">//不偷val，偷左右孩子（都要，针对左右孩子，取最大值）</span><br><span class="line">int val2=Math.max(left[0],left[1])+max(right[0],right[1]);</span><br><span class="line"></span><br><span class="line">return new int[]&#123;val1,val2&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2422代码实现"><a class="markdownIt-Anchor" href="#2422代码实现"></a> 24.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span>[] res=robTree(root);</span><br><span class="line">       <span class="keyword">return</span> Math.max(res[<span class="number">0</span>],res[<span class="number">1</span>]);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span>[] robTree(TreeNode cur)&#123;</span><br><span class="line">       <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">       <span class="keyword">if</span>(cur==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> dp;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span>[] left=robTree(cur.left);</span><br><span class="line">       <span class="type">int</span>[] right=robTree(cur.right);</span><br><span class="line">       <span class="comment">//不偷cur</span></span><br><span class="line">       dp[<span class="number">0</span>]=Math.max(left[<span class="number">0</span>],left[<span class="number">1</span>])+Math.max(right[<span class="number">0</span>],right[<span class="number">1</span>]);</span><br><span class="line">       <span class="comment">//偷cur</span></span><br><span class="line">       dp[<span class="number">1</span>]=cur.val+left[<span class="number">0</span>]+right[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">return</span> dp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="25买卖股票的最佳时机"><a class="markdownIt-Anchor" href="#25买卖股票的最佳时机"></a> 25.买卖股票的最佳时机</h1>
<h2 id="251题目"><a class="markdownIt-Anchor" href="#251题目"></a> 25.1题目</h2>
<p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>
<h2 id="252解法一贪心"><a class="markdownIt-Anchor" href="#252解法一贪心"></a> 25.2解法一：贪心</h2>
<h3 id="2521贪心思路"><a class="markdownIt-Anchor" href="#2521贪心思路"></a> 25.2.1贪心思路</h3>
<ol>
<li>题目要求求能获取的最大利润</li>
<li>遍历整个数组，寻找左边最小值、右边最大值，相减即为最大利润</li>
</ol>
<h3 id="2522代码实现"><a class="markdownIt-Anchor" href="#2522代码实现"></a> 25.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">       <span class="type">int</span> low=Integer.MAX_VALUE;</span><br><span class="line">       <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">           <span class="comment">//左取最小数</span></span><br><span class="line">           low=Math.min(low,prices[i]);</span><br><span class="line">           <span class="comment">//右取最大数</span></span><br><span class="line">           res=Math.max(res,prices[i]-low);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="253解法二动规"><a class="markdownIt-Anchor" href="#253解法二动规"></a> 25.3解法二：动规</h2>
<h3 id="2531动规思路"><a class="markdownIt-Anchor" href="#2531动规思路"></a> 25.3.1动规思路</h3>
<ol>
<li>
<p>确定dp数组以及下标含义：</p>
<p><mark>dp(i)(0)表示第i天持有股票时，所得最多的现金</mark></p>
<p><mark>dp(i)(1)表示第i天不持有股票时，所得最多的现金</mark></p>
</li>
<li>
<p>确定递推公式：</p>
<p><mark>注意：因为一只股票只能买卖一次，所以今天买入股票所得的金额必须为-prices[i]</mark></p>
<p>前一天持有股票时所得最多的现金/今天持有股票：dp(i)(0)=Math.max（ dp(i-1)(0) ，-prices[i] ）</p>
<p>前一天不持有股票/今天卖股票：dp(i)(1)=Math.max（ dp(i-1)(1)，dp(i-1)(0)+prices[i] ）</p>
</li>
<li>
<p>dp数组初始化：dp(0)(0)=-prices[0]，dp(0)(1)=0</p>
</li>
<li>
<p>确定遍历顺序：从前往后</p>
</li>
</ol>
<h3 id="2532代码实现"><a class="markdownIt-Anchor" href="#2532代码实现"></a> 25.3.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(prices.length==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">       dp[<span class="number">0</span>][<span class="number">0</span>]-=prices[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">           dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],-prices[i]);</span><br><span class="line">           dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="26买卖股票的最佳时机"><a class="markdownIt-Anchor" href="#26买卖股票的最佳时机"></a> 26.买卖股票的最佳时机||</h1>
<h2 id="261题目"><a class="markdownIt-Anchor" href="#261题目"></a> 26.1题目</h2>
<p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p>
<p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>
<p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [7,1,5,3,6,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。</span><br><span class="line">     总利润为 4 + 3 = 7 。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span><br><span class="line">     总利润为 4 。</span><br></pre></td></tr></table></figure>
<h2 id="262解法动规"><a class="markdownIt-Anchor" href="#262解法动规"></a> 26.2解法：动规</h2>
<h3 id="2621动规思路"><a class="markdownIt-Anchor" href="#2621动规思路"></a> 26.2.1动规思路</h3>
<ol>
<li>
<p>确定dp数组以及下标含义：</p>
<p><mark>dp(i)(0)表示第i天持有股票时，所得最多的现金</mark></p>
<p><mark>dp(i)(1)表示第i天不持有股票时，所得最多的现金</mark></p>
</li>
<li>
<p>确定递推公式：</p>
<p><mark>注意：因为<strong>一只股票可以买卖多次</strong>，所以今天买入股票所得的金额必须为dp(i-1)(0)-prices[i]</mark></p>
<p>前一天持有股票时所得最多的现金/今天持有股票：dp(i)(0)=Math.max（ dp(i-1)(0) ，dp(i-1)(0)-prices[i] ）</p>
<p>前一天不持有股票/今天卖股票：dp(i)(1)=Math.max（ dp(i-1)(1)，dp(i-1)(0)+prices[i] ）</p>
</li>
<li>
<p>dp数组初始化：dp(0)(0)=-prices[0]，dp(0)(1)=0</p>
</li>
<li>
<p>确定遍历顺序：从前往后</p>
</li>
</ol>
<h3 id="2622代码实现"><a class="markdownIt-Anchor" href="#2622代码实现"></a> 26.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(prices.length==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">       dp[<span class="number">0</span>][<span class="number">0</span>]-=prices[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">           dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">           dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="27买卖股票的最佳时机"><a class="markdownIt-Anchor" href="#27买卖股票的最佳时机"></a> 27.买卖股票的最佳时机|||</h1>
<h2 id="271题目"><a class="markdownIt-Anchor" href="#271题目"></a> 27.1题目</h2>
<p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p>
<p>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。</span><br><span class="line">     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   </span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票</span><br></pre></td></tr></table></figure>
<h2 id="272解法动规"><a class="markdownIt-Anchor" href="#272解法动规"></a> 27.2解法：动规</h2>
<h3 id="2721动规思路"><a class="markdownIt-Anchor" href="#2721动规思路"></a> 27.2.1动规思路</h3>
<ol>
<li>
<p>确定dp数组以及下标含义：第一次买入、第一次卖出、第二次买入、第二次卖出</p>
</li>
<li>
<p>确定递推公式：</p>
<ol>
<li>例如：dp(i)(1)：有两种情况，前一天已经是第一次买入股票状态了，或者前一天没有操作，今天第一次买入股票，即dp(i)1)=max（ dp(i-1)(1)，dp(i-1)(0)-prices[i] ）</li>
<li>综上：<img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240610210353931.png" alt="image-20240610210353931" /></li>
</ol>
</li>
<li>
<p>dp数组初始化：dp(0)(1)=dp(0)(3)=-prices[0]</p>
</li>
<li>
<p>确定遍历顺序：从前往后</p>
</li>
</ol>
<h3 id="2722代码实现"><a class="markdownIt-Anchor" href="#2722代码实现"></a> 27.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">       <span class="type">int</span> len=prices.length;</span><br><span class="line">       <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[len][<span class="number">5</span>];</span><br><span class="line">       <span class="comment">//4个状态：第一次买入、第一次卖出、第二次买入、第二次卖出</span></span><br><span class="line">       dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">       dp[<span class="number">0</span>][<span class="number">3</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">           dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">           dp[i][<span class="number">2</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">2</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">           dp[i][<span class="number">3</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">3</span>],dp[i-<span class="number">1</span>][<span class="number">2</span>]-prices[i]);</span><br><span class="line">           dp[i][<span class="number">4</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">4</span>],dp[i-<span class="number">1</span>][<span class="number">3</span>]+prices[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[len-<span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="28买卖股票的最佳时机iv"><a class="markdownIt-Anchor" href="#28买卖股票的最佳时机iv"></a> 28.买卖股票的最佳时机IV</h1>
<h2 id="281题目"><a class="markdownIt-Anchor" href="#281题目"></a> 28.1题目</h2>
<p>给你一个整数数组 <code>prices</code> 和一个整数 <code>k</code> ，其中 <code>prices[i]</code> 是某支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。</p>
<p>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = 2, prices = [2,4,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：k = 2, prices = [3,2,6,5,0,3]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。</span><br><span class="line">     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</span><br></pre></td></tr></table></figure>
<h2 id="282解法动规"><a class="markdownIt-Anchor" href="#282解法动规"></a> 28.2解法：动规</h2>
<h3 id="2821动规思路"><a class="markdownIt-Anchor" href="#2821动规思路"></a> 28.2.1动规思路</h3>
<ol>
<li>
<p>确定dp数组以及下标含义：dp(i)(股票状态)</p>
<p>i为天数、股票状态中奇数表示第k次交易持有股票、偶数表示第k次交易不持有股票</p>
</li>
<li>
<p>确定递归公式；其中j为第k次交易，j累加2，一直为偶数：0、2、4…</p>
<p>奇数：dp(i)(j+1)=max( dp(i-1)(j+1)，dp(i-1)(j)-prices[i] )</p>
<p>偶数：dp(i)(j+2)=max( dp(i-1)(j+2)，dp(i-1)(j+1)+prices[i])</p>
</li>
<li>
<p>dp数组初始化：dp(i)(奇数)=-prices[0]</p>
</li>
<li>
<p>确定遍历顺序：从前往后</p>
</li>
</ol>
<h3 id="2822代码实现"><a class="markdownIt-Anchor" href="#2822代码实现"></a> 28.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">       <span class="type">int</span> len=prices.length;</span><br><span class="line">       <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[len][<span class="number">2</span>*k+<span class="number">1</span>];</span><br><span class="line">       <span class="comment">//dp数组初始化，奇数次买入为负</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*k;i+=<span class="number">2</span>)&#123;</span><br><span class="line">           dp[<span class="number">0</span>][i+<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>*k;j+=<span class="number">2</span>)&#123;</span><br><span class="line">               dp[i][j+<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][j+<span class="number">1</span>],dp[i-<span class="number">1</span>][j]-prices[i]);</span><br><span class="line">               dp[i][j+<span class="number">2</span>]=Math.max(dp[i-<span class="number">1</span>][j+<span class="number">2</span>],dp[i-<span class="number">1</span>][j+<span class="number">1</span>]+prices[i]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[len-<span class="number">1</span>][<span class="number">2</span>*k];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="29买卖股票的最佳时机含冷冻期"><a class="markdownIt-Anchor" href="#29买卖股票的最佳时机含冷冻期"></a> 29.买卖股票的最佳时机含冷冻期</h1>
<h2 id="291题目"><a class="markdownIt-Anchor" href="#291题目"></a> 29.1题目</h2>
<p>给定一个整数数组<code>prices</code>，其中第 <code>prices[i]</code> 表示第 <code>*i*</code> 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<p>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>
<h2 id="292解法"><a class="markdownIt-Anchor" href="#292解法"></a> 29.2解法</h2>
<h3 id="2921动规思路"><a class="markdownIt-Anchor" href="#2921动规思路"></a> 29.2.1动规思路</h3>
<ol>
<li>
<p>确定dp数组以及下标含义：dp(i)(股票状态)</p>
<p>i为天数、股票状态有四种：</p>
<ul>
<li>状态一：持有股票（今天买入、之前就买入了）</li>
<li>状态二：保持卖出股票状态（两天前卖出股票，度过一天冷冻期）</li>
<li>状态三：今天卖出股票</li>
<li>状态四：今天为冷冻期</li>
</ul>
</li>
<li>
<p>确定递归公式；</p>
<ul>
<li>持有股票状态：
<ul>
<li>情况一：前一天就是持有股票状态</li>
<li>情况二：今天买入，前一天是冷冻期</li>
<li>情况三：今天买入，前一天是保持卖出股票状态</li>
<li>dp(i)(0)=max（dp(i-1)(0)，max（dp(i-1)(3)-prices[i]，dp(i-1)(1)-prices[i]）</li>
</ul>
</li>
<li>卖出股票状态：
<ul>
<li>情况一：前一天就是保持卖出股票状态</li>
<li>情况二：前一天是冷冻期</li>
<li>dp(i)(1)=max（dp(i-1)(1)，dp(i-1)(2)）</li>
</ul>
</li>
<li>今天卖出股票状态：
<ul>
<li>dp(i)(2)=dp(i-1)(0)+prices[i]</li>
</ul>
</li>
<li>冷冻期：前一天卖出
<ul>
<li>dp(i)(3)=dp(i-1)(2)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>dp数组初始化：dp(0)(0)=-prices[0]</p>
</li>
<li>
<p>确定遍历顺序：从前往后</p>
</li>
</ol>
<h3 id="2922代码实现"><a class="markdownIt-Anchor" href="#2922代码实现"></a> 29.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">       <span class="type">int</span> len=prices.length;</span><br><span class="line">       <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[len][<span class="number">4</span>];</span><br><span class="line">       dp[<span class="number">0</span>][<span class="number">0</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">           dp[i][<span class="number">0</span>]=Math.max( dp[i-<span class="number">1</span>][<span class="number">0</span>], Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i],dp[i-<span class="number">1</span>][<span class="number">3</span>]-prices[i]));</span><br><span class="line">           dp[i][<span class="number">1</span>]=Math.max( dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">           dp[i][<span class="number">2</span>]=dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i];</span><br><span class="line">           dp[i][<span class="number">3</span>]=dp[i-<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Math.max(dp[len-<span class="number">1</span>][<span class="number">1</span>],Math.max(dp[len-<span class="number">1</span>][<span class="number">2</span>],dp[len-<span class="number">1</span>][<span class="number">3</span>]));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="30买卖股票的最佳时机含手续费"><a class="markdownIt-Anchor" href="#30买卖股票的最佳时机含手续费"></a> 30.买卖股票的最佳时机含手续费</h1>
<h2 id="301题目"><a class="markdownIt-Anchor" href="#301题目"></a> 30.1题目</h2>
<p>给定一个整数数组 <code>prices</code>，其中 <code>prices[i]</code>表示第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1, 3, 2, 8, 4, 9], fee = 2</span><br><span class="line">输出：8</span><br><span class="line">解释：能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] = 1</span><br><span class="line">在此处卖出 prices[3] = 8</span><br><span class="line">在此处买入 prices[4] = 4</span><br><span class="line">在此处卖出 prices[5] = 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1,3,7,5,10,3], fee = 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>
<h2 id="302解法动规"><a class="markdownIt-Anchor" href="#302解法动规"></a> 30.2解法：动规</h2>
<h3 id="3021动规思路"><a class="markdownIt-Anchor" href="#3021动规思路"></a> 30.2.1动规思路</h3>
<ol>
<li>
<p>确定dp数组以及下标含义：</p>
<p><mark>dp(i)(0)表示第i天持有股票时，所得最多的现金</mark></p>
<p><mark>dp(i)(1)表示第i天不持有股票时，所得最多的现金</mark></p>
</li>
<li>
<p>确定递推公式：</p>
<p><mark>注意：因为<strong>一只股票可以买卖多次</strong>，所以今天买入股票所得的金额必须为dp(i-1)(0)-prices[i]</mark></p>
<p><mark><strong>注意：卖出股票时需要收取手续费！！！</strong></mark></p>
<p>前一天持有股票时所得最多的现金/今天持有股票：dp(i)(0)=Math.max（ dp(i-1)(0) ，dp(i-1)(0)-prices[i] ）</p>
<p>前一天不持有股票/今天卖股票：dp(i)(1)=Math.max（ dp(i-1)(1)，dp(i-1)(0)+prices[i]-free ）</p>
</li>
<li>
<p>dp数组初始化：dp(0)(0)=-prices[0]，dp(0)(1)=0</p>
</li>
<li>
<p>确定遍历顺序：从前往后</p>
</li>
</ol>
<h3 id="3022代码实现"><a class="markdownIt-Anchor" href="#3022代码实现"></a> 30.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices,<span class="type">int</span> free)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(prices.length==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">       dp[<span class="number">0</span>][<span class="number">0</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">           dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">           dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i]-free);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="31最长递增子序列"><a class="markdownIt-Anchor" href="#31最长递增子序列"></a> 31.最长递增子序列</h1>
<h2 id="311题目"><a class="markdownIt-Anchor" href="#311题目"></a> 31.1题目</h2>
<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的</p>
<p>子序列。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
<h2 id="322解法动规"><a class="markdownIt-Anchor" href="#322解法动规"></a> 32.2解法：动规</h2>
<h3 id="3221动规思路"><a class="markdownIt-Anchor" href="#3221动规思路"></a> 32.2.1动规思路</h3>
<ol>
<li>
<p>确定dp数组以及下标含义：</p>
<p>dp[i]：表示i之前（包括i）的以nums[i]结尾的最长递增子序列的长度</p>
</li>
<li>
<p>确定递归函数</p>
<p>位置i的最长升序子序列等于<mark>j从0到i-1各个位置的最长升序子序列 + <strong>1</strong> 的最大值</mark>。</p>
</li>
<li>
<p>dp数组初始化：</p>
<p>每一个i，对应的dp[i]（即最长递增子序列）起始大小至少都是1.</p>
</li>
<li>
<p>确定遍历顺序：</p>
<p>外层循环数组的每个元素从前往后，内层循环也从前往后</p>
</li>
</ol>
<h3 id="3222代码实现"><a class="markdownIt-Anchor" href="#3222代码实现"></a> 32.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="type">int</span>  len=nums.length;</span><br><span class="line">       <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">       Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">       <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[i]&gt;nums[j])&#123;</span><br><span class="line">                   dp[i]=Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(result&lt;dp[i])&#123;</span><br><span class="line">               result=dp[i];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="32最长连续递增子序列"><a class="markdownIt-Anchor" href="#32最长连续递增子序列"></a> 32.最长连续递增子序列</h1>
<h2 id="321题目"><a class="markdownIt-Anchor" href="#321题目"></a> 32.1题目</h2>
<p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p>
<p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,5,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：最长连续递增序列是 [1,3,5], 长度为3。</span><br><span class="line">尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 </span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,2,2,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：最长连续递增序列是 [2], 长度为1。</span><br></pre></td></tr></table></figure>
<h2 id="322解法动规-2"><a class="markdownIt-Anchor" href="#322解法动规-2"></a> 32.2解法：动规</h2>
<h3 id="3221动规思路-2"><a class="markdownIt-Anchor" href="#3221动规思路-2"></a> 32.2.1动规思路</h3>
<ol>
<li>
<p>该题和上一题的区别：该题要求求连续递增的子序列，所以求数组每个元素的状态时，不用遍历该元素前的全部元素，只需要和上一个元素比较</p>
</li>
<li>
<p>确定dp数组以及下标含义：</p>
<p>dp[i]：表示i之前（包括i）的以nums[i]结尾的最长连续递增子序列的长度</p>
</li>
<li>
<p>确定递归函数</p>
<p>如果 nums[i] &gt; nums[i - 1]，那么以 i 为结尾的连续递增的子序列长度 一定等于 以i - 1为结尾的连续递增的子序列长度 + 1 。</p>
<p>即：dp[i] = dp[i - 1] + 1;</p>
</li>
<li>
<p>dp数组初始化：</p>
<p>每一个i，对应的dp[i]（即最长递增子序列）起始大小至少都是1.</p>
</li>
<li>
<p>确定遍历顺序：从前往后</p>
</li>
</ol>
<h3 id="3222代码实现-2"><a class="markdownIt-Anchor" href="#3222代码实现-2"></a> 32.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="type">int</span> len=nums.length;</span><br><span class="line">       <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">       Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">       <span class="type">int</span> result=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[i]&gt;nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">               dp[i]=dp[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(result&lt;dp[i])&#123;</span><br><span class="line">               result=dp[i];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="33最长重复子数组"><a class="markdownIt-Anchor" href="#33最长重复子数组"></a> 33.最长重复子数组</h1>
<h2 id="331题目"><a class="markdownIt-Anchor" href="#331题目"></a> 33.1题目</h2>
<p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度</em> 。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：长度最长的公共子数组是 [3,2,1] 。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<h2 id="332解法动规"><a class="markdownIt-Anchor" href="#332解法动规"></a> 33.2解法：动规</h2>
<h3 id="3321动规思路"><a class="markdownIt-Anchor" href="#3321动规思路"></a> 33.2.1动规思路</h3>
<ol>
<li>
<p>确定dp数组以及下标含义：</p>
<p>dp(i)(j) ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp(i)(j) 。</p>
</li>
<li>
<p>确定递推公式（子数组必须是连续的，即只能从前一个元素得出）：</p>
<p>当A[i - 1] 和B[j - 1]相等的时候，dp(i)(j) = dp(i-1)(j-1) + 1;</p>
<p>根据递推公式可以看出，遍历i 和 j 要从1开始！</p>
</li>
<li>
<p>dp数组初始化：dp(i)(0)和dp(0)(j)均没有意义</p>
</li>
<li>
<p>确定遍历顺序：外层for循环遍历A，内层for循环遍历B。</p>
</li>
</ol>
<h3 id="3322代码实现"><a class="markdownIt-Anchor" href="#3322代码实现"></a> 33.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">       <span class="type">int</span> len1=nums1.length;</span><br><span class="line">       <span class="type">int</span> len2=nums2.length;</span><br><span class="line">       <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">       <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len1;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=len2;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums1[i-<span class="number">1</span>]==nums2[j-<span class="number">1</span>])&#123;</span><br><span class="line">                   dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">if</span>(result&lt;dp[i][j])&#123;</span><br><span class="line">                       result=dp[i][j];</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="34最长公共子序列"><a class="markdownIt-Anchor" href="#34最长公共子序列"></a> 34.最长公共子序列</h1>
<h2 id="341题目"><a class="markdownIt-Anchor" href="#341题目"></a> 34.1题目</h2>
<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>
<p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li>
</ul>
<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3</span><br></pre></td></tr></table></figure>
<h2 id="342解法动规"><a class="markdownIt-Anchor" href="#342解法动规"></a> 34.2解法：动规</h2>
<h3 id="3421动规思路"><a class="markdownIt-Anchor" href="#3421动规思路"></a> 34.2.1动规思路</h3>
<ol>
<li>
<p>首先明确该题和上一题：最长重复子数组的区别：该题不要求连续，上一题需要</p>
</li>
<li>
<p>子序列：有顺序的序列，即ace是abcde的子序列，但是aec并不是子序列</p>
</li>
<li>
<p>确定dp数组以及下标含义：</p>
<p>dp(i)(j)：以下标i-1为结尾的A数组，和以下标j-1为结尾的B数组，最长公共子序列长度为dp(i)(j)</p>
</li>
<li>
<p>确定递推公式（不要求连续）</p>
<ol>
<li>情况一：A[I-1]==B[j-1]，即dp(i)(j)=dp(i-1)(j-1)+1</li>
<li>情况二：A[I-1]!=B[j-1]，即dp(i)(j)=Math.max( dp(i-1)(j)，dp(i)(j-1))</li>
</ol>
</li>
<li>
<p>dp数组初始化：dp(i)(0)和dp(0)(j)均没有意义</p>
</li>
<li>
<p>确定遍历顺序：外层for循环遍历A，内层for循环遍历B</p>
</li>
<li>
<p>举例推导：</p>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240628212603954.png" alt="image-20240628212603954" /></p>
</li>
</ol>
<h3 id="3422代码实现"><a class="markdownIt-Anchor" href="#3422代码实现"></a> 34.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[text1.length()+<span class="number">1</span>][text2.length()+<span class="number">1</span>];</span><br><span class="line">       <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=text1.length();i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=text2.length();j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(text1.charAt(i-<span class="number">1</span>)==text2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                   dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(dp[i][j]&gt;result)&#123;</span><br><span class="line">                   result=dp[i][j];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="35最大子数组和"><a class="markdownIt-Anchor" href="#35最大子数组和"></a> 35.最大子数组和</h1>
<h2 id="351题目"><a class="markdownIt-Anchor" href="#351题目"></a> 35.1题目</h2>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong></p>
<p>是数组中的一个连续部分。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 </span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<h2 id="352解法动规"><a class="markdownIt-Anchor" href="#352解法动规"></a> 35.2解法：动规</h2>
<h3 id="3521动规思路"><a class="markdownIt-Anchor" href="#3521动规思路"></a> 35.2.1动规思路</h3>
<ol>
<li>
<p>确定dp数组以及下标含义：</p>
<p>dp[i]：下标为i的子数组的最大子数组和为dp[i]</p>
</li>
<li>
<p>确定递推公式：dp[i]=Math.max( dp[i-1]+nums[i]，nums[i])</p>
</li>
<li>
<p>dp数组初始化：dp[0]=Math.max(0,nums[i])</p>
</li>
<li>
<p>确定遍历顺序：从前往后</p>
</li>
<li>
<p>举例推导：</p>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240628212440809.png" alt="image-20240628212440809" /></p>
</li>
</ol>
<h3 id="3522代码实现"><a class="markdownIt-Anchor" href="#3522代码实现"></a> 35.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">       <span class="type">int</span> result=nums[<span class="number">0</span>];</span><br><span class="line">       dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           dp[i]=Math.max(dp[i-<span class="number">1</span>]+nums[i],nums[i]);</span><br><span class="line">           result=Math.max(result,dp[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="36判断子序列"><a class="markdownIt-Anchor" href="#36判断子序列"></a> 36.判断子序列</h1>
<h2 id="361题目"><a class="markdownIt-Anchor" href="#361题目"></a> 36.1题目</h2>
<p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p>
<p><strong>进阶：</strong></p>
<p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;axc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<h2 id="362解法动规"><a class="markdownIt-Anchor" href="#362解法动规"></a> 36.2解法：动规</h2>
<h3 id="3621动规思路"><a class="markdownIt-Anchor" href="#3621动规思路"></a> 36.2.1动规思路</h3>
<ol>
<li>
<p>确定dp数组以及下标含义:</p>
<p>dp(i)(j)：表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同的子序列的长度为dp(i)(j)</p>
</li>
<li>
<p>确定递推公式：</p>
<p>2.1 s[i-1]=t[j-1]：t中找到了一个字符，在s中也出现，即dp(i)(j)=dp(i-1)(j-1)+1</p>
<p>2.2 s[i-1]!=t[j-1]：t下标j-1位置的字符和s下标i-1位置的字符不同，即dp(i)(j)=dp(i)(j-1)</p>
</li>
<li>
<p>dp数组初始化：dp(i)(0)和dp(0)(j)位置的元素没有意义</p>
</li>
<li>
<p>确定遍历顺序：从上到下</p>
</li>
<li>
<p>举例推导：</p>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240628212343012.png" alt="image-20240628212343012" /></p>
</li>
</ol>
<h3 id="3622代码实现"><a class="markdownIt-Anchor" href="#3622代码实现"></a> 36.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()+<span class="number">1</span>][t.length()+<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.length();i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=t.length();j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>)==t.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                   dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   dp[i][j]=dp[i][j-<span class="number">1</span>];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[s.length()][t.length()]==s.length();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="37不同的子序列"><a class="markdownIt-Anchor" href="#37不同的子序列"></a> 37.不同的子序列</h1>
<h2 id="371题目"><a class="markdownIt-Anchor" href="#371题目"></a> 37.1题目</h2>
<p>给你两个字符串 <code>s</code> 和 <code>t</code> ，统计并返回在 <code>s</code> 的 <strong>子序列</strong> 中 <code>t</code> 出现的个数，结果需要对 109 + 7 取模。</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">如下所示, 有 3 种可以从 s 中得到 &quot;rabbit&quot; 的方案。</span><br><span class="line">rabbbit</span><br><span class="line">rabbbit</span><br><span class="line">rabbbit</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;babgbag&quot;, t = &quot;bag&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">如下所示, 有 5 种可以从 s 中得到 &quot;bag&quot; 的方案。 </span><br><span class="line">babgbag</span><br><span class="line">babgbag</span><br><span class="line">babgbag</span><br><span class="line">babgbag</span><br><span class="line">babgbag</span><br></pre></td></tr></table></figure>
<h2 id="372解法动规"><a class="markdownIt-Anchor" href="#372解法动规"></a> 37.2解法：动规</h2>
<h3 id="3721动规思路"><a class="markdownIt-Anchor" href="#3721动规思路"></a> 37.2.1动规思路</h3>
<ol>
<li>
<p>求解：求子序列s组装成t的几种方法！！！</p>
</li>
<li>
<p>确定dp数组以及下标含义：</p>
<p>dp(i)(j)：以下标i-1为结尾的s子序列中 <mark><strong>出现</strong></mark>  以下标j-1为结尾的t子序列的个数 为dp(i)(j)</p>
</li>
<li>
<p>确定递推公式：</p>
<p>3.1 s[i-1]=j[j-1]：两种情况，取s[i-1]或不取，即dp(i)(j)=dp(i-1)(j-1)+dp(i-1)(j)</p>
<p>3.2 s[i-1]!=[j-1]：只能不取s[i-1]，即dp(i)(j)=dp(i-1)(j)</p>
</li>
<li>
<p>dp数组初始化：</p>
<p>dp(i)(0)：子序列s组装成空串的方法肯定有一种</p>
<p>dp(0)(j)：无意义</p>
</li>
<li>
<p>确定遍历顺序：从上到下</p>
</li>
<li>
<p>举例推导：</p>
<p><img src="https://gitee.com/linhaipengg/md_-picture/raw/master/image-20240628215052748.png" alt="image-20240628215052748" /></p>
</li>
</ol>
<h3 id="3722代码实现"><a class="markdownIt-Anchor" href="#3722代码实现"></a> 37.2.2代码实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()+<span class="number">1</span>][t.length()+<span class="number">1</span>];</span><br><span class="line">       <span class="comment">//初始化</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=s.length();i++)&#123;</span><br><span class="line">           dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.length();i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=t.length();j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>)==t.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                   <span class="comment">//两种情况：取/不取</span></span><br><span class="line">                   dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+dp[i-<span class="number">1</span>][j];</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[s.length()][t.length()];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>动态规划思想</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://www.haipeng-lin.cn/posts/8a9d5576.html">https://www.haipeng-lin.cn/posts/8a9d5576.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a" style="display: inline-block;width: 120px"><h>作者</h><div class="post-copyright-cc-info"><h>拾忆鱼</h></div></div><div class="post-copyright-c" style="display: inline-block;width: 120px"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-08-29</h></div></div><div class="post-copyright-u" style="display: inline-block;width: 120px"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-09-01</h></div></div><div class="post-copyright-c" style="display: inline-block;width: 120px"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/linhaipengg/md_-picture/raw/master/算法.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/73952078.html"><img class="prev-cover" src="https://gitee.com/linhaipengg/md_-picture/raw/master/算法.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">贪心思想</div></div></a></div><div class="next-post pull-right"><a href="/posts/f7912a82.html"><img class="next-cover" src="https://gitee.com/linhaipengg/md_-picture/raw/master/算法.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">力扣刷题</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410101530409.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">拾忆鱼</div><div class="author-info__description">一条菜鱼的小破站</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">小菜鱼正在从CSDN博客搬家，尽请期待　　      地址：<a target="_blank" rel="noopener" href="https://haipeng-lin.blog.csdn.net/">haipeng-lin.blog.csdn.net</a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text"> 动态规划</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-text"> 1.动态规划理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB%E5%A4%A7%E7%BA%B2"><span class="toc-text"> 1.1题目分类大纲</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text"> 1.2什么是动态规划？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text"> 1.3背包问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4"><span class="toc-text"> 1.4解题步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95debug"><span class="toc-text"> 1.5动态规划应该如何debug？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="toc-text"> 2.斐波那契数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E9%A2%98%E7%9B%AE"><span class="toc-text"> 2.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E8%A7%A3%E6%B3%95%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text"> 2.2解法：动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#221%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%9D%E8%B7%AF"><span class="toc-text"> 2.2.1动态规划思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E7%A1%AE%E5%AE%9Adp%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E4%B8%8B%E6%A0%87%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-text"> （1）确定dp数组以及下标的含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%A1%AE%E5%AE%9A%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F"><span class="toc-text"> （2）确定递推公式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3dp%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text"> （3）dp数组初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E7%A1%AE%E5%AE%9A%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F"><span class="toc-text"> （4）确定遍历顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E4%B8%BE%E4%BE%8B%E6%8E%A8%E5%AF%BCdp%E6%95%B0%E7%BB%84"><span class="toc-text"> （5）举例推导dp数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#222%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 2.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-text"> 3.爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E9%A2%98%E7%9B%AE"><span class="toc-text"> 3.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 3.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#321%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 3.2.1动规思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E7%A1%AE%E5%AE%9Adp%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E4%B8%8B%E6%A0%87%E7%9A%84%E5%90%AB%E4%B9%89-2"><span class="toc-text"> （1）确定dp数组以及下标的含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%A1%AE%E5%AE%9A%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F-2"><span class="toc-text"> （2）确定递推公式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3dp%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96-2"><span class="toc-text"> （3）dp数组初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E7%A1%AE%E5%AE%9A%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F-2"><span class="toc-text"> （4）确定遍历顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E4%B8%BE%E4%BE%8B%E6%8E%A8%E5%AF%BCdp%E6%95%B0%E7%BB%84-2"><span class="toc-text"> （5）举例推导dp数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#322%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 3.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-text"> 4.使用最小花费爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41%E9%A2%98%E7%9B%AE"><span class="toc-text"> 4.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 4.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#421%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 4.2.1动规思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E7%A1%AE%E5%AE%9Adp%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E4%B8%8B%E6%A0%87%E7%9A%84%E5%90%AB%E4%B9%89-3"><span class="toc-text"> （1）确定dp数组以及下标的含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%A1%AE%E5%AE%9A%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F-3"><span class="toc-text"> （2）确定递推公式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3dp%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96-3"><span class="toc-text"> （3）dp数组初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E7%A1%AE%E5%AE%9A%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F-3"><span class="toc-text"> （4）确定遍历顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E4%B8%BE%E4%BE%8B%E6%8E%A8%E5%AF%BCdp%E6%95%B0%E7%BB%84-3"><span class="toc-text"> （5）举例推导dp数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#422%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 4.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-text"> 5.不同路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51%E9%A2%98%E7%9B%AE"><span class="toc-text"> 5.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52%E8%A7%A3%E6%B3%95%E4%B8%80%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2"><span class="toc-text"> 5.2解法一：深度搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#521%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2%E6%80%9D%E8%B7%AF"><span class="toc-text"> 5.2.1深度搜索思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#522%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 5.2.2代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53%E8%A7%A3%E6%B3%95%E4%BA%8C%E5%8A%A8%E8%A7%84"><span class="toc-text"> 5.3解法二：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#531%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 5.3.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#532%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 5.3.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-text"> 6.不同路径||</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#61%E9%A2%98%E7%9B%AE"><span class="toc-text"> 6.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 6.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#621%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 6.2.1动规思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1dp%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E4%B8%8B%E6%A0%87%E5%90%AB%E4%B9%89"><span class="toc-text"> （1）dp数组以及下标含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F"><span class="toc-text"> （2）递推公式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3dp%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96-4"><span class="toc-text"> （3）dp数组初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E7%A1%AE%E5%AE%9A%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F-4"><span class="toc-text"> （4）确定遍历顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E4%B8%BE%E4%BE%8B%E6%8E%A8%E5%88%B0dp%E6%95%B0%E7%BB%84"><span class="toc-text"> （5）举例推到dp数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#622%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 6.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-text"> 7.整数拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#71%E9%A2%98%E7%9B%AE"><span class="toc-text"> 7.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 7.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#721%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 7.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#722%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 7.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text"> 8.不同的二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#81%E9%A2%98%E7%9B%AE"><span class="toc-text"> 8.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 8.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#821%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 8.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#822%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 8.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#90-1%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-text"> 9.0-1背包理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#91%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%88%86%E7%B1%BB"><span class="toc-text"> 9.1背包问题分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92-01%E8%83%8C%E5%8C%85%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text"> 9.2 01背包（二维数组）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#921%E9%97%AE%E9%A2%98"><span class="toc-text"> 9.2.1问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#922%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 9.2.2动规思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#93%E5%8F%98%E6%8D%A2%E9%A2%98%E7%9B%AE"><span class="toc-text"> 9.3变换题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#931%E9%A2%98%E7%9B%AE"><span class="toc-text"> 9.3.1题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#932%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 9.3.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-text"> 10.分割等和子集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#101%E9%A2%98%E7%9B%AE"><span class="toc-text"> 10.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 10.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1021%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 10.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1022%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 10.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F"><span class="toc-text"> 11.最后一块石头的重量||</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#111%E9%A2%98%E7%9B%AE"><span class="toc-text"> 11.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#112%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 11.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1121%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 11.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1122%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 11.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-text"> 12.目标和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#121%E9%A2%98%E7%9B%AE"><span class="toc-text"> 12.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#122%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 12.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1221%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 12.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1222%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 12.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13%E4%B8%80%E5%92%8C%E9%9B%B6"><span class="toc-text"> 13.一和零</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#131%E9%A2%98%E7%9B%AE"><span class="toc-text"> 13.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#132%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 13.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1321%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 13.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1322%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 13.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#140-1%E8%83%8C%E5%8C%85%E4%BE%8B%E9%A2%98%E5%B0%8F%E7%BB%93"><span class="toc-text"> 14.0-1背包例题小结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-text"> 15.完全背包理论基础</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-text"> 16.零钱兑换||</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#161%E9%A2%98%E7%9B%AE"><span class="toc-text"> 16.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#162%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 16.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1621%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 16.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1622%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 16.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Civ"><span class="toc-text"> 17.组合总和IV</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#171%E9%A2%98%E7%9B%AE"><span class="toc-text"> 17.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#172%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 17.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1721%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 17.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1722%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 17.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18%E7%88%AC%E6%A5%BC%E6%A2%AF%E8%BF%9B%E9%98%B6%E7%89%88"><span class="toc-text"> 18.爬楼梯（进阶版）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#181%E9%A2%98%E7%9B%AE"><span class="toc-text"> 18.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#182%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 18.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1821%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 18.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1822%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 18.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-text"> 19.零钱兑换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#191%E9%A2%98%E7%9B%AE"><span class="toc-text"> 19.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#192%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 19.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1921%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 19.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1922%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 19.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-text"> 20.完全平方数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#201%E9%A2%98%E7%9B%AE"><span class="toc-text"> 20.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#202%E8%A7%A3%E6%B3%95"><span class="toc-text"> 20.2解法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2021%E8%A7%A3%E6%B3%95%E6%80%9D%E8%B7%AF%E5%8A%A8%E8%A7%84"><span class="toc-text"> 20.2.1解法思路：动规</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2022%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 20.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="toc-text"> 21.单词拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#211%E9%A2%98%E7%9B%AE"><span class="toc-text"> 21.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#212%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 21.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2121%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 21.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2122%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 21.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-text"> 22.打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#221%E9%A2%98%E7%9B%AE"><span class="toc-text"> 22.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#222%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 22.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2221%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 22.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2222%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 22.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-text"> 23.打家劫舍||</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#231%E9%A2%98%E7%9B%AE"><span class="toc-text"> 23.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#232%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 23.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2321%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 23.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2322%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 23.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#24%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-text"> 24.打家劫舍|||</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#241%E9%A2%98%E7%9B%AE"><span class="toc-text"> 24.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#242%E8%A7%A3%E6%B3%95%E7%8A%B6%E6%80%81%E5%8A%A8%E8%A7%84"><span class="toc-text"> 24.2解法：状态动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2421%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 24.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2422%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 24.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#25%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-text"> 25.买卖股票的最佳时机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#251%E9%A2%98%E7%9B%AE"><span class="toc-text"> 25.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#252%E8%A7%A3%E6%B3%95%E4%B8%80%E8%B4%AA%E5%BF%83"><span class="toc-text"> 25.2解法一：贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2521%E8%B4%AA%E5%BF%83%E6%80%9D%E8%B7%AF"><span class="toc-text"> 25.2.1贪心思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2522%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 25.2.2代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#253%E8%A7%A3%E6%B3%95%E4%BA%8C%E5%8A%A8%E8%A7%84"><span class="toc-text"> 25.3解法二：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2531%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 25.3.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2532%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 25.3.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#26%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-text"> 26.买卖股票的最佳时机||</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#261%E9%A2%98%E7%9B%AE"><span class="toc-text"> 26.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#262%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 26.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2621%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 26.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2622%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 26.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#27%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-text"> 27.买卖股票的最佳时机|||</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#271%E9%A2%98%E7%9B%AE"><span class="toc-text"> 27.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#272%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 27.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2721%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 27.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2722%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 27.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#28%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAiv"><span class="toc-text"> 28.买卖股票的最佳时机IV</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#281%E9%A2%98%E7%9B%AE"><span class="toc-text"> 28.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#282%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 28.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2821%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 28.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2822%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 28.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#29%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F"><span class="toc-text"> 29.买卖股票的最佳时机含冷冻期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#291%E9%A2%98%E7%9B%AE"><span class="toc-text"> 29.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#292%E8%A7%A3%E6%B3%95"><span class="toc-text"> 29.2解法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2921%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 29.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2922%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 29.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#30%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9"><span class="toc-text"> 30.买卖股票的最佳时机含手续费</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#301%E9%A2%98%E7%9B%AE"><span class="toc-text"> 30.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#302%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 30.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3021%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 30.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3022%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 30.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#31%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text"> 31.最长递增子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#311%E9%A2%98%E7%9B%AE"><span class="toc-text"> 31.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#322%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 32.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3221%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 32.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3222%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 32.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#32%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text"> 32.最长连续递增子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#321%E9%A2%98%E7%9B%AE"><span class="toc-text"> 32.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#322%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84-2"><span class="toc-text"> 32.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3221%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF-2"><span class="toc-text"> 32.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3222%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-text"> 32.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-text"> 33.最长重复子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#331%E9%A2%98%E7%9B%AE"><span class="toc-text"> 33.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#332%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 33.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3321%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 33.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3322%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 33.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#34%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text"> 34.最长公共子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#341%E9%A2%98%E7%9B%AE"><span class="toc-text"> 34.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#342%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 34.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3421%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 34.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3422%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 34.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#35%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-text"> 35.最大子数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#351%E9%A2%98%E7%9B%AE"><span class="toc-text"> 35.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#352%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 35.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3521%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 35.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3522%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 35.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#36%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text"> 36.判断子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#361%E9%A2%98%E7%9B%AE"><span class="toc-text"> 36.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#362%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 36.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3621%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 36.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3622%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 36.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#37%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text"> 37.不同的子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#371%E9%A2%98%E7%9B%AE"><span class="toc-text"> 37.1题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#372%E8%A7%A3%E6%B3%95%E5%8A%A8%E8%A7%84"><span class="toc-text"> 37.2解法：动规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3721%E5%8A%A8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-text"> 37.2.1动规思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3722%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 37.2.2代码实现</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/2fccc80a.html" title="基于ES和Canal分别实现数据检索/同步"><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202411031858285.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于ES和Canal分别实现数据检索/同步"/></a><div class="content"><a class="title" href="/posts/2fccc80a.html" title="基于ES和Canal分别实现数据检索/同步">基于ES和Canal分别实现数据检索/同步</a><time datetime="2024-11-03T10:56:12.000Z" title="发表于 2024-11-03 18:56:12">2024-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/46ceb5bd.html" title="基于Redis实现用户活跃月/日排行榜"><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410291146967.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于Redis实现用户活跃月/日排行榜"/></a><div class="content"><a class="title" href="/posts/46ceb5bd.html" title="基于Redis实现用户活跃月/日排行榜">基于Redis实现用户活跃月/日排行榜</a><time datetime="2024-10-29T03:44:41.000Z" title="发表于 2024-10-29 11:44:41">2024-10-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8239deef.html" title="基于微信公众号+验证码实现微信登录"><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410282106730.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于微信公众号+验证码实现微信登录"/></a><div class="content"><a class="title" href="/posts/8239deef.html" title="基于微信公众号+验证码实现微信登录">基于微信公众号+验证码实现微信登录</a><time datetime="2024-10-28T13:05:25.000Z" title="发表于 2024-10-28 21:05:25">2024-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/172c1a2d.html" title="ElasticSearch学习笔记"><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410161138400.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ElasticSearch学习笔记"/></a><div class="content"><a class="title" href="/posts/172c1a2d.html" title="ElasticSearch学习笔记">ElasticSearch学习笔记</a><time datetime="2024-10-16T03:36:17.000Z" title="发表于 2024-10-16 11:36:17">2024-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/6982816f.html" title="RocketMQ学习笔记"><img src="https://haipeng-lin.oss-cn-shenzhen.aliyuncs.com/202410131719724.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RocketMQ学习笔记"/></a><div class="content"><a class="title" href="/posts/6982816f.html" title="RocketMQ学习笔记">RocketMQ学习笔记</a><time datetime="2024-10-13T09:17:30.000Z" title="发表于 2024-10-13 17:17:30">2024-10-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer-left"><div class="footer-title"><span>拾忆鱼's Blog | </span><span class="footer-copyright">&copy;2024 By 拾忆鱼</span></div><div class="wordcount"></div><span>拾忆鱼 已经写了 264.2k 字，</span><span>好像写完一本 钱钟书 的 《围城》 了啊</span></div><div id="footer-right"><div class="footer_custom_text"><div id="runtime"></div></div><div class="footer-totop"><i class="fas fa-chevron-up" onclick="rmf.scrollToTop()"></i></div><div class="footer-info"><p>使用Hexo框架 | 基于butterfly修改 | 萌ICP备20240730号</p><!--a(title='湘公网安备 2023003198号' href='http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=2023003198')= '湘公网安备 2023003198号'--><!--a(title='湘ICP备2023003198号' href='https://beian.miit.gov.cn/')= '湘ICP备2023003198号'--></div><div class="footer-service"><a title="51LA" target="_blank" rel="noopener" href="https://www.51.la"><img alt="51LA" src="https://gitee.com/linhaipengg/md_-picture/raw/master/51la.png"/></a><a title="CC BY-NC-SA 4.0" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><img alt="CC BY-NC-SA 4.0" src="https://img.june-pj.cn/img/2024/01/16/cc.webp"/></a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.haipeng-lin.cn',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.haipeng-lin.cn',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/twikoo/1.4.18/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script data-pjax src="/gitcalendar/js/gitcalendar.js"></script><script data-pjax src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/js/swiper.min.js"></script><script src="/js/footer.js"></script><script type="text/javascript" src="/js/main.js"></script><script data-pjax type="text/javascript" src="/js/essay/essay.js"></script><script data-pjax type="text/javascript" src="/js/essay/waterfall.js"></script><link rel="stylesheet" href="/css/swiper.css"><script data-pjax src="/js/categoryBar/categoryBar.js"></script><link data-pjax defer="" rel="stylesheet" href="/css/categoryBar/heoMainColor.css"><link data-pjax defer="" rel="stylesheet" href="/css/categoryBar/categoryBar.css"><script type="text/javascript" src="/js/nav.js"></script><script src="/js/countup.js"></script><script data-pjax type="text/javascript" src="/js/memos/waterfall.min.js"></script><script data-pjax type="text/javascript" src="/js/memos/imgStatus.min.js"></script><script data-pjax type="text/javascript" src="/js/memos/lately.min.js"></script><script type="text/javascript" src="/js/memos/photo.js"></script><script type="text/javascript" src="/js/icat.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>